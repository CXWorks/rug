{"dependencies":{"<&'a ArrayBase<S, D> as zip::IntoNdProducer>::into_producer":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<&'a [A] as zip::IntoNdProducer>::into_producer":[],"<&'a [usize] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<&'a [usize] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<&'a dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<&'a dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<&'a dimension::dynindeximpl::IxDynImpl as std::iter::IntoIterator>::into_iter":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a mut ArrayBase<S, D> as zip::IntoNdProducer>::into_producer":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<&'a mut T as argument_traits::AssignElem<T>>::assign_elem":[],"<&'a mut [A] as zip::IntoNdProducer>::into_producer":[],"<&'a mut std::mem::MaybeUninit<T> as argument_traits::AssignElem<T>>::assign_elem":["std::marker::Sized","std::mem::MaybeUninit"],"<&'a mut std::vec::Vec<A> as zip::IntoNdProducer>::into_producer":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<&'a std::cell::Cell<T> as argument_traits::AssignElem<T>>::assign_elem":["std::cell::Cell"],"<&'a std::vec::Vec<A> as zip::IntoNdProducer>::into_producer":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::get":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::index":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::uget":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<&T as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do5>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>,) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<() as dimension::conversion::IntoDimension>::into_dimension":[],"<() as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<() as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_unchecked":["dimension::dim::Dim"],"<() as slice::MultiSlice<'a, A, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<(A, B) as zip::OffsetTuple>::stride_offset":[],"<(A, B) as zip::ZippableTuple>::as_ptr":[],"<(A, B) as zip::ZippableTuple>::as_ref":[],"<(A, B) as zip::ZippableTuple>::contiguous_stride":[],"<(A, B) as zip::ZippableTuple>::split_at":["dimension::axis::Axis"],"<(A, B) as zip::ZippableTuple>::stride_of":[],"<(A, B) as zip::ZippableTuple>::uget_ptr":[],"<(A, B, C) as zip::OffsetTuple>::stride_offset":[],"<(A, B, C) as zip::ZippableTuple>::as_ptr":[],"<(A, B, C) as zip::ZippableTuple>::as_ref":[],"<(A, B, C) as zip::ZippableTuple>::contiguous_stride":[],"<(A, B, C) as zip::ZippableTuple>::split_at":["dimension::axis::Axis"],"<(A, B, C) as zip::ZippableTuple>::stride_of":[],"<(A, B, C) as zip::ZippableTuple>::uget_ptr":[],"<(A, B, C, D) as zip::OffsetTuple>::stride_offset":[],"<(A, B, C, D) as zip::ZippableTuple>::as_ptr":[],"<(A, B, C, D) as zip::ZippableTuple>::as_ref":[],"<(A, B, C, D) as zip::ZippableTuple>::contiguous_stride":[],"<(A, B, C, D) as zip::ZippableTuple>::split_at":["dimension::axis::Axis"],"<(A, B, C, D) as zip::ZippableTuple>::stride_of":[],"<(A, B, C, D) as zip::ZippableTuple>::uget_ptr":[],"<(A, B, C, D, E) as zip::OffsetTuple>::stride_offset":[],"<(A, B, C, D, E) as zip::ZippableTuple>::as_ptr":[],"<(A, B, C, D, E) as zip::ZippableTuple>::as_ref":[],"<(A, B, C, D, E) as zip::ZippableTuple>::contiguous_stride":[],"<(A, B, C, D, E) as zip::ZippableTuple>::split_at":["dimension::axis::Axis"],"<(A, B, C, D, E) as zip::ZippableTuple>::stride_of":[],"<(A, B, C, D, E) as zip::ZippableTuple>::uget_ptr":[],"<(A, B, C, D, E, F) as zip::OffsetTuple>::stride_offset":[],"<(A, B, C, D, E, F) as zip::ZippableTuple>::as_ptr":[],"<(A, B, C, D, E, F) as zip::ZippableTuple>::as_ref":[],"<(A, B, C, D, E, F) as zip::ZippableTuple>::contiguous_stride":[],"<(A, B, C, D, E, F) as zip::ZippableTuple>::split_at":["dimension::axis::Axis"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::stride_of":[],"<(A, B, C, D, E, F) as zip::ZippableTuple>::uget_ptr":[],"<(A,) as zip::OffsetTuple>::stride_offset":[],"<(A,) as zip::ZippableTuple>::as_ptr":[],"<(A,) as zip::ZippableTuple>::as_ref":[],"<(A,) as zip::ZippableTuple>::contiguous_stride":[],"<(A,) as zip::ZippableTuple>::split_at":["dimension::axis::Axis"],"<(A,) as zip::ZippableTuple>::stride_of":[],"<(A,) as zip::ZippableTuple>::uget_ptr":[],"<(usize, usize) as dimension::conversion::IntoDimension>::into_dimension":[],"<(usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<(usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_unchecked":["dimension::dim::Dim"],"<(usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":[],"<(usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<(usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_unchecked":["dimension::dim::Dim"],"<(usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":[],"<(usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<(usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_unchecked":["dimension::dim::Dim"],"<(usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":[],"<(usize, usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<(usize, usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_unchecked":["dimension::dim::Dim"],"<(usize, usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":[],"<(usize,) as dimension::conversion::IntoDimension>::into_dimension":[],"<*const T as zip::Offset>::__private__":["private::PrivateMarker"],"<*const T as zip::Offset>::stride_offset":[],"<*mut T as zip::Offset>::__private__":["private::PrivateMarker"],"<*mut T as zip::Offset>::stride_offset":[],"<*mut T as zip::OffsetTuple>::stride_offset":[],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::equal_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::equal_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 1]>>>>::dot":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 2]>>>>::dot":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 1]>>>>::dot":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 2]>>>>::dot":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::broadcast_unwrap":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::equal_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::get":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::index":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::uget":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::equal_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::Data>::into_owned":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::RawData>::__private__":["CowRepr","ViewRepr","data_repr::OwnedRepr","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::RawData>::_data_slice":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::RawDataClone>::clone_from_with_ptr":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::RawDataClone>::clone_with_ptr":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::RawDataMut>::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<CowRepr<'a, A> as data_traits::RawDataMut>::try_is_unique":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<D as dimension::DimensionExt>::axis":["dimension::axis::Axis"],"<D as dimension::DimensionExt>::set_axis":["dimension::axis::Axis"],"<D as dimension::conversion::IntoDimension>::into_dimension":[],"<D as dimension::ndindex::NdIndex<D>>::index_checked":["std::marker::Sized","std::option::Option"],"<D as dimension::ndindex::NdIndex<D>>::index_unchecked":[],"<D as zip::Splittable>::split_at":["dimension::axis::Axis"],"<OwnedArcRepr<A> as data_traits::Data>::into_owned":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<OwnedArcRepr<A> as data_traits::DataOwned>::into_shared":["OwnedArcRepr","std::marker::Sized","std::sync::Arc"],"<OwnedArcRepr<A> as data_traits::DataOwned>::new":["OwnedArcRepr","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<OwnedArcRepr<A> as data_traits::RawData>::__private__":["OwnedArcRepr","private::PrivateMarker","std::marker::Sized","std::sync::Arc"],"<OwnedArcRepr<A> as data_traits::RawData>::_data_slice":["OwnedArcRepr","std::marker::Sized","std::option::Option","std::sync::Arc"],"<OwnedArcRepr<A> as data_traits::RawDataClone>::clone_with_ptr":["OwnedArcRepr","std::marker::Sized","std::ptr::NonNull","std::sync::Arc"],"<OwnedArcRepr<A> as data_traits::RawDataMut>::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<OwnedArcRepr<A> as data_traits::RawDataMut>::try_is_unique":["OwnedArcRepr","std::marker::Sized","std::option::Option","std::sync::Arc"],"<OwnedArcRepr<A> as std::clone::Clone>::clone":["OwnedArcRepr","std::marker::Sized","std::sync::Arc"],"<OwnedArcRepr<A> as std::fmt::Debug>::fmt":["OwnedArcRepr","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<P as zip::IntoNdProducer>::into_producer":[],"<RawViewRepr<*const A> as data_traits::RawData>::__private__":["RawViewRepr","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized"],"<RawViewRepr<*const A> as data_traits::RawData>::_data_slice":["RawViewRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<RawViewRepr<*const A> as data_traits::RawDataClone>::clone_with_ptr":["RawViewRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<RawViewRepr<*mut A> as data_traits::RawData>::__private__":["RawViewRepr","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized"],"<RawViewRepr<*mut A> as data_traits::RawData>::_data_slice":["RawViewRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<RawViewRepr<*mut A> as data_traits::RawDataClone>::clone_with_ptr":["RawViewRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<RawViewRepr<*mut A> as data_traits::RawDataMut>::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<RawViewRepr<*mut A> as data_traits::RawDataMut>::try_is_unique":["RawViewRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<RawViewRepr<A> as std::clone::Clone>::clone":["RawViewRepr","std::marker::PhantomData","std::marker::Sized"],"<Shape<D> as shape_builder::ShapeBuilder>::f":["Shape","std::marker::Sized"],"<Shape<D> as shape_builder::ShapeBuilder>::into_shape":["Shape","std::marker::Sized"],"<Shape<D> as shape_builder::ShapeBuilder>::set_f":["Shape","std::marker::Sized"],"<Shape<D> as shape_builder::ShapeBuilder>::strides":["Shape","StrideShape","std::marker::Sized"],"<Shape<D> as std::clone::Clone>::clone":["Shape","std::marker::Sized"],"<Shape<D> as std::fmt::Debug>::fmt":["Shape","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<StrideShape<D> as std::clone::Clone>::clone":["StrideShape","std::marker::Sized"],"<StrideShape<D> as std::fmt::Debug>::fmt":["StrideShape","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<T as shape_builder::ShapeBuilder>::f":["Shape","std::marker::Sized"],"<T as shape_builder::ShapeBuilder>::into_shape":["Shape","std::marker::Sized"],"<T as shape_builder::ShapeBuilder>::set_f":["Shape","std::marker::Sized"],"<T as shape_builder::ShapeBuilder>::strides":["StrideShape","std::marker::Sized"],"<ViewRepr<&'a A> as data_traits::Data>::into_owned":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ViewRepr<&'a A> as data_traits::RawData>::__private__":["ViewRepr","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized"],"<ViewRepr<&'a A> as data_traits::RawData>::_data_slice":["ViewRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<ViewRepr<&'a A> as data_traits::RawDataClone>::clone_with_ptr":["ViewRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ViewRepr<&'a mut A> as data_traits::Data>::into_owned":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ViewRepr<&'a mut A> as data_traits::RawData>::__private__":["ViewRepr","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized"],"<ViewRepr<&'a mut A> as data_traits::RawData>::_data_slice":["ViewRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<ViewRepr<&'a mut A> as data_traits::RawDataMut>::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<ViewRepr<&'a mut A> as data_traits::RawDataMut>::try_is_unique":["ViewRepr","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<ViewRepr<A> as std::clone::Clone>::clone":["ViewRepr","std::marker::PhantomData","std::marker::Sized"],"<[T; 0] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 0] as free_functions::FixedInitializer>::len":[],"<[T; 10] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 10] as free_functions::FixedInitializer>::len":[],"<[T; 11] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 11] as free_functions::FixedInitializer>::len":[],"<[T; 12] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 12] as free_functions::FixedInitializer>::len":[],"<[T; 13] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 13] as free_functions::FixedInitializer>::len":[],"<[T; 14] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 14] as free_functions::FixedInitializer>::len":[],"<[T; 15] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 15] as free_functions::FixedInitializer>::len":[],"<[T; 16] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 16] as free_functions::FixedInitializer>::len":[],"<[T; 1] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 1] as free_functions::FixedInitializer>::len":[],"<[T; 2] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 2] as free_functions::FixedInitializer>::len":[],"<[T; 3] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 3] as free_functions::FixedInitializer>::len":[],"<[T; 4] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 4] as free_functions::FixedInitializer>::len":[],"<[T; 5] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 5] as free_functions::FixedInitializer>::len":[],"<[T; 6] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 6] as free_functions::FixedInitializer>::len":[],"<[T; 7] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 7] as free_functions::FixedInitializer>::len":[],"<[T; 8] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 8] as free_functions::FixedInitializer>::len":[],"<[T; 9] as free_functions::FixedInitializer>::as_init_slice":[],"<[T; 9] as free_functions::FixedInitializer>::len":[],"<[usize; 0] as dimension::conversion::Convert>::convert":[],"<[usize; 0] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 1] as dimension::conversion::Convert>::convert":[],"<[usize; 1] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 2] as dimension::conversion::Convert>::convert":[],"<[usize; 2] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 3] as dimension::conversion::Convert>::convert":[],"<[usize; 3] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 4] as dimension::conversion::Convert>::convert":[],"<[usize; 4] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 5] as dimension::conversion::Convert>::convert":[],"<[usize; 5] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 6] as dimension::conversion::Convert>::convert":[],"<[usize; 6] as dimension::conversion::IntoDimension>::into_dimension":[],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 6]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 6]>>>::index_unchecked":["dimension::dim::Dim"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<[usize] as dimension::DimensionExt>::axis":["dimension::axis::Axis"],"<[usize] as dimension::DimensionExt>::set_axis":["dimension::axis::Axis"],"<arrayformat::FormatOptions as std::clone::Clone>::clone":["arrayformat::FormatOptions"],"<arrayformat::FormatOptions as std::fmt::Debug>::fmt":["arrayformat::FormatOptions","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<data_repr::OwnedRepr<A> as data_traits::Data>::into_owned":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as data_traits::DataOwned>::into_shared":["OwnedArcRepr","data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull","std::sync::Arc"],"<data_repr::OwnedRepr<A> as data_traits::DataOwned>::new":["data_repr::OwnedRepr","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"<data_repr::OwnedRepr<A> as data_traits::RawData>::__private__":["data_repr::OwnedRepr","private::PrivateMarker","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as data_traits::RawData>::_data_slice":["data_repr::OwnedRepr","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as data_traits::RawDataClone>::clone_from_with_ptr":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as data_traits::RawDataClone>::clone_with_ptr":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as data_traits::RawDataMut>::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as data_traits::RawDataMut>::try_is_unique":["data_repr::OwnedRepr","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as std::clone::Clone>::clone":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as std::clone::Clone>::clone_from":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"<data_repr::OwnedRepr<A> as std::fmt::Debug>::fmt":["data_repr::OwnedRepr","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"<data_repr::OwnedRepr<A> as std::ops::Drop>::drop":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"<dimension::axes::Axes<'a, D> as std::clone::Clone>::clone":["dimension::axes::Axes","std::marker::Sized"],"<dimension::axes::Axes<'a, D> as std::fmt::Debug>::fmt":["dimension::axes::Axes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dimension::axes::Axes<'a, D> as std::iter::DoubleEndedIterator>::next_back":["dimension::axes::Axes","std::marker::Sized","std::option::Option"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::fold":["dimension::axes::Axes","std::marker::Sized","std::ops::FnMut"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::next":["dimension::axes::Axes","std::marker::Sized","std::option::Option"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::size_hint":["dimension::axes::Axes","std::marker::Sized","std::option::Option"],"<dimension::axes::AxisDescription as std::clone::Clone>::clone":["dimension::axes::AxisDescription","dimension::axis::Axis"],"<dimension::axes::AxisDescription as std::fmt::Debug>::fmt":["dimension::axes::AxisDescription","dimension::axis::Axis","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dimension::axis::Axis as std::clone::Clone>::clone":["dimension::axis::Axis"],"<dimension::axis::Axis as std::cmp::Eq>::assert_receiver_is_total_eq":["dimension::axis::Axis"],"<dimension::axis::Axis as std::cmp::Ord>::cmp":["dimension::axis::Axis","std::cmp::Ordering"],"<dimension::axis::Axis as std::cmp::PartialEq>::eq":["dimension::axis::Axis"],"<dimension::axis::Axis as std::cmp::PartialOrd>::partial_cmp":["dimension::axis::Axis","std::marker::Sized","std::option::Option"],"<dimension::axis::Axis as std::fmt::Debug>::fmt":["dimension::axis::Axis","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dimension::axis::Axis as std::hash::Hash>::hash":["dimension::axis::Axis","std::hash::Hasher","std::marker::Sized"],"<dimension::dim::Dim<I> as std::clone::Clone>::clone":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::cmp::Eq>::assert_receiver_is_total_eq":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::cmp::PartialEq<I>>::eq":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::cmp::PartialEq>::eq":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::default::Default>::default":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::fmt::Debug>::fmt":["dimension::dim::Dim","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dimension::dim::Dim<I> as std::hash::Hash>::hash":["dimension::dim::Dim","std::hash::Hasher","std::marker::Sized"],"<dimension::dim::Dim<I> as std::ops::Add>::add":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::AddAssign<&'a dimension::dim::Dim<I>>>::add_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::AddAssign>::add_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::Mul<usize>>::mul":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::Mul>::mul":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::MulAssign<&'a dimension::dim::Dim<I>>>::mul_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::MulAssign<usize>>::mul_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::MulAssign>::mul_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::Sub>::sub":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::SubAssign<&'a dimension::dim::Dim<I>>>::sub_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<I> as std::ops::SubAssign>::sub_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::next_for":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 0]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 0]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::default_strides":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::equal":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::first_index":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::max_stride_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::min_stride_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::next_for":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::size":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::size_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::stride_offset":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 1]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as dimension::remove_axis::RemoveAxis>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as std::ops::Add<usize>>::add":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as std::ops::AddAssign<usize>>::add_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as std::ops::Sub<usize>>::sub":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 1]> as std::ops::SubAssign<usize>>::sub_assign":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::default_strides":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::equal":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::first_index":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::fortran_strides":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::last_elem":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::min_stride_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::next_for":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::set_last_elem":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::size":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::size_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::stride_offset":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 2]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 2]> as dimension::remove_axis::RemoveAxis>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::next_for":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::size":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::stride_offset":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 3]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 3]> as dimension::remove_axis::RemoveAxis>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 4]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 4]> as dimension::remove_axis::RemoveAxis>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 5]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 5]> as dimension::remove_axis::RemoveAxis>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<[usize; 6]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<dimension::dim::Dim<[usize; 6]> as dimension::remove_axis::RemoveAxis>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::__private__":["dimension::dim::Dim","private::PrivateMarker"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::from_dimension":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::option::Option"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::insert_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::into_pattern":["dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::ndim":["dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::slice":["dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::slice_mut":["dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::try_remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::zeros":["dimension::dim::Dim"],"<dimension::dynindeximpl::IxDynImpl as dimension::conversion::IntoDimension>::into_dimension":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::clone::Clone>::clone":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::cmp::Eq>::assert_receiver_is_total_eq":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::cmp::PartialEq>::eq":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::convert::From<&'a [usize]>>::from":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::convert::From<std::vec::Vec<usize>>>::from":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<dimension::dynindeximpl::IxDynImpl as std::default::Default>::default":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::fmt::Debug>::fmt":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dimension::dynindeximpl::IxDynImpl as std::hash::Hash>::hash":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::hash::Hasher","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::ops::Deref>::deref":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::ops::DerefMut>::deref_mut":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::ops::Index<J>>::index":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynImpl as std::ops::IndexMut<J>>::index_mut":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynRepr<T> as std::clone::Clone>::clone":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynRepr<T> as std::cmp::PartialEq>::eq":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynRepr<T> as std::fmt::Debug>::fmt":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dimension::dynindeximpl::IxDynRepr<T> as std::hash::Hash>::hash":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::hash::Hasher","std::marker::Sized"],"<dimension::dynindeximpl::IxDynRepr<T> as std::ops::Deref>::deref":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynRepr<T> as std::ops::DerefMut>::deref_mut":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<dimension::dynindeximpl::IxDynRepr<usize> as std::default::Default>::default":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::ErrorKind as std::clone::Clone>::clone":["error::ErrorKind"],"<error::ErrorKind as std::cmp::PartialEq>::eq":["error::ErrorKind"],"<error::ErrorKind as std::fmt::Debug>::fmt":["error::ErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ShapeError as std::clone::Clone>::clone":["error::ErrorKind","error::ShapeError"],"<error::ShapeError as std::cmp::PartialEq>::eq":["error::ErrorKind","error::ShapeError"],"<error::ShapeError as std::fmt::Debug>::fmt":["error::ErrorKind","error::ShapeError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ShapeError as std::fmt::Display>::fmt":["error::ErrorKind","error::ShapeError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<geomspace::Geomspace<F> as std::iter::DoubleEndedIterator>::next_back":["geomspace::Geomspace","std::marker::Sized","std::option::Option"],"<geomspace::Geomspace<F> as std::iter::Iterator>::next":["geomspace::Geomspace","std::marker::Sized","std::option::Option"],"<geomspace::Geomspace<F> as std::iter::Iterator>::size_hint":["geomspace::Geomspace","std::marker::Sized","std::option::Option"],"<i32 as slice::SliceNextDim<D1, D1>>::next_dim":["std::marker::PhantomData"],"<indexes::IndexPtr<D> as std::clone::Clone>::clone":["indexes::IndexPtr","std::marker::Sized"],"<indexes::IndexPtr<D> as std::fmt::Debug>::fmt":["indexes::IndexPtr","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<indexes::IndexPtr<D> as zip::Offset>::__private__":["indexes::IndexPtr","private::PrivateMarker","std::marker::Sized"],"<indexes::IndexPtr<D> as zip::Offset>::stride_offset":["indexes::IndexPtr","std::marker::Sized"],"<indexes::Indices<D> as std::clone::Clone>::clone":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as std::fmt::Debug>::fmt":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::fmt::Formatter","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull","std::result::Result"],"<indexes::Indices<D> as std::iter::IntoIterator>::into_iter":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","private::PrivateMarker","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::equal_dim":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","layout::Layout","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::Indices<D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<indexes::IndicesIter<D> as std::clone::Clone>::clone":["indexes::IndicesIter","std::marker::Sized","std::option::Option"],"<indexes::IndicesIter<D> as std::iter::Iterator>::fold":["indexes::IndicesIter","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<indexes::IndicesIter<D> as std::iter::Iterator>::next":["indexes::IndicesIter","std::marker::Sized","std::option::Option"],"<indexes::IndicesIter<D> as std::iter::Iterator>::size_hint":["indexes::IndicesIter","std::marker::Sized","std::option::Option"],"<indexes::IndicesIterF<D> as std::clone::Clone>::clone":["indexes::IndicesIterF","std::marker::Sized"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::next":["indexes::IndicesIterF","std::marker::Sized","std::option::Option"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::size_hint":["indexes::IndicesIterF","std::marker::Sized","std::option::Option"],"<isize as slice::SliceNextDim<D1, D1>>::next_dim":["std::marker::PhantomData"],"<iterators::AxisChunksIter<'a, A, D> as std::clone::Clone>::clone":["iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::next":["iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::next":["iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIter<'a, A, D> as std::clone::Clone>::clone":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as std::fmt::Debug>::fmt":["iterators::AxisIter","iterators::AxisIterCore","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<iterators::AxisIter<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::next":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::__private__":["iterators::AxisIter","iterators::AxisIterCore","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::as_ptr":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::as_ref":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::contiguous_stride":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::layout":["iterators::AxisIter","iterators::AxisIterCore","layout::Layout","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::raw_dim":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::split_at":["dimension::axis::Axis","iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::stride_of":["dimension::axis::Axis","iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::uget_ptr":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterCore<A, D> as std::clone::Clone>::clone":["iterators::AxisIterCore","std::marker::Sized"],"<iterators::AxisIterCore<A, D> as std::fmt::Debug>::fmt":["iterators::AxisIterCore","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iterators::AxisIterCore<A, D> as std::iter::DoubleEndedIterator>::next_back":["iterators::AxisIterCore","std::marker::Sized","std::option::Option"],"<iterators::AxisIterCore<A, D> as std::iter::ExactSizeIterator>::len":["iterators::AxisIterCore","std::marker::Sized"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::next":["iterators::AxisIterCore","std::marker::Sized","std::option::Option"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::size_hint":["iterators::AxisIterCore","std::marker::Sized","std::option::Option"],"<iterators::AxisIterMut<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::next":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::__private__":["iterators::AxisIterCore","iterators::AxisIterMut","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::as_ptr":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::as_ref":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::layout":["iterators::AxisIterCore","iterators::AxisIterMut","layout::Layout","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::raw_dim":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::split_at":["dimension::axis::Axis","iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::stride_of":["dimension::axis::Axis","iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::uget_ptr":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"<iterators::Baseiter<A, D> as std::clone::Clone>::clone":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"<iterators::Baseiter<A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::fold":["iterators::Baseiter","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::next":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["iterators::Baseiter","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::ElementsBase<'a, A, D> as std::clone::Clone>::clone":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBase<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::fold":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBase<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBase<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::fold":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBaseMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::ElementsBaseMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::ElementsRepr<S, C> as std::clone::Clone>::clone":["iterators::ElementsRepr","std::marker::Sized"],"<iterators::IndexedIter<'a, A, D> as std::clone::Clone>::clone":["iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::IndexedIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::IndexedIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::IndexedIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::IndexedIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, D> as std::clone::Clone>::clone":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized"],"<iterators::Iter<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::all":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::any":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::ElementsRepr","iterators::Iter","std::iter::FromIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::count":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::find":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::find_map":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::fold":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::last":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::next":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::nth":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::position":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::option::Option"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized","std::ops::FnMut"],"<iterators::IterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::all":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::any":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::ElementsRepr","iterators::IterMut","std::iter::FromIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::count":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::find":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::find_map":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::fold":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::last":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::option::Option"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::next":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::option::Option"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::nth":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::option::Option"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::position":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut","std::option::Option"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::option::Option"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::option::Option"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::option::Option"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized","std::ops::FnMut"],"<iterators::LanesIter<'a, A, D> as std::clone::Clone>::clone":["iterators::Baseiter","iterators::LanesIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::LanesIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","iterators::LanesIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::LanesIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::LanesIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::LanesIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["iterators::Baseiter","iterators::LanesIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::LanesIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::LanesIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::chunks::ExactChunks<'a, A, D> as std::clone::Clone>::clone":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as std::iter::IntoIterator>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::clone::Clone>::clone":["iterators::Baseiter","iterators::ElementsBase","iterators::chunks::ExactChunksIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBase","iterators::chunks::ExactChunksIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBase","iterators::chunks::ExactChunksIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::chunks::ExactChunksIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::chunks::ExactChunksIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::chunks::ExactChunksMut<'a, A, D> as std::iter::IntoIterator>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as std::clone::Clone>::clone":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as std::iter::IntoIterator>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as std::iter::IntoIterator>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as std::clone::Clone>::clone":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as std::iter::IntoIterator>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::__private__":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","private::PrivateMarker","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::as_ref":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::contiguous_stride":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::uget_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"<iterators::windows::WindowsIter<'a, A, D> as std::clone::Clone>::clone":["iterators::Baseiter","iterators::ElementsBase","iterators::windows::WindowsIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::next":["iterators::Baseiter","iterators::ElementsBase","iterators::windows::WindowsIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::size_hint":["iterators::Baseiter","iterators::ElementsBase","iterators::windows::WindowsIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<layout::Layout as std::clone::Clone>::clone":["layout::Layout"],"<linspace::Linspace<F> as std::iter::DoubleEndedIterator>::next_back":["linspace::Linspace","std::marker::Sized","std::option::Option"],"<linspace::Linspace<F> as std::iter::Iterator>::next":["linspace::Linspace","std::marker::Sized","std::option::Option"],"<linspace::Linspace<F> as std::iter::Iterator>::size_hint":["linspace::Linspace","std::marker::Sized","std::option::Option"],"<logspace::Logspace<F> as std::iter::DoubleEndedIterator>::next_back":["logspace::Logspace","std::marker::Sized","std::option::Option"],"<logspace::Logspace<F> as std::iter::Iterator>::next":["logspace::Logspace","std::marker::Sized","std::option::Option"],"<logspace::Logspace<F> as std::iter::Iterator>::size_hint":["logspace::Logspace","std::marker::Sized","std::option::Option"],"<slice::Slice as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["slice::Slice","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<slice::Slice as std::clone::Clone>::clone":["slice::Slice","std::marker::Sized","std::option::Option"],"<slice::Slice as std::cmp::Eq>::assert_receiver_is_total_eq":["slice::Slice","std::marker::Sized","std::option::Option"],"<slice::Slice as std::cmp::PartialEq>::eq":["slice::Slice","std::marker::Sized","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::Range<i32>>>::from":["slice::Slice","std::marker::Sized","std::ops::Range","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::Range<isize>>>::from":["slice::Slice","std::marker::Sized","std::ops::Range","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::Range<usize>>>::from":["slice::Slice","std::marker::Sized","std::ops::Range","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<i32>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeFrom","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<isize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeFrom","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<usize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeFrom","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeFull>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeFull","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<i32>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeInclusive","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<isize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeInclusive","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeInclusive","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeTo<i32>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeTo","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeTo<isize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeTo","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeTo<usize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeTo","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<i32>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeToInclusive","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<isize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeToInclusive","std::option::Option"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["slice::Slice","std::marker::Sized","std::ops::RangeToInclusive","std::option::Option"],"<slice::Slice as std::fmt::Debug>::fmt":["slice::Slice","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<slice::Slice as std::hash::Hash>::hash":["slice::Slice","std::hash::Hasher","std::marker::Sized","std::option::Option"],"<slice::SliceInfo<T, D> as std::clone::Clone>::clone":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<slice::SliceInfo<T, D> as std::convert::AsRef<[slice::SliceOrIndex]>>::as_ref":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","slice::SliceOrIndex","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::option::Option","std::ptr::NonNull"],"<slice::SliceInfo<T, D> as std::convert::AsRef<slice::SliceInfo<[slice::SliceOrIndex], D>>>::as_ref":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<slice::SliceInfo<T, D> as std::fmt::Debug>::fmt":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::fmt::Formatter","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull","std::result::Result"],"<slice::SliceInfo<T, D> as std::ops::Deref>::deref":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"<slice::SliceOrIndex as std::clone::Clone>::clone":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::cmp::Eq>::assert_receiver_is_total_eq":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::cmp::PartialEq>::eq":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<i32>>::from":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<isize>>::from":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<slice::Slice>>::from":["slice::Slice","slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<i32>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::Range","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<isize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::Range","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<usize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::Range","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<i32>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeFrom","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<isize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeFrom","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<usize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeFrom","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFull>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeFull","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<i32>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeInclusive","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<isize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeInclusive","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeInclusive","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<i32>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeTo","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<isize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeTo","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<usize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeTo","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<i32>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeToInclusive","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<isize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeToInclusive","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["slice::SliceOrIndex","std::marker::Sized","std::ops::RangeToInclusive","std::option::Option"],"<slice::SliceOrIndex as std::convert::From<usize>>::from":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"<slice::SliceOrIndex as std::fmt::Debug>::fmt":["slice::SliceOrIndex","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<slice::SliceOrIndex as std::fmt::Display>::fmt":["slice::SliceOrIndex","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<slice::SliceOrIndex as std::hash::Hash>::hash":["slice::SliceOrIndex","std::hash::Hasher","std::marker::Sized","std::option::Option"],"<std::ops::Range<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["std::marker::PhantomData","std::marker::Sized","std::ops::Range"],"<std::ops::RangeFrom<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["std::marker::PhantomData","std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFull as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["std::marker::PhantomData","std::ops::RangeFull"],"<std::ops::RangeInclusive<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["std::marker::PhantomData","std::marker::Sized","std::ops::RangeInclusive"],"<std::ops::RangeTo<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["std::marker::PhantomData","std::marker::Sized","std::ops::RangeTo"],"<std::ops::RangeToInclusive<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["std::marker::PhantomData","std::marker::Sized","std::ops::RangeToInclusive"],"<std::vec::Vec<usize> as dimension::conversion::IntoDimension>::into_dimension":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<usize as dimension::axes::IncOps>::post_dec":[],"<usize as dimension::axes::IncOps>::post_inc":[],"<usize as dimension::axes::IncOps>::pre_dec":[],"<usize as dimension::conversion::IntoDimension>::into_dimension":["dimension::dim::Dim"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_unchecked":["dimension::dim::Dim"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["dimension::dim::Dim","std::marker::Sized","std::option::Option"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["dimension::dim::Dim"],"<usize as slice::SliceNextDim<D1, D1>>::next_dim":["std::marker::PhantomData"],"<zip::FoldWhile<T> as std::clone::Clone>::clone":["std::marker::Sized","zip::FoldWhile"],"<zip::FoldWhile<T> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","zip::FoldWhile"],"<zip::Zip<Parts, D> as std::clone::Clone>::clone":["layout::Layout","std::marker::Sized","zip::Zip"],"<zip::Zip<Parts, D> as std::fmt::Debug>::fmt":["layout::Layout","std::fmt::Formatter","std::marker::Sized","std::result::Result","zip::Zip"],"ArrayBase":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::broadcast_assume":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::broadcast_unwrap":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::broadcast_unwrap::broadcast_panic":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"ArrayBase::<S, D>::inner_rows":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::inner_rows_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::raw_strides":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::try_remove_axis":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"ArrayBase::<S, D>::unordered_foreach_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"CowRepr":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"CowRepr::<'a, A>::is_owned":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"CowRepr::<'a, A>::is_view":["CowRepr","ViewRepr","data_repr::OwnedRepr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"OwnedArcRepr":["OwnedArcRepr","std::marker::Sized","std::sync::Arc"],"RawViewRepr":["RawViewRepr","std::marker::PhantomData","std::marker::Sized"],"RawViewRepr::<A>::new":["RawViewRepr","std::marker::PhantomData","std::marker::Sized"],"Shape":["Shape","std::marker::Sized"],"StrideShape":["StrideShape","std::marker::Sized"],"ViewRepr":["ViewRepr","std::marker::PhantomData","std::marker::Sized"],"ViewRepr::<A>::new":["ViewRepr","std::marker::PhantomData","std::marker::Sized"],"aliases::Ix0":["dimension::dim::Dim"],"aliases::Ix1":["dimension::dim::Dim"],"aliases::Ix2":["dimension::dim::Dim"],"aliases::Ix3":["dimension::dim::Dim"],"aliases::Ix4":["dimension::dim::Dim"],"aliases::Ix5":["dimension::dim::Dim"],"aliases::Ix6":["dimension::dim::Dim"],"aliases::IxDyn":["dimension::dim::Dim"],"argument_traits::AssignElem::assign_elem":[],"arrayformat::<impl std::fmt::Binary for ArrayBase<S, D>>::fmt":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"arrayformat::<impl std::fmt::Debug for ArrayBase<S, D>>::fmt":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"arrayformat::<impl std::fmt::Display for ArrayBase<S, D>>::fmt":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"arrayformat::<impl std::fmt::LowerExp for ArrayBase<S, D>>::fmt":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"arrayformat::<impl std::fmt::LowerHex for ArrayBase<S, D>>::fmt":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"arrayformat::<impl std::fmt::UpperExp for ArrayBase<S, D>>::fmt":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"arrayformat::FormatOptions":["arrayformat::FormatOptions"],"arrayformat::FormatOptions::collapse_limit":["arrayformat::FormatOptions"],"arrayformat::FormatOptions::default_for_array":["arrayformat::FormatOptions"],"arrayformat::FormatOptions::set_no_limit":["arrayformat::FormatOptions"],"arrayformat::format_array":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","arrayformat::FormatOptions","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::result::Result"],"arrayformat::format_array_inner":["ArrayBase","CowRepr","ViewRepr","arrayformat::FormatOptions","data_repr::OwnedRepr","data_traits::RawData","std::clone::Clone","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::result::Result"],"arrayformat::format_with_overflow":["std::fmt::Formatter","std::marker::Sized","std::result::Result"],"arraytraits::<impl std::cmp::PartialEq<ArrayBase<S2, D>> for ArrayBase<S, D>>::eq":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::convert::From<&'a ArrayBase<S, D>> for ArrayBase<ViewRepr<&'a A>, D>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::convert::From<&'a Slice> for ArrayBase<ViewRepr<&'a A>, dimension::dim::Dim<[usize; 1]>>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::convert::From<&'a mut ArrayBase<S, D>> for ArrayBase<ViewRepr<&'a mut A>, D>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::convert::From<&'a mut Slice> for ArrayBase<ViewRepr<&'a mut A>, dimension::dim::Dim<[usize; 1]>>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::convert::From<std::vec::Vec<A>> for ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"arraytraits::<impl std::default::Default for ArrayBase<S, D>>::default":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::hash::Hash for ArrayBase<S, D>>::hash":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::iter::FromIterator<A> for ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from_iter":["ArrayBase","ArrayView","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::iter::IntoIterator for &'a ArrayBase<S, D>>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::iter::IntoIterator for &'a mut ArrayBase<S, D>>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::iter::IntoIterator for ArrayBase<ViewRepr<&'a A>, D>>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::iter::IntoIterator for ArrayBase<ViewRepr<&'a mut A>, D>>::into_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::ops::Index<I> for ArrayBase<S, D>>::index":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::<impl std::ops::IndexMut<I> for ArrayBase<S, D>>::index_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"arraytraits::array_out_of_bounds":[],"arraytraits::debug_bounds_check":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"data_repr::OwnedRepr":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"data_repr::OwnedRepr::<A>::as_nonnull_mut":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"data_repr::OwnedRepr::<A>::as_ptr":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"data_repr::OwnedRepr::<A>::as_slice":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"data_repr::OwnedRepr::<A>::from":["data_repr::OwnedRepr","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"data_repr::OwnedRepr::<A>::into_vec":["data_repr::OwnedRepr","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"data_repr::OwnedRepr::<A>::len":["data_repr::OwnedRepr","std::marker::Sized","std::ptr::NonNull"],"data_repr::OwnedRepr::<A>::take_as_vec":["data_repr::OwnedRepr","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"data_traits::Data::into_owned":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"data_traits::DataMut::ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"data_traits::DataMut::is_unique":[],"data_traits::DataOwned::into_shared":["OwnedArcRepr","std::marker::Sized","std::sync::Arc"],"data_traits::DataOwned::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"data_traits::RawData::__private__":["private::PrivateMarker"],"data_traits::RawData::_data_slice":["std::marker::Sized","std::option::Option"],"data_traits::RawDataClone::clone_from_with_ptr":["std::ptr::NonNull"],"data_traits::RawDataClone::clone_with_ptr":["std::ptr::NonNull"],"data_traits::RawDataMut::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"data_traits::RawDataMut::try_is_unique":["std::marker::Sized","std::option::Option"],"dimension::DimensionExt::axis":["dimension::axis::Axis"],"dimension::DimensionExt::set_axis":["dimension::axis::Axis"],"dimension::abs_index":[],"dimension::arith_seq_intersect":[],"dimension::axes::Axes":["dimension::axes::Axes","std::marker::Sized"],"dimension::axes::AxisDescription":["dimension::axes::AxisDescription","dimension::axis::Axis"],"dimension::axes::AxisDescription::axis":["dimension::axes::AxisDescription","dimension::axis::Axis"],"dimension::axes::AxisDescription::len":["dimension::axes::AxisDescription","dimension::axis::Axis"],"dimension::axes::AxisDescription::stride":["dimension::axes::AxisDescription","dimension::axis::Axis"],"dimension::axes::IncOps::post_dec":[],"dimension::axes::IncOps::post_inc":[],"dimension::axes::IncOps::pre_dec":[],"dimension::axes::axes_of":["aliases::IxDyn","dimension::axes::Axes","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"dimension::axis::Axis":["dimension::axis::Axis"],"dimension::axis::Axis::index":["dimension::axis::Axis"],"dimension::can_index_slice":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::result::Result"],"dimension::can_index_slice_not_custom":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::result::Result"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 0]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 0]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 1]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 1]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 2]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 2]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 3]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 3]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 4]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 4]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 5]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 5]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 6]>>::is_zero":["dimension::dim::Dim"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 6]>>::zero":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 0]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 1]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 2]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 3]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 4]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 5]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 6]>>::index":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 0]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 1]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 2]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 3]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 4]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 5]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 6]>>::index_mut":["dimension::dim::Dim"],"dimension::conversion::Convert::convert":[],"dimension::conversion::IntoDimension::into_dimension":[],"dimension::dim::Dim":["<D as dimension::conversion::IntoDimension>::D","dimension::conversion::IntoDimension","std::marker::Sized"],"dimension::dim::Dim::<I>::ix":["dimension::dim::Dim"],"dimension::dim::Dim::<I>::ixm":["dimension::dim::Dim"],"dimension::dim::Dim::<I>::new":["dimension::dim::Dim"],"dimension::dim_stride_overlap":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"dimension::dimension_trait::<impl std::ops::Index<usize> for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::index":["dimension::dim::Dim"],"dimension::dimension_trait::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::index_mut":["dimension::dim::Dim"],"dimension::dimension_trait::Dimension::__private__":["private::PrivateMarker"],"dimension::dimension_trait::Dimension::_fastest_varying_stride_order":[],"dimension::dimension_trait::Dimension::as_array_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"dimension::dimension_trait::Dimension::as_array_view_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"dimension::dimension_trait::Dimension::default_strides":[],"dimension::dimension_trait::Dimension::equal":[],"dimension::dimension_trait::Dimension::first_index":["std::marker::Sized","std::option::Option"],"dimension::dimension_trait::Dimension::fortran_strides":[],"dimension::dimension_trait::Dimension::from_dimension":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::option::Option"],"dimension::dimension_trait::Dimension::insert_axis":["dimension::axis::Axis"],"dimension::dimension_trait::Dimension::into_dyn":["dimension::dim::Dim"],"dimension::dimension_trait::Dimension::into_pattern":[],"dimension::dimension_trait::Dimension::is_contiguous":[],"dimension::dimension_trait::Dimension::last_elem":[],"dimension::dimension_trait::Dimension::max_stride_axis":["dimension::axis::Axis"],"dimension::dimension_trait::Dimension::min_stride_axis":["dimension::axis::Axis"],"dimension::dimension_trait::Dimension::ndim":[],"dimension::dimension_trait::Dimension::next_for":["std::marker::Sized","std::option::Option"],"dimension::dimension_trait::Dimension::next_for_f":[],"dimension::dimension_trait::Dimension::set_last_elem":[],"dimension::dimension_trait::Dimension::size":[],"dimension::dimension_trait::Dimension::size_checked":["std::marker::Sized","std::option::Option"],"dimension::dimension_trait::Dimension::slice":[],"dimension::dimension_trait::Dimension::slice_mut":[],"dimension::dimension_trait::Dimension::stride_offset":[],"dimension::dimension_trait::Dimension::stride_offset_checked":["std::marker::Sized","std::option::Option"],"dimension::dimension_trait::Dimension::strides_equivalent":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"dimension::dimension_trait::Dimension::try_remove_axis":["dimension::axis::Axis"],"dimension::dimension_trait::Dimension::zeros":[],"dimension::do_collapse_axis":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"dimension::do_slice":["slice::Slice","std::marker::Sized","std::option::Option"],"dimension::dynindeximpl::<impl dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::zeros":["dimension::dim::Dim"],"dimension::dynindeximpl::<impl dimension::remove_axis::RemoveAxis for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::remove_axis":["dimension::axis::Axis","dimension::dim::Dim"],"dimension::dynindeximpl::IxDynImpl":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"dimension::dynindeximpl::IxDynImpl::insert":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"dimension::dynindeximpl::IxDynImpl::remove":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"dimension::dynindeximpl::IxDynRepr":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"dimension::dynindeximpl::IxDynRepr::<T>::copy_from":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"dimension::dynindeximpl::IxDynRepr::<T>::from":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"dimension::dynindeximpl::IxDynRepr::<T>::from_vec":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"dimension::dynindeximpl::IxDynRepr::<T>::from_vec_auto":["dimension::dynindeximpl::IxDynRepr","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"dimension::extended_gcd":[],"dimension::max_abs_offset_check_overflow":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::result::Result"],"dimension::merge_axes":["aliases::IxDyn","dimension::axis::Axis","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"dimension::ndindex::<impl dimension::conversion::IntoDimension for &'a [usize]>::into_dimension":[],"dimension::ndindex::NdIndex::index_checked":["std::marker::Sized","std::option::Option"],"dimension::ndindex::NdIndex::index_unchecked":[],"dimension::remove_axis::RemoveAxis::remove_axis":["dimension::axis::Axis"],"dimension::size_of_shape_checked":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::result::Result"],"dimension::slice_min_max":["slice::Slice","std::marker::Sized","std::option::Option"],"dimension::slices_intersect":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"dimension::solve_linear_diophantine_eq":["std::marker::Sized","std::option::Option"],"dimension::stride_offset":[],"dimension::stride_offset_checked":["std::marker::Sized","std::option::Option"],"dimension::to_abs_slice":["slice::Slice","std::marker::Sized","std::option::Option"],"error::ErrorKind":["error::ErrorKind"],"error::ShapeError":["error::ErrorKind","error::ShapeError"],"error::ShapeError::from_kind":["error::ErrorKind","error::ShapeError"],"error::ShapeError::kind":["error::ErrorKind","error::ShapeError"],"error::from_kind":["error::ErrorKind","error::ShapeError"],"error::incompatible_shapes":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","error::ErrorKind","error::ShapeError","std::marker::Sized"],"extension::nonnull::nonnull_debug_checked_from_ptr":["std::marker::Sized","std::ptr::NonNull"],"extension::nonnull::nonnull_from_vec_data":["std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"free_functions::<impl std::convert::From<std::vec::Vec<V>> for ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 2]>>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"free_functions::<impl std::convert::From<std::vec::Vec<V>> for ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 3]>>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"free_functions::FixedInitializer::as_init_slice":[],"free_functions::FixedInitializer::len":[],"free_functions::arr0":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::arr1":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::arr2":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","free_functions::FixedInitializer","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::arr3":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","free_functions::FixedInitializer","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::aview0":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::aview1":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::aview2":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","free_functions::FixedInitializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::aview_mut1":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::aview_mut2":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","free_functions::FixedInitializer","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::rcarr1":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::rcarr2":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","free_functions::FixedInitializer","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"free_functions::rcarr3":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","free_functions::FixedInitializer","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"geomspace::Geomspace":["geomspace::Geomspace","std::marker::Sized"],"geomspace::geomspace":["num_traits::Float","std::marker::Sized","std::option::Option"],"impl_1d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::to_vec":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::cols":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::column":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::column_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::is_square":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::ncols":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::nrows":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::row":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::row_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::rows":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_clone::<impl std::clone::Clone for ArrayBase<S, D>>::clone":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_clone::<impl std::clone::Clone for ArrayBase<S, D>>::clone_from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::default":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","shape_builder::ShapeBuilder","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::from_elem":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","shape_builder::ShapeBuilder","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_fn":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","shape_builder::ShapeBuilder","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_simple_fn":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","shape_builder::ShapeBuilder","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec":["std::alloc::Allocator","std::convert::Into","std::marker::Sized","std::result::Result","std::vec::Vec"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec_impl":["StrideShape","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec_unchecked":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"impl_constructors::<impl ArrayBase<S, D>>::from_vec_dim_stride_unchecked":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"impl_constructors::<impl ArrayBase<S, D>>::maybe_uninit":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","shape_builder::ShapeBuilder","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::ones":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_traits::One","shape_builder::ShapeBuilder","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::uninitialized":["<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","shape_builder::ShapeBuilder","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, D>>::zeros":["<D as dimension::conversion::IntoDimension>::D","<T as shape_builder::ShapeBuilder>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","num_traits::Zero","shape_builder::ShapeBuilder","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from_vec":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::geomspace":["num_traits::Float","std::marker::Sized","std::option::Option"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::linspace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_traits::Float","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::logspace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_traits::Float","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::range":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_traits::Float","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::eye":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","num_traits::One","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::from_diag":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_cow::<impl ArrayBase<CowRepr<'a, A>, D>>::is_owned":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_cow::<impl ArrayBase<CowRepr<'a, A>, D>>::is_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_cow::<impl std::convert::From<ArrayBase<ViewRepr<&'a A>, D>> for ArrayBase<CowRepr<'a, A>, D>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_cow::<impl std::convert::From<ArrayBase<data_repr::OwnedRepr<A>, D>> for ArrayBase<CowRepr<'a, A>, D>>::from":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_dyn::<impl ArrayBase<S, dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_axis_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_dyn::<impl ArrayBase<S, dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::insert_axis_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::accumulate_axis_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_mut_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","data_traits::RawDataMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_slice":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_slice_memory_order":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_slice_memory_order_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_slice_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::as_standard_layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::assign":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::axes":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axes::Axes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::axis_chunks_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::axis_chunks_iter_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::axis_iter":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::axis_iter_mut":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::broadcast":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::conversion::IntoDimension","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::broadcast::upcast":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized","std::option::Option"],"impl_methods::<impl ArrayBase<S, D>>::collapse_axis":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::diag":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::diag_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::diag_params":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::ensure_unique":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::exact_chunks":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::conversion::IntoDimension","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::exact_chunks_mut":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::conversion::IntoDimension","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::fill":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::first":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::first_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::fold":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::fold_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::gencolumns":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::gencolumns_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::genrows":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::genrows_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::get":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::get_0d":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::get_mut":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::get_ptr":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::get_ptr_mut":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","data_traits::RawDataMut","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::index_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::index_axis_move":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::index_axis_mut":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::indexed_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::indexed_iter_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","iterators::Baseiter","iterators::ElementsBaseMut","iterators::IndexedIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::insert_axis":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::into_diag":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::into_dimensionality":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"impl_methods::<impl ArrayBase<S, D>>::into_dyn":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::into_owned":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::into_shape":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"impl_methods::<impl ArrayBase<S, D>>::into_shared":["ArrayBase","CowRepr","OwnedArcRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataOwned","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc"],"impl_methods::<impl ArrayBase<S, D>>::into_subview":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::invert_axis":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::is_contiguous":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::is_empty":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::is_standard_layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::is_standard_layout::is_standard_layout":["aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::Sized"],"impl_methods::<impl ArrayBase<S, D>>::iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","iterators::ElementsRepr","iterators::Iter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::iter_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","iterators::ElementsRepr","iterators::IterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::lanes":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::lanes_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::len":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::len_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::map":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::map_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::map_axis_mut":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::map_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::map_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::mapv":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::mapv_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::mapv_into":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::max_stride_axis":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::merge_axes":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::multi_slice_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","slice::MultiSlice","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::ndim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::outer_iter":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::outer_iter_mut":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::permuted_axes":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::pointer_is_inbounds":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::raw_dim":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::raw_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::raw_view_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","data_traits::RawDataMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::remove_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::reshape":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","OwnedArcRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataOwned","data_traits::DataShared","data_traits::RawData","dimension::conversion::IntoDimension","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::Arc"],"impl_methods::<impl ArrayBase<S, D>>::reversed_axes":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::select":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::shape":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_axis":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","slice::Slice","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_axis_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","slice::Slice","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_axis_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","slice::Slice","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_collapse":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_move":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::slice_mut":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::stride_of":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::strides":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::subview":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::subview_inplace":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::subview_mut":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::swap":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::swap_axes":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::t":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::to_owned":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::to_shared":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::try_ensure_unique":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","data_traits::RawDataMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::uget":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::uget_mut":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::uswap":["<D as dimension::ndindex::NdIndex<D>>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","dimension::ndindex::NdIndex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::view_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::visit":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::windows":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::conversion::IntoDimension","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_by_rows":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_elem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::DataMut","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_same_shape":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for f32>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for f64>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i128>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i16>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i32>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i64>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i8>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u128>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u16>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u32>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u64>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u8>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for f32>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for f64>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i128>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i16>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i32>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i64>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i8>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for num_complex::Complex<f32>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for num_complex::Complex<f64>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u128>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u16>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u32>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u64>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u8>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S2, E>> for ArrayBase<S, D>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<B> for &'a ArrayBase<S, D>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Add<B> for ArrayBase<S, D>>::add":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for bool>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i128>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i16>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i32>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i64>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i8>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u128>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u16>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u32>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u64>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u8>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for bool>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i128>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i16>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i32>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i64>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i8>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u128>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u16>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u32>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u64>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u8>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<B> for &'a ArrayBase<S, D>>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<B> for ArrayBase<S, D>>::bitand":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for bool>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i128>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i16>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i32>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i64>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i8>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u128>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u16>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u32>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u64>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u8>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for bool>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i128>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i16>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i32>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i64>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i8>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u128>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u16>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u32>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u64>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u8>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<B> for &'a ArrayBase<S, D>>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<B> for ArrayBase<S, D>>::bitor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for bool>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i128>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i16>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i32>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i64>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i8>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u128>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u16>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u32>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u64>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u8>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for bool>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i128>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i16>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i32>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i64>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i8>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u128>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u16>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u32>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u64>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u8>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<B> for &'a ArrayBase<S, D>>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<B> for ArrayBase<S, D>>::bitxor":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for f32>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for f64>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i128>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i16>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i32>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i64>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i8>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u128>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u16>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u32>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u64>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u8>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for f32>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for f64>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i128>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i16>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i32>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i64>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i8>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for num_complex::Complex<f32>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for num_complex::Complex<f64>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u128>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u16>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u32>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u64>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u8>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S2, E>> for ArrayBase<S, D>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<B> for &'a ArrayBase<S, D>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Div<B> for ArrayBase<S, D>>::div":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for f32>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for f64>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i128>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i16>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i32>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i64>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i8>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u128>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u16>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u32>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u64>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u8>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for f32>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for f64>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i128>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i16>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i32>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i64>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i8>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for num_complex::Complex<f32>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for num_complex::Complex<f64>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u128>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u16>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u32>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u64>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u8>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S2, E>> for ArrayBase<S, D>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<B> for &'a ArrayBase<S, D>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<B> for ArrayBase<S, D>>::mul":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Neg for &'a ArrayBase<S, D>>::neg":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Neg for ArrayBase<S, D>>::neg":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Not for &'a ArrayBase<S, D>>::not":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Not for ArrayBase<S, D>>::not":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for f32>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for f64>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i128>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i16>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i32>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i64>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i8>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u128>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u16>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u32>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u64>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u8>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for f32>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for f64>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i128>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i16>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i32>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i64>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i8>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u128>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u16>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u32>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u64>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u8>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S2, E>> for ArrayBase<S, D>>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<B> for &'a ArrayBase<S, D>>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<B> for ArrayBase<S, D>>::rem":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i128>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i16>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i32>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i64>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i8>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u128>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u16>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u32>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u64>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u8>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i128>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i16>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i32>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i64>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i8>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u128>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u16>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u32>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u64>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u8>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S2, E>> for ArrayBase<S, D>>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<B> for &'a ArrayBase<S, D>>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<B> for ArrayBase<S, D>>::shl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i128>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i16>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i32>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i64>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i8>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u128>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u16>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u32>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u64>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u8>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i128>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i16>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i32>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i64>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i8>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u128>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u16>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u32>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u64>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u8>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S2, E>> for ArrayBase<S, D>>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<B> for &'a ArrayBase<S, D>>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<B> for ArrayBase<S, D>>::shr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for f32>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for f64>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i128>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i16>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i32>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i64>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i8>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u128>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u16>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u32>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u64>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u8>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for f32>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for f64>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i128>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i16>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i32>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i64>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i8>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for num_complex::Complex<f32>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for num_complex::Complex<f64>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_complex::Complex","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u128>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u16>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u32>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u64>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u8>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S2, E>> for ArrayBase<S, D>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<B> for &'a ArrayBase<S, D>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<B> for ArrayBase<S, D>>::sub":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::AddAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::add_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::AddAssign<A> for ArrayBase<S, D>>::add_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::BitAndAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::BitAndAssign<A> for ArrayBase<S, D>>::bitand_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::BitOrAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::BitOrAssign<A> for ArrayBase<S, D>>::bitor_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::BitXorAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::BitXorAssign<A> for ArrayBase<S, D>>::bitxor_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::DivAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::div_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::DivAssign<A> for ArrayBase<S, D>>::div_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::MulAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::mul_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::MulAssign<A> for ArrayBase<S, D>>::mul_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::RemAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::rem_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::RemAssign<A> for ArrayBase<S, D>>::rem_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::ShlAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shl_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::ShlAssign<A> for ArrayBase<S, D>>::shl_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::ShrAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shr_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::ShrAssign<A> for ArrayBase<S, D>>::shr_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::SubAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::sub_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_ops::assign_ops::<impl std::ops::SubAssign<A> for ArrayBase<S, D>>::sub_assign":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_owned_array::<impl ArrayBase<data_repr::OwnedRepr<A>, D>>::into_raw_vec":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"impl_owned_array::<impl ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::cast":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::deref_into_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::from_shape_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::new_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::cast":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::deref_into_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::deref_into_view_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::from_shape_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::into_raw_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::new_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_special_element_types::<impl ArrayBase<S, D>>::assume_init":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_special_element_types::unlimited_transmute":["std::marker::Sized"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape":["std::convert::Into","std::marker::Sized","std::result::Result"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape_impl":["StrideShape","std::marker::Sized","std::result::Result"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::new_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape":["std::convert::Into","std::marker::Sized","std::result::Result"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape_impl":["StrideShape","std::marker::Sized","std::result::Result"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape_ptr":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::new_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::reborrow":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_base_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::Baseiter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_elements_base":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_iter_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::ElementsRepr","iterators::Iter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_outer_iter":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_raw_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_slice":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::reborrow":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::to_slice":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_base_iter":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::Baseiter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_elements_base":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_iter_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::ElementsRepr","iterators::IterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_outer_iter":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_raw_view_mut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_slice":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_slice_":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_view":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::indexing::IndexLonger::get":["std::marker::Sized","std::option::Option"],"impl_views::indexing::IndexLonger::index":[],"impl_views::indexing::IndexLonger::uget":[],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a A>, D>>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","slice::MultiSlice","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::split_at":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"indexes::IndexPtr":["indexes::IndexPtr","std::marker::Sized"],"indexes::Indices":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"indexes::IndicesIter":["indexes::IndicesIter","std::marker::Sized","std::option::Option"],"indexes::IndicesIterF":["indexes::IndicesIterF","std::marker::Sized"],"indexes::indices":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"indexes::indices_iter_f":["<D as dimension::conversion::IntoDimension>::D","dimension::conversion::IntoDimension","indexes::IndicesIterF","std::marker::Sized"],"indexes::indices_of":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","indexes::Indices","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"is_aligned":["std::marker::Sized"],"iterators::AxisChunksIter":["iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisChunksIter::<'a, A, D>::get_subview":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisChunksIter::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisChunksIter::<'a, A, D>::split_at":["iterators::AxisChunksIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisChunksIterMut":["iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisChunksIterMut::<'a, A, D>::get_subview":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisChunksIterMut::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisChunksIterMut::<'a, A, D>::split_at":["iterators::AxisChunksIterMut","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisIter":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisIter::<'a, A, D>::new":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisIter::<'a, A, D>::split_at":["iterators::AxisIter","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisIterCore":["iterators::AxisIterCore","std::marker::Sized"],"iterators::AxisIterCore::<A, D>::new":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisIterCore::<A, D>::next_back_with_index":["iterators::AxisIterCore","std::marker::Sized","std::option::Option"],"iterators::AxisIterCore::<A, D>::next_with_index":["iterators::AxisIterCore","std::marker::Sized","std::option::Option"],"iterators::AxisIterCore::<A, D>::offset":["iterators::AxisIterCore","std::marker::Sized"],"iterators::AxisIterCore::<A, D>::split_at":["iterators::AxisIterCore","std::marker::Sized"],"iterators::AxisIterMut":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"iterators::AxisIterMut::<'a, A, D>::new":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::AxisIterMut::<'a, A, D>::split_at":["iterators::AxisIterCore","iterators::AxisIterMut","std::marker::PhantomData","std::marker::Sized"],"iterators::Baseiter":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"iterators::Baseiter::<A, D>::new":["iterators::Baseiter","std::marker::Sized","std::option::Option"],"iterators::ElementsBase":["iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::ElementsBase::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::Baseiter","iterators::ElementsBase","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"iterators::ElementsBaseMut":["iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::ElementsBaseMut::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::Baseiter","iterators::ElementsBaseMut","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"iterators::ElementsRepr":["iterators::ElementsRepr","std::marker::Sized"],"iterators::IndexedIter":["iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::IndexedIter::<'a, A, D>::new":["iterators::Baseiter","iterators::ElementsBase","iterators::IndexedIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::IndexedIterMut":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::IndexedIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::IndexedIterMut::<'a, A, D>::new":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::IndexedIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::Iter":["iterators::ElementsRepr","iterators::Iter","std::marker::Sized"],"iterators::Iter::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::ElementsRepr","iterators::Iter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::IterMut":["iterators::ElementsRepr","iterators::IterMut","std::marker::Sized"],"iterators::IterMut::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::ElementsRepr","iterators::IterMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::LanesIter":["iterators::Baseiter","iterators::LanesIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::LanesIterMut":["iterators::Baseiter","iterators::LanesIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::chunk_iter_parts":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::dim::Dim","dimension::dimension_trait::Dimension","iterators::AxisIterCore","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::chunks::ExactChunks":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::chunks::ExactChunks::<'a, A, D>::new":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","iterators::chunks::ExactChunks","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::chunks::ExactChunksIter":["iterators::Baseiter","iterators::ElementsBase","iterators::chunks::ExactChunksIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::chunks::ExactChunksIterMut":["iterators::Baseiter","iterators::ElementsBaseMut","iterators::chunks::ExactChunksIterMut","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"iterators::chunks::ExactChunksMut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::chunks::ExactChunksMut::<'a, A, D>::new":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","iterators::chunks::ExactChunksMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::lanes::Lanes":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::lanes::Lanes::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::dim::Dim","dimension::dimension_trait::Dimension","iterators::lanes::Lanes","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::lanes::LanesMut":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::lanes::LanesMut::<'a, A, D>::new":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::dim::Dim","dimension::dimension_trait::Dimension","iterators::lanes::LanesMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::to_vec":["geomspace::Geomspace","iterators::TrustedIterator","std::alloc::Allocator","std::iter::ExactSizeIterator","std::marker::Sized","std::vec::Vec"],"iterators::to_vec_mapped":["geomspace::Geomspace","iterators::TrustedIterator","std::alloc::Allocator","std::iter::ExactSizeIterator","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"iterators::windows::Windows":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::windows::Windows::<'a, A, D>::new":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","iterators::windows::Windows","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"iterators::windows::WindowsIter":["iterators::Baseiter","iterators::ElementsBase","iterators::windows::WindowsIter","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"itertools::enumerate":["ArrayBase","ArrayView","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::iter::Enumerate","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"itertools::zip":["ArrayBase","ArrayView","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::iter::IntoIterator","std::iter::Zip","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"layout::Layout":["layout::Layout"],"layout::Layout::and":["layout::Layout"],"layout::Layout::c":["layout::Layout"],"layout::Layout::f":["layout::Layout"],"layout::Layout::flag":["layout::Layout"],"layout::Layout::is":["layout::Layout"],"layout::Layout::new":["layout::Layout"],"layout::Layout::none":["layout::Layout"],"layout::Layout::one_dimensional":["layout::Layout"],"layout::layoutfmt::<impl std::fmt::Debug for layout::Layout>::fmt":["layout::Layout","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"linalg::impl_linalg::<impl ArrayBase<S, D>>::scaled_add":["<T as linalg_traits::LinalgScalar>::T","ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","linalg_traits::LinalgScalar","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","linalg::impl_linalg::Dot","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot_generic":["<T as linalg_traits::LinalgScalar>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","linalg_traits::LinalgScalar","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot_impl":["<T as linalg_traits::LinalgScalar>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","linalg_traits::LinalgScalar","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::dot":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","linalg::impl_linalg::Dot","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::Dot::dot":[],"linalg::impl_linalg::cast_as":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::dot_shape_error":[],"linalg::impl_linalg::general_dot_shape_error":[],"linalg::impl_linalg::general_mat_mul":["<T as linalg_traits::LinalgScalar>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","linalg_traits::LinalgScalar","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::general_mat_vec_mul":["<T as linalg_traits::LinalgScalar>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::Data","data_traits::DataMut","data_traits::RawData","linalg_traits::LinalgScalar","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::mat_mul_general":["<T as linalg_traits::LinalgScalar>::T","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","linalg_traits::LinalgScalar","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"linalg::impl_linalg::same_type":["std::marker::Sized"],"linspace::Linspace":["linspace::Linspace","std::marker::Sized"],"linspace::linspace":["linspace::Linspace","num_traits::Float","std::marker::Sized"],"linspace::range":["linspace::Linspace","num_traits::Float","std::marker::Sized"],"logspace::Logspace":["logspace::Logspace","std::marker::Sized"],"logspace::logspace":["logspace::Logspace","num_traits::Float","std::marker::Sized"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::all_close":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::Data","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","num_traits::Float","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::mean":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","num_traits::FromPrimitive","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Add","std::ops::Div","std::option::Option","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::mean_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","num_traits::FromPrimitive","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Add","std::ops::Div","std::option::Option","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::product":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","num_traits::One","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Mul","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::scalar_sum":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Add","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::std_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","num_traits::Float","num_traits::FromPrimitive","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::sum":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::conversion::IntoDimension","dimension::dim::Dim","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Add","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::sum_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","num_traits::Zero","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Add","std::ptr::NonNull"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::var_axis":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","num_traits::Float","num_traits::FromPrimitive","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"numeric_util::unrolled_dot":["<T as linalg_traits::LinalgScalar>::T","linalg_traits::LinalgScalar","std::marker::Sized"],"numeric_util::unrolled_eq":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"numeric_util::unrolled_fold":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::ptr::NonNull"],"private::PrivateMarker":["private::PrivateMarker"],"shape_builder::<impl Shape<D>>::size":["Shape","std::marker::Sized"],"shape_builder::<impl std::convert::From<D> for Shape<D>>::from":["Shape","std::marker::Sized"],"shape_builder::<impl std::convert::From<T> for StrideShape<D>>::from":["StrideShape","std::marker::Sized"],"shape_builder::ShapeBuilder::f":["Shape","std::marker::Sized"],"shape_builder::ShapeBuilder::into_shape":["Shape","std::marker::Sized"],"shape_builder::ShapeBuilder::set_f":["Shape","std::marker::Sized"],"shape_builder::ShapeBuilder::strides":["StrideShape","std::marker::Sized"],"slice::MultiSlice::multi_slice_move":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"slice::Slice":["slice::Slice","std::marker::Sized","std::option::Option"],"slice::Slice::new":["slice::Slice","std::marker::Sized","std::option::Option"],"slice::Slice::step_by":["slice::Slice","std::marker::Sized","std::option::Option"],"slice::SliceInfo":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"slice::SliceInfo::<T, D>::new":["std::marker::Sized","std::result::Result"],"slice::SliceInfo::<T, D>::new_unchecked":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"slice::SliceInfo::<T, D>::out_ndim":["ArrayBase","CowRepr","ViewRepr","aliases::IxDyn","data_repr::OwnedRepr","data_traits::RawData","dimension::dim::Dim","dimension::dimension_trait::Dimension","slice::SliceInfo","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign","std::ptr::NonNull"],"slice::SliceNextDim::next_dim":["std::marker::PhantomData"],"slice::SliceOrIndex":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"slice::SliceOrIndex::is_index":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"slice::SliceOrIndex::is_slice":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"slice::SliceOrIndex::step_by":["slice::SliceOrIndex","std::marker::Sized","std::option::Option"],"stacking::stack":["<D as dimension::conversion::IntoDimension>::D","ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","dimension::axis::Axis","dimension::conversion::IntoDimension","dimension::dim::Dim","dimension::remove_axis::RemoveAxis","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"zip::<impl ArrayBase<S, D>>::layout_impl":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"zip::Broadcast::__private__":["private::PrivateMarker"],"zip::Broadcast::broadcast_unwrap":[],"zip::FoldWhile":["std::marker::Sized","zip::FoldWhile"],"zip::FoldWhile::<T>::into_inner":["std::marker::Sized","zip::FoldWhile"],"zip::FoldWhile::<T>::is_done":["std::marker::Sized","zip::FoldWhile"],"zip::IntoNdProducer::into_producer":[],"zip::NdProducer::__private__":["private::PrivateMarker"],"zip::NdProducer::as_ptr":[],"zip::NdProducer::as_ref":[],"zip::NdProducer::contiguous_stride":[],"zip::NdProducer::equal_dim":[],"zip::NdProducer::layout":["layout::Layout"],"zip::NdProducer::raw_dim":[],"zip::NdProducer::split_at":["dimension::axis::Axis","std::marker::Sized"],"zip::NdProducer::stride_of":["dimension::axis::Axis"],"zip::NdProducer::uget_ptr":[],"zip::Offset::__private__":["private::PrivateMarker"],"zip::Offset::stride_offset":[],"zip::OffsetTuple::stride_offset":[],"zip::Splittable::split_at":["dimension::axis::Axis"],"zip::Zip":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(P,), D>::from":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2), D>::all":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2), D>::and":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2), D>::and_broadcast":["<P as zip::IntoNdProducer>::P","aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2), D>::apply":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2), D>::apply_assign_into":["<P as zip::IntoNdProducer>::P","argument_traits::AssignElem","layout::Layout","std::marker::Sized","std::ops::FnMut","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2), D>::apply_collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","zip::Zip"],"zip::Zip::<(P1, P2), D>::fold":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2), D>::fold_while":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip"],"zip::Zip::<(P1, P2), D>::split":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::all":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::and":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::and_broadcast":["<P as zip::IntoNdProducer>::P","aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::apply":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::apply_assign_into":["<P as zip::IntoNdProducer>::P","argument_traits::AssignElem","layout::Layout","std::marker::Sized","std::ops::FnMut","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::apply_collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::fold":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::fold_while":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip"],"zip::Zip::<(P1, P2, P3), D>::split":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::all":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::and":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::and_broadcast":["<P as zip::IntoNdProducer>::P","aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::apply":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::apply_assign_into":["<P as zip::IntoNdProducer>::P","argument_traits::AssignElem","layout::Layout","std::marker::Sized","std::ops::FnMut","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::apply_collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::fold":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::fold_while":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4), D>::split":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::all":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::and":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::and_broadcast":["<P as zip::IntoNdProducer>::P","aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply_assign_into":["<P as zip::IntoNdProducer>::P","argument_traits::AssignElem","layout::Layout","std::marker::Sized","std::ops::FnMut","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply_collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::fold":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::fold_while":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::split":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::all":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::apply":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::fold":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::fold_while":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::split":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(P1,), D>::all":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1,), D>::and":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1,), D>::and_broadcast":["<P as zip::IntoNdProducer>::P","aliases::IxDyn","dimension::dim::Dim","dimension::dimension_trait::Dimension","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1,), D>::apply":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1,), D>::apply_assign_into":["<P as zip::IntoNdProducer>::P","argument_traits::AssignElem","layout::Layout","std::marker::Sized","std::ops::FnMut","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<(P1,), D>::apply_collect":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","zip::Zip"],"zip::Zip::<(P1,), D>::fold":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::Zip"],"zip::Zip::<(P1,), D>::fold_while":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip"],"zip::Zip::<(P1,), D>::split":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<(indexes::Indices<D>, P), D>::indexed":["<P as zip::IntoNdProducer>::P","layout::Layout","std::marker::Sized","zip::IntoNdProducer","zip::Zip"],"zip::Zip::<P, D>::apply_core":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip","zip::ZippableTuple"],"zip::Zip::<P, D>::apply_core_contiguous":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip","zip::ZippableTuple"],"zip::Zip::<P, D>::apply_core_strided":["layout::Layout","std::marker::Sized","std::ops::FnMut","zip::FoldWhile","zip::Zip","zip::ZippableTuple"],"zip::Zip::<P, D>::uninitalized_for_current_layout":["ArrayBase","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","zip::Zip"],"zip::Zip::<Parts, D>::check":["ArrayBase","ArrayView","CowRepr","ViewRepr","data_repr::OwnedRepr","data_traits::RawData","layout::Layout","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","zip::NdProducer","zip::Zip"],"zip::Zip::<Parts, D>::len_of":["dimension::axis::Axis","layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<Parts, D>::max_stride_axis":["dimension::axis::Axis","layout::Layout","std::marker::Sized","zip::Zip"],"zip::Zip::<Parts, D>::size":["layout::Layout","std::marker::Sized","zip::Zip"],"zip::ZippableTuple::as_ptr":[],"zip::ZippableTuple::as_ref":[],"zip::ZippableTuple::contiguous_stride":[],"zip::ZippableTuple::split_at":["dimension::axis::Axis"],"zip::ZippableTuple::stride_of":[],"zip::ZippableTuple::uget_ptr":[]},"glob_path_import":{"aliases":"","dimension::dim":"dimension::","free_functions":"","impl_views::constructors":"impl_views::","impl_views::conversions":"impl_views::","impl_views::indexing":"impl_views::","impl_views::splitting":"impl_views::","prelude":"imp_prelude::"},"self_to_fn":{"<D as dimension::DimensionExt>::D":["impl<D> DimensionExt for D\nwhere\n    D: Dimension,\n{\n    #[inline]\n    fn axis(&self, axis: Axis) -> Ix {\n        self[axis.index()]\n    }\n\n    #[inline]\n    fn set_axis(&mut self, axis: Axis, value: Ix) {\n        self[axis.index()] = value;\n    }\n}"],"<D as dimension::conversion::IntoDimension>::D":["impl<D> IntoDimension for D\nwhere\n    D: Dimension,\n{\n    type Dim = D;\n    #[inline(always)]\n    fn into_dimension(self) -> Self {\n        self\n    }\n}"],"<D as dimension::ndindex::NdIndex<D>>::D":["unsafe impl<D> NdIndex<D> for D\nwhere\n    D: Dimension,\n{\n    fn index_checked(&self, dim: &D, strides: &D) -> Option<isize> {\n        dim.stride_offset_checked(strides, self)\n    }\n    fn index_unchecked(&self, strides: &D) -> isize {\n        D::stride_offset(self, strides)\n    }\n}"],"<D as zip::Splittable>::D":["impl<D> Splittable for D\nwhere\n    D: Dimension,\n{\n    fn split_at(self, axis: Axis, index: Ix) -> (Self, Self) {\n        let mut d1 = self;\n        let mut d2 = d1.clone();\n        let i = axis.index();\n        let len = d1[i];\n        d1[i] = index;\n        d2[i] = len - index;\n        (d1, d2)\n    }\n}"],"<P as zip::IntoNdProducer>::P":["impl<P> IntoNdProducer for P\nwhere\n    P: NdProducer,\n{\n    type Item = P::Item;\n    type Dim = P::Dim;\n    type Output = Self;\n    fn into_producer(self) -> Self::Output {\n        self\n    }\n}"],"<T as arraytraits::AsArray<'a, A, D>>::T":["impl<'a, A: 'a, D, T> AsArray<'a, A, D> for T\nwhere\n    T: Into<ArrayView<'a, A, D>>,\n    D: Dimension,\n{\n}"],"<T as data_traits::DataClone>::T":["impl<T> DataClone for T where T: Data + RawDataClone {}"],"<T as linalg_traits::LinalgScalar>::T":["impl<T> LinalgScalar for T where\n    T: 'static\n        + Copy\n        + Zero\n        + One\n        + Add<Output = T>\n        + Sub<Output = T>\n        + Mul<Output = T>\n        + Div<Output = T>\n{\n}"],"<T as shape_builder::ShapeBuilder>::T":["impl<T> ShapeBuilder for T\nwhere\n    T: IntoDimension,\n{\n    type Dim = T::Dim;\n    type Strides = T;\n    fn into_shape(self) -> Shape<Self::Dim> {\n        Shape {\n            dim: self.into_dimension(),\n            is_c: true,\n        }\n    }\n    fn f(self) -> Shape<Self::Dim> {\n        self.set_f(true)\n    }\n    fn set_f(self, is_f: bool) -> Shape<Self::Dim> {\n        self.into_shape().set_f(is_f)\n    }\n    fn strides(self, st: T) -> StrideShape<Self::Dim> {\n        self.into_shape().strides(st.into_dimension())\n    }\n}"],"Array":["impl<A, D> Array<A, D>\nwhere\n    D: Dimension,\n{\n    /// Return a vector of the elements in the array, in the way they are\n    /// stored internally.\n    ///\n    /// If the array is in standard memory layout, the logical element order\n    /// of the array (`.iter()` order) and of the returned vector will be the same.\n    pub fn into_raw_vec(self) -> Vec<A> {\n        self.data.into_vec()\n    }\n}","impl<A> Array<A, Ix0> {\n    /// Returns the single element in the array without cloning it.\n    ///\n    /// ```\n    /// use ndarray::{arr0, Array0};\n    ///\n    /// // `Foo` doesn't implement `Clone`.\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct Foo;\n    ///\n    /// let array: Array0<Foo> = arr0(Foo);\n    /// let scalar: Foo = array.into_scalar();\n    /// assert_eq!(scalar, Foo);\n    /// ```\n    pub fn into_scalar(self) -> A {\n        let size = ::std::mem::size_of::<A>();\n        if size == 0 {\n            // Any index in the `Vec` is fine since all elements are identical.\n            self.data.into_vec().remove(0)\n        } else {\n            // Find the index in the `Vec` corresponding to `self.ptr`.\n            // (This is necessary because the element in the array might not be\n            // the first element in the `Vec`, such as if the array was created\n            // by `array![1, 2, 3, 4].slice_move(s![2])`.)\n            let first = self.ptr.as_ptr() as usize;\n            let base = self.data.as_ptr() as usize;\n            let index = (first - base) / size;\n            debug_assert_eq!((first - base) % size, 0);\n            // Remove the element at the index and return it.\n            self.data.into_vec().remove(index)\n        }\n    }\n}"],"ArrayBase":["impl<'a, A, B, S, S2, D, E> $trt<&'a ArrayBase<S2, E>> for ArrayBase<S, D>\nwhere\n    A: Clone + $trt<B, Output=A>,\n    B: Clone,\n    S: DataOwned<Elem=A> + DataMut,\n    S2: Data<Elem=B>,\n    D: Dimension,\n    E: Dimension,\n{\n    type Output = ArrayBase<S, D>;\n    fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>\n    {\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }\n}","impl<'a, A, S, S2, D, E> $trt<&'a ArrayBase<S2, E>> for ArrayBase<S, D>\n            where\n                A: Clone + $trt<A>,\n                S: DataMut<Elem = A>,\n                S2: Data<Elem = A>,\n                D: Dimension,\n                E: Dimension,\n            {\n                fn $method(&mut self, rhs: &ArrayBase<S2, E>) {\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }\n            }","impl<'a, A: fmt::Binary, S, D: Dimension> fmt::Binary for ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }\n}","impl<'a, A: fmt::Debug, S, D: Dimension> fmt::Debug for ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)?;\n\n        // Add extra information for Debug\n        write!(\n            f,\n            \", shape={:?}, strides={:?}, layout={:?}\",\n            self.shape(),\n            self.strides(),\n            layout = self.view().layout()\n        )?;\n        match D::NDIM {\n            Some(ndim) => write!(f, \", const ndim={}\", ndim)?,\n            None => write!(f, \", dynamic ndim={}\", self.ndim())?,\n        }\n        Ok(())\n    }\n}","impl<'a, A: fmt::Display, S, D: Dimension> fmt::Display for ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }\n}","impl<'a, A: fmt::LowerExp, S, D: Dimension> fmt::LowerExp for ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }\n}","impl<'a, A: fmt::LowerHex, S, D: Dimension> fmt::LowerHex for ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }\n}","impl<'a, A: fmt::UpperExp, S, D: Dimension> fmt::UpperExp for ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }\n}","impl<'a, S, D> hash::Hash for ArrayBase<S, D>\nwhere\n    D: Dimension,\n    S: Data,\n    S::Elem: hash::Hash,\n{\n    // Note: elements are hashed in the logical order\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.shape().hash(state);\n        if let Some(self_s) = self.as_slice() {\n            hash::Hash::hash_slice(self_s, state);\n        } else {\n            for row in self.inner_rows() {\n                if let Some(row_s) = row.as_slice() {\n                    hash::Hash::hash_slice(row_s, state);\n                } else {\n                    for elt in row {\n                        elt.hash(state)\n                    }\n                }\n            }\n        }\n    }\n}","impl<A, B, S, S2, D, E> $trt<ArrayBase<S2, E>> for ArrayBase<S, D>\nwhere\n    A: Clone + $trt<B, Output=A>,\n    B: Clone,\n    S: DataOwned<Elem=A> + DataMut,\n    S2: Data<Elem=B>,\n    D: Dimension,\n    E: Dimension,\n{\n    type Output = ArrayBase<S, D>;\n    fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>\n    {\n        self.$mth(&rhs)\n    }\n}","impl<A, B, S, S2, D> PartialEq<ArrayBase<S2, D>> for ArrayBase<S, D>\nwhere\n    A: PartialEq<B>,\n    S: Data<Elem = A>,\n    S2: Data<Elem = B>,\n    D: Dimension,\n{\n    fn eq(&self, rhs: &ArrayBase<S2, D>) -> bool {\n        if self.shape() != rhs.shape() {\n            return false;\n        }\n        if let Some(self_s) = self.as_slice() {\n            if let Some(rhs_s) = rhs.as_slice() {\n                return numeric_util::unrolled_eq(self_s, rhs_s);\n            }\n        }\n        Zip::from(self)\n            .and(rhs)\n            .fold_while(true, |_, a, b| {\n                if a != b {\n                    FoldWhile::Done(false)\n                } else {\n                    FoldWhile::Continue(true)\n                }\n            })\n            .into_inner()\n    }\n}","impl<A, S, D, B> $trt<B> for ArrayBase<S, D>\n    where A: Clone + $trt<B, Output=A>,\n          S: DataOwned<Elem=A> + DataMut,\n          D: Dimension,\n          B: ScalarOperand,\n{\n    type Output = ArrayBase<S, D>;\n    fn $mth(mut self, x: B) -> ArrayBase<S, D> {\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }\n}","impl<A, S, D> $trt<A> for ArrayBase<S, D>\n            where\n                A: ScalarOperand + $trt<A>,\n                S: DataMut<Elem = A>,\n                D: Dimension,\n            {\n                fn $method(&mut self, rhs: A) {\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }\n            }","impl<A, S, D> ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n    D: Dimension,\n{\n    #[inline]\n    fn broadcast_unwrap<E>(&self, dim: E) -> ArrayView<'_, A, E>\n    where\n        E: Dimension,\n    {\n        #[cold]\n        #[inline(never)]\n        fn broadcast_panic<D, E>(from: &D, to: &E) -> !\n        where\n            D: Dimension,\n            E: Dimension,\n        {\n            panic!(\n                \"ndarray: could not broadcast array from shape: {:?} to: {:?}\",\n                from.slice(),\n                to.slice()\n            )\n        }\n\n        match self.broadcast(dim.clone()) {\n            Some(it) => it,\n            None => broadcast_panic(&self.dim, &dim),\n        }\n    }\n\n    // Broadcast to dimension `E`, without checking that the dimensions match\n    // (Checked in debug assertions).\n    #[inline]\n    fn broadcast_assume<E>(&self, dim: E) -> ArrayView<'_, A, E>\n    where\n        E: Dimension,\n    {\n        let dim = dim.into_dimension();\n        debug_assert_eq!(self.shape(), dim.slice());\n        let ptr = self.ptr;\n        let mut strides = dim.clone();\n        strides.slice_mut().copy_from_slice(self.strides.slice());\n        unsafe { ArrayView::new(ptr, dim, strides) }\n    }\n\n    fn raw_strides(&self) -> D {\n        self.strides.clone()\n    }\n\n    /// Apply closure `f` to each element in the array, in whatever\n    /// order is the fastest to visit.\n    fn unordered_foreach_mut<F>(&mut self, mut f: F)\n    where\n        S: DataMut,\n        F: FnMut(&mut A),\n    {\n        if let Some(slc) = self.as_slice_memory_order_mut() {\n            slc.iter_mut().for_each(f);\n        } else {\n            for row in self.inner_rows_mut() {\n                row.into_iter_().fold((), |(), elt| f(elt));\n            }\n        }\n    }\n\n    /// Remove array axis `axis` and return the result.\n    fn try_remove_axis(self, axis: Axis) -> ArrayBase<S, D::Smaller> {\n        let d = self.dim.try_remove_axis(axis);\n        let s = self.strides.try_remove_axis(axis);\n        ArrayBase {\n            ptr: self.ptr,\n            data: self.data,\n            dim: d,\n            strides: s,\n        }\n    }\n\n    /// n-d generalization of rows, just like inner iter\n    fn inner_rows(&self) -> iterators::Lanes<'_, A, D::Smaller> {\n        let n = self.ndim();\n        Lanes::new(self.view(), Axis(n.saturating_sub(1)))\n    }\n\n    /// n-d generalization of rows, just like inner iter\n    fn inner_rows_mut(&mut self) -> iterators::LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n    {\n        let n = self.ndim();\n        LanesMut::new(self.view_mut(), Axis(n.saturating_sub(1)))\n    }\n}","impl<A, S, D> ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n    D: Dimension,\n{\n    /// Perform the operation `self += alpha * rhs` efficiently, where\n    /// `alpha` is a scalar and `rhs` is another array. This operation is\n    /// also known as `axpy` in BLAS.\n    ///\n    /// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n    ///\n    /// **Panics** if broadcasting isnt possible.\n    pub fn scaled_add<S2, E>(&mut self, alpha: A, rhs: &ArrayBase<S2, E>)\n    where\n        S: DataMut,\n        S2: Data<Elem = A>,\n        A: LinalgScalar,\n        E: Dimension,\n    {\n        self.zip_mut_with(rhs, move |y, &x| *y = *y + (alpha * x));\n    }\n}","impl<A, S, D> ArrayBase<S, D>\nwhere\n    S: Data<Elem = A>,\n    D: Dimension,\n{\n    /// Return the sum of all elements in the array.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let a = arr2(&[[1., 2.],\n    ///                [3., 4.]]);\n    /// assert_eq!(a.sum(), 10.);\n    /// ```\n    pub fn sum(&self) -> A\n    where\n        A: Clone + Add<Output = A> + num_traits::Zero,\n    {\n        if let Some(slc) = self.as_slice_memory_order() {\n            return numeric_util::unrolled_fold(slc, A::zero, A::add);\n        }\n        let mut sum = A::zero();\n        for row in self.inner_rows() {\n            if let Some(slc) = row.as_slice() {\n                sum = sum + numeric_util::unrolled_fold(slc, A::zero, A::add);\n            } else {\n                sum = sum + row.iter().fold(A::zero(), |acc, elt| acc + elt.clone());\n            }\n        }\n        sum\n    }\n\n    /// Returns the [arithmetic mean] x of all elements in the array:\n    ///\n    /// ```text\n    ///     1   n\n    /// x =     x\n    ///     n  i=1\n    /// ```\n    ///\n    /// If the array is empty, `None` is returned.\n    ///\n    /// **Panics** if `A::from_usize()` fails to convert the number of elements in the array.\n    ///\n    /// [arithmetic mean]: https://en.wikipedia.org/wiki/Arithmetic_mean\n    pub fn mean(&self) -> Option<A>\n    where\n        A: Clone + FromPrimitive + Add<Output = A> + Div<Output = A> + Zero,\n    {\n        let n_elements = self.len();\n        if n_elements == 0 {\n            None\n        } else {\n            let n_elements = A::from_usize(n_elements)\n                .expect(\"Converting number of elements to `A` must not fail.\");\n            Some(self.sum() / n_elements)\n        }\n    }\n\n    /// Return the sum of all elements in the array.\n    ///\n    /// *This method has been renamed to `.sum()` and will be deprecated in the\n    /// next version.*\n    // #[deprecated(note=\"renamed to `sum`\", since=\"0.13\")]\n    pub fn scalar_sum(&self) -> A\n    where\n        A: Clone + Add<Output = A> + num_traits::Zero,\n    {\n        self.sum()\n    }\n\n    /// Return the product of all elements in the array.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let a = arr2(&[[1., 2.],\n    ///                [3., 4.]]);\n    /// assert_eq!(a.product(), 24.);\n    /// ```\n    pub fn product(&self) -> A\n    where\n        A: Clone + Mul<Output = A> + num_traits::One,\n    {\n        if let Some(slc) = self.as_slice_memory_order() {\n            return numeric_util::unrolled_fold(slc, A::one, A::mul);\n        }\n        let mut sum = A::one();\n        for row in self.inner_rows() {\n            if let Some(slc) = row.as_slice() {\n                sum = sum * numeric_util::unrolled_fold(slc, A::one, A::mul);\n            } else {\n                sum = sum * row.iter().fold(A::one(), |acc, elt| acc * elt.clone());\n            }\n        }\n        sum\n    }\n\n    /// Return sum along `axis`.\n    ///\n    /// ```\n    /// use ndarray::{aview0, aview1, arr2, Axis};\n    ///\n    /// let a = arr2(&[[1., 2., 3.],\n    ///                [4., 5., 6.]]);\n    /// assert!(\n    ///     a.sum_axis(Axis(0)) == aview1(&[5., 7., 9.]) &&\n    ///     a.sum_axis(Axis(1)) == aview1(&[6., 15.]) &&\n    ///\n    ///     a.sum_axis(Axis(0)).sum_axis(Axis(0)) == aview0(&21.)\n    /// );\n    /// ```\n    ///\n    /// **Panics** if `axis` is out of bounds.\n    pub fn sum_axis(&self, axis: Axis) -> Array<A, D::Smaller>\n    where\n        A: Clone + Zero + Add<Output = A>,\n        D: RemoveAxis,\n    {\n        let n = self.len_of(axis);\n        let mut res = Array::zeros(self.raw_dim().remove_axis(axis));\n        let stride = self.strides()[axis.index()];\n        if self.ndim() == 2 && stride == 1 {\n            // contiguous along the axis we are summing\n            let ax = axis.index();\n            for (i, elt) in enumerate(&mut res) {\n                *elt = self.index_axis(Axis(1 - ax), i).sum();\n            }\n        } else {\n            for i in 0..n {\n                let view = self.index_axis(axis, i);\n                res = res + &view;\n            }\n        }\n        res\n    }\n\n    /// Return mean along `axis`.\n    ///\n    /// Return `None` if the length of the axis is zero.\n    ///\n    /// **Panics** if `axis` is out of bounds or if `A::from_usize()`\n    /// fails for the axis length.\n    ///\n    /// ```\n    /// use ndarray::{aview0, aview1, arr2, Axis};\n    ///\n    /// let a = arr2(&[[1., 2., 3.],\n    ///                [4., 5., 6.]]);\n    /// assert!(\n    ///     a.mean_axis(Axis(0)).unwrap() == aview1(&[2.5, 3.5, 4.5]) &&\n    ///     a.mean_axis(Axis(1)).unwrap() == aview1(&[2., 5.]) &&\n    ///\n    ///     a.mean_axis(Axis(0)).unwrap().mean_axis(Axis(0)).unwrap() == aview0(&3.5)\n    /// );\n    /// ```\n    pub fn mean_axis(&self, axis: Axis) -> Option<Array<A, D::Smaller>>\n    where\n        A: Clone + Zero + FromPrimitive + Add<Output = A> + Div<Output = A>,\n        D: RemoveAxis,\n    {\n        let axis_length = self.len_of(axis);\n        if axis_length == 0 {\n            None\n        } else {\n            let axis_length =\n                A::from_usize(axis_length).expect(\"Converting axis length to `A` must not fail.\");\n            let sum = self.sum_axis(axis);\n            Some(sum / aview0(&axis_length))\n        }\n    }\n\n    /// Return variance along `axis`.\n    ///\n    /// The variance is computed using the [Welford one-pass\n    /// algorithm](https://www.jstor.org/stable/1266577).\n    ///\n    /// The parameter `ddof` specifies the \"delta degrees of freedom\". For\n    /// example, to calculate the population variance, use `ddof = 0`, or to\n    /// calculate the sample variance, use `ddof = 1`.\n    ///\n    /// The variance is defined as:\n    ///\n    /// ```text\n    ///               1       n\n    /// variance =     (x - x)\n    ///            n - ddof  i=1\n    /// ```\n    ///\n    /// where\n    ///\n    /// ```text\n    ///     1   n\n    /// x =     x\n    ///     n  i=1\n    /// ```\n    ///\n    /// and `n` is the length of the axis.\n    ///\n    /// **Panics** if `ddof` is less than zero or greater than `n`, if `axis`\n    /// is out of bounds, or if `A::from_usize()` fails for any any of the\n    /// numbers in the range `0..=n`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use ndarray::{aview1, arr2, Axis};\n    ///\n    /// let a = arr2(&[[1., 2.],\n    ///                [3., 4.],\n    ///                [5., 6.]]);\n    /// let var = a.var_axis(Axis(0), 1.);\n    /// assert_eq!(var, aview1(&[4., 4.]));\n    /// ```\n    pub fn var_axis(&self, axis: Axis, ddof: A) -> Array<A, D::Smaller>\n    where\n        A: Float + FromPrimitive,\n        D: RemoveAxis,\n    {\n        let zero = A::from_usize(0).expect(\"Converting 0 to `A` must not fail.\");\n        let n = A::from_usize(self.len_of(axis)).expect(\"Converting length to `A` must not fail.\");\n        assert!(\n            !(ddof < zero || ddof > n),\n            \"`ddof` must not be less than zero or greater than the length of \\\n             the axis\",\n        );\n        let dof = n - ddof;\n        let mut mean = Array::<A, _>::zeros(self.dim.remove_axis(axis));\n        let mut sum_sq = Array::<A, _>::zeros(self.dim.remove_axis(axis));\n        for (i, subview) in self.axis_iter(axis).enumerate() {\n            let count = A::from_usize(i + 1).expect(\"Converting index to `A` must not fail.\");\n            azip!((mean in &mut mean, sum_sq in &mut sum_sq, &x in &subview) {\n                let delta = x - *mean;\n                *mean = *mean + delta / count;\n                *sum_sq = (x - *mean).mul_add(delta, *sum_sq);\n            });\n        }\n        sum_sq.mapv_into(|s| s / dof)\n    }\n\n    /// Return standard deviation along `axis`.\n    ///\n    /// The standard deviation is computed from the variance using\n    /// the [Welford one-pass algorithm](https://www.jstor.org/stable/1266577).\n    ///\n    /// The parameter `ddof` specifies the \"delta degrees of freedom\". For\n    /// example, to calculate the population standard deviation, use `ddof = 0`,\n    /// or to calculate the sample standard deviation, use `ddof = 1`.\n    ///\n    /// The standard deviation is defined as:\n    ///\n    /// ```text\n    ///                   1       n          \n    /// stddev = sqrt      (x - x)\n    ///                n - ddof  i=1         \n    /// ```\n    ///\n    /// where\n    ///\n    /// ```text\n    ///     1   n\n    /// x =     x\n    ///     n  i=1\n    /// ```\n    ///\n    /// and `n` is the length of the axis.\n    ///\n    /// **Panics** if `ddof` is less than zero or greater than `n`, if `axis`\n    /// is out of bounds, or if `A::from_usize()` fails for any any of the\n    /// numbers in the range `0..=n`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use ndarray::{aview1, arr2, Axis};\n    ///\n    /// let a = arr2(&[[1., 2.],\n    ///                [3., 4.],\n    ///                [5., 6.]]);\n    /// let stddev = a.std_axis(Axis(0), 1.);\n    /// assert_eq!(stddev, aview1(&[2., 2.]));\n    /// ```\n    pub fn std_axis(&self, axis: Axis, ddof: A) -> Array<A, D::Smaller>\n    where\n        A: Float + FromPrimitive,\n        D: RemoveAxis,\n    {\n        self.var_axis(axis, ddof).mapv_into(|x| x.sqrt())\n    }\n\n    /// Return `true` if the arrays' elementwise differences are all within\n    /// the given absolute tolerance, `false` otherwise.\n    ///\n    /// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n    ///\n    /// **Panics** if broadcasting to the same shape isnt possible.\n    #[deprecated(\n        note = \"Use `abs_diff_eq` - it requires the `approx` crate feature\",\n        since = \"0.13.0\"\n    )]\n    pub fn all_close<S2, E>(&self, rhs: &ArrayBase<S2, E>, tol: A) -> bool\n    where\n        A: Float,\n        S2: Data<Elem = A>,\n        E: Dimension,\n    {\n        !Zip::from(self)\n            .and(rhs.broadcast_unwrap(self.raw_dim()))\n            .fold_while((), |_, x, y| {\n                if (*x - *y).abs() <= tol {\n                    FoldWhile::Continue(())\n                } else {\n                    FoldWhile::Done(())\n                }\n            })\n            .is_done()\n    }\n}","impl<A, S, D> ArrayBase<S, D>\nwhere\n    S: RawData<Elem = A>,\n    D: Dimension,\n{\n    /// Return the total number of elements in the array.\n    pub fn len(&self) -> usize {\n        self.dim.size()\n    }\n\n    /// Return the length of `axis`.\n    ///\n    /// The axis should be in the range `Axis(` 0 .. *n* `)` where *n* is the\n    /// number of dimensions (axes) of the array.\n    ///\n    /// ***Panics*** if the axis is out of bounds.\n    pub fn len_of(&self, axis: Axis) -> usize {\n        self.dim[axis.index()]\n    }\n\n    /// Return whether the array has any elements\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Return the number of dimensions (axes) in the array\n    pub fn ndim(&self) -> usize {\n        self.dim.ndim()\n    }\n\n    /// Return the shape of the array in its pattern form,\n    /// an integer in the one-dimensional case, tuple in the n-dimensional cases\n    /// and so on.\n    pub fn dim(&self) -> D::Pattern {\n        self.dim.clone().into_pattern()\n    }\n\n    /// Return the shape of the array as it stored in the array.\n    ///\n    /// This is primarily useful for passing to other `ArrayBase`\n    /// functions, such as when creating another array of the same\n    /// shape and dimensionality.\n    ///\n    /// ```\n    /// use ndarray::Array;\n    ///\n    /// let a = Array::from_elem((2, 3), 5.);\n    ///\n    /// // Create an array of zeros that's the same shape and dimensionality as `a`.\n    /// let b = Array::<f64, _>::zeros(a.raw_dim());\n    /// ```\n    pub fn raw_dim(&self) -> D {\n        self.dim.clone()\n    }\n\n    /// Return the shape of the array as a slice.\n    ///\n    /// Note that you probably don't want to use this to create an array of the\n    /// same shape as another array because creating an array with e.g.\n    /// [`Array::zeros()`](ArrayBase::zeros) using a shape of type `&[usize]`\n    /// results in a dynamic-dimensional array. If you want to create an array\n    /// that has the same shape and dimensionality as another array, use\n    /// [`.raw_dim()`](ArrayBase::raw_dim) instead:\n    ///\n    /// ```rust\n    /// use ndarray::{Array, Array2};\n    ///\n    /// let a = Array2::<i32>::zeros((3, 4));\n    /// let shape = a.shape();\n    /// assert_eq!(shape, &[3, 4]);\n    ///\n    /// // Since `a.shape()` returned `&[usize]`, we get an `ArrayD` instance:\n    /// let b = Array::zeros(shape);\n    /// assert_eq!(a.clone().into_dyn(), b);\n    ///\n    /// // To get the same dimension type, use `.raw_dim()` instead:\n    /// let c = Array::zeros(a.raw_dim());\n    /// assert_eq!(a, c);\n    /// ```\n    pub fn shape(&self) -> &[usize] {\n        self.dim.slice()\n    }\n\n    /// Return the strides of the array as a slice.\n    pub fn strides(&self) -> &[isize] {\n        let s = self.strides.slice();\n        // reinterpret unsigned integer as signed\n        unsafe { slice::from_raw_parts(s.as_ptr() as *const _, s.len()) }\n    }\n\n    /// Return the stride of `axis`.\n    ///\n    /// The axis should be in the range `Axis(` 0 .. *n* `)` where *n* is the\n    /// number of dimensions (axes) of the array.\n    ///\n    /// ***Panics*** if the axis is out of bounds.\n    pub fn stride_of(&self, axis: Axis) -> isize {\n        // strides are reinterpreted as isize\n        self.strides[axis.index()] as isize\n    }\n\n    /// Return a read-only view of the array\n    pub fn view(&self) -> ArrayView<'_, A, D>\n    where\n        S: Data,\n    {\n        debug_assert!(self.pointer_is_inbounds());\n        unsafe { ArrayView::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }\n\n    /// Return a read-write view of the array\n    pub fn view_mut(&mut self) -> ArrayViewMut<'_, A, D>\n    where\n        S: DataMut,\n    {\n        self.ensure_unique();\n        unsafe { ArrayViewMut::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }\n\n    /// Return an uniquely owned copy of the array.\n    ///\n    /// If the input array is contiguous and its strides are positive, then the\n    /// output array will have the same memory layout. Otherwise, the layout of\n    /// the output array is unspecified. If you need a particular layout, you\n    /// can allocate a new array with the desired memory layout and\n    /// [`.assign()`](#method.assign) the data. Alternatively, you can collect\n    /// an iterator, like this for a result in standard layout:\n    ///\n    /// ```\n    /// # use ndarray::prelude::*;\n    /// # let arr = Array::from_shape_vec((2, 2).f(), vec![1, 2, 3, 4]).unwrap();\n    /// # let owned = {\n    /// Array::from_shape_vec(arr.raw_dim(), arr.iter().cloned().collect()).unwrap()\n    /// # };\n    /// # assert!(owned.is_standard_layout());\n    /// # assert_eq!(arr, owned);\n    /// ```\n    ///\n    /// or this for a result in column-major (Fortran) layout:\n    ///\n    /// ```\n    /// # use ndarray::prelude::*;\n    /// # let arr = Array::from_shape_vec((2, 2), vec![1, 2, 3, 4]).unwrap();\n    /// # let owned = {\n    /// Array::from_shape_vec(arr.raw_dim().f(), arr.t().iter().cloned().collect()).unwrap()\n    /// # };\n    /// # assert!(owned.t().is_standard_layout());\n    /// # assert_eq!(arr, owned);\n    /// ```\n    pub fn to_owned(&self) -> Array<A, D>\n    where\n        A: Clone,\n        S: Data,\n    {\n        if let Some(slc) = self.as_slice_memory_order() {\n            unsafe {\n                Array::from_shape_vec_unchecked(\n                    self.dim.clone().strides(self.strides.clone()),\n                    slc.to_vec(),\n                )\n            }\n        } else {\n            self.map(|x| x.clone())\n        }\n    }\n\n    /// Return a shared ownership (copy on write) array.\n    pub fn to_shared(&self) -> ArcArray<A, D>\n    where\n        A: Clone,\n        S: Data,\n    {\n        // FIXME: Avoid copying if its already an ArcArray.\n        self.to_owned().into_shared()\n    }\n\n    /// Turn the array into a uniquely owned array, cloning the array elements\n    /// if necessary.\n    pub fn into_owned(self) -> Array<A, D>\n    where\n        A: Clone,\n        S: Data,\n    {\n        S::into_owned(self)\n    }\n\n    /// Turn the array into a shared ownership (copy on write) array,\n    /// without any copying.\n    pub fn into_shared(self) -> ArcArray<A, D>\n    where\n        S: DataOwned,\n    {\n        let data = self.data.into_shared();\n        ArrayBase {\n            data,\n            ptr: self.ptr,\n            dim: self.dim,\n            strides: self.strides,\n        }\n    }\n\n    /// Returns a reference to the first element of the array, or `None` if it\n    /// is empty.\n    pub fn first(&self) -> Option<&A>\n    where\n        S: Data,\n    {\n        if self.is_empty() {\n            None\n        } else {\n            Some(unsafe { &*self.as_ptr() })\n        }\n    }\n\n    /// Returns a mutable reference to the first element of the array, or\n    /// `None` if it is empty.\n    pub fn first_mut(&mut self) -> Option<&mut A>\n    where\n        S: DataMut,\n    {\n        if self.is_empty() {\n            None\n        } else {\n            Some(unsafe { &mut *self.as_mut_ptr() })\n        }\n    }\n\n    /// Return an iterator of references to the elements of the array.\n    ///\n    /// Elements are visited in the *logical order* of the array, which\n    /// is where the rightmost index is varying the fastest.\n    ///\n    /// Iterator element type is `&A`.\n    pub fn iter(&self) -> Iter<'_, A, D>\n    where\n        S: Data,\n    {\n        debug_assert!(self.pointer_is_inbounds());\n        self.view().into_iter_()\n    }\n\n    /// Return an iterator of mutable references to the elements of the array.\n    ///\n    /// Elements are visited in the *logical order* of the array, which\n    /// is where the rightmost index is varying the fastest.\n    ///\n    /// Iterator element type is `&mut A`.\n    pub fn iter_mut(&mut self) -> IterMut<'_, A, D>\n    where\n        S: DataMut,\n    {\n        self.view_mut().into_iter_()\n    }\n\n    /// Return an iterator of indexes and references to the elements of the array.\n    ///\n    /// Elements are visited in the *logical order* of the array, which\n    /// is where the rightmost index is varying the fastest.\n    ///\n    /// Iterator element type is `(D::Pattern, &A)`.\n    ///\n    /// See also [`Zip::indexed`](struct.Zip.html)\n    pub fn indexed_iter(&self) -> IndexedIter<'_, A, D>\n    where\n        S: Data,\n    {\n        IndexedIter::new(self.view().into_elements_base())\n    }\n\n    /// Return an iterator of indexes and mutable references to the elements of the array.\n    ///\n    /// Elements are visited in the *logical order* of the array, which\n    /// is where the rightmost index is varying the fastest.\n    ///\n    /// Iterator element type is `(D::Pattern, &mut A)`.\n    pub fn indexed_iter_mut(&mut self) -> IndexedIterMut<'_, A, D>\n    where\n        S: DataMut,\n    {\n        IndexedIterMut::new(self.view_mut().into_elements_base())\n    }\n\n    /// Return a sliced view of the array.\n    ///\n    /// See [*Slicing*](#slicing) for full documentation.\n    /// See also [`SliceInfo`] and [`D::SliceArg`].\n    ///\n    /// [`SliceInfo`]: struct.SliceInfo.html\n    /// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// (**Panics** if `D` is `IxDyn` and `info` does not match the number of array axes.)\n    pub fn slice<Do>(&self, info: &SliceInfo<D::SliceArg, Do>) -> ArrayView<'_, A, Do>\n    where\n        Do: Dimension,\n        S: Data,\n    {\n        self.view().slice_move(info)\n    }\n\n    /// Return a sliced read-write view of the array.\n    ///\n    /// See [*Slicing*](#slicing) for full documentation.\n    /// See also [`SliceInfo`] and [`D::SliceArg`].\n    ///\n    /// [`SliceInfo`]: struct.SliceInfo.html\n    /// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// (**Panics** if `D` is `IxDyn` and `info` does not match the number of array axes.)\n    pub fn slice_mut<Do>(&mut self, info: &SliceInfo<D::SliceArg, Do>) -> ArrayViewMut<'_, A, Do>\n    where\n        Do: Dimension,\n        S: DataMut,\n    {\n        self.view_mut().slice_move(info)\n    }\n\n    /// Return multiple disjoint, sliced, mutable views of the array.\n    ///\n    /// See [*Slicing*](#slicing) for full documentation.\n    /// See also [`SliceInfo`] and [`D::SliceArg`].\n    ///\n    /// [`SliceInfo`]: struct.SliceInfo.html\n    /// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n    ///\n    /// **Panics** if any of the following occur:\n    ///\n    /// * if any of the views would intersect (i.e. if any element would appear in multiple slices)\n    /// * if an index is out of bounds or step size is zero\n    /// * if `D` is `IxDyn` and `info` does not match the number of array axes\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use ndarray::{arr2, s};\n    ///\n    /// let mut a = arr2(&[[1, 2, 3], [4, 5, 6]]);\n    /// let (mut edges, mut middle) = a.multi_slice_mut((s![.., ..;2], s![.., 1]));\n    /// edges.fill(1);\n    /// middle.fill(0);\n    /// assert_eq!(a, arr2(&[[1, 0, 1], [1, 0, 1]]));\n    /// ```\n    pub fn multi_slice_mut<'a, M>(&'a mut self, info: M) -> M::Output\n    where\n        M: MultiSlice<'a, A, D>,\n        S: DataMut,\n    {\n        info.multi_slice_move(self.view_mut())\n    }\n\n    /// Slice the array, possibly changing the number of dimensions.\n    ///\n    /// See [*Slicing*](#slicing) for full documentation.\n    /// See also [`SliceInfo`] and [`D::SliceArg`].\n    ///\n    /// [`SliceInfo`]: struct.SliceInfo.html\n    /// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// (**Panics** if `D` is `IxDyn` and `info` does not match the number of array axes.)\n    pub fn slice_move<Do>(mut self, info: &SliceInfo<D::SliceArg, Do>) -> ArrayBase<S, Do>\n    where\n        Do: Dimension,\n    {\n        // Slice and collapse in-place without changing the number of dimensions.\n        self.slice_collapse(&*info);\n\n        let indices: &[SliceOrIndex] = (**info).as_ref();\n\n        // Copy the dim and strides that remain after removing the subview axes.\n        let out_ndim = info.out_ndim();\n        let mut new_dim = Do::zeros(out_ndim);\n        let mut new_strides = Do::zeros(out_ndim);\n        izip!(self.dim.slice(), self.strides.slice(), indices)\n            .filter_map(|(d, s, slice_or_index)| match slice_or_index {\n                SliceOrIndex::Slice { .. } => Some((d, s)),\n                SliceOrIndex::Index(_) => None,\n            })\n            .zip(izip!(new_dim.slice_mut(), new_strides.slice_mut()))\n            .for_each(|((d, s), (new_d, new_s))| {\n                *new_d = *d;\n                *new_s = *s;\n            });\n\n        ArrayBase {\n            ptr: self.ptr,\n            data: self.data,\n            dim: new_dim,\n            strides: new_strides,\n        }\n    }\n\n    /// Slice the array in place without changing the number of dimensions.\n    ///\n    /// Note that [`&SliceInfo`](struct.SliceInfo.html) (produced by the\n    /// [`s![]`](macro.s!.html) macro) will usually coerce into `&D::SliceArg`\n    /// automatically, but in some cases (e.g. if `D` is `IxDyn`), you may need\n    /// to call `.as_ref()`.\n    ///\n    /// See [*Slicing*](#slicing) for full documentation.\n    /// See also [`D::SliceArg`].\n    ///\n    /// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// (**Panics** if `D` is `IxDyn` and `indices` does not match the number of array axes.)\n    pub fn slice_collapse(&mut self, indices: &D::SliceArg) {\n        let indices: &[SliceOrIndex] = indices.as_ref();\n        assert_eq!(indices.len(), self.ndim());\n        indices\n            .iter()\n            .enumerate()\n            .for_each(|(axis, &slice_or_index)| match slice_or_index {\n                SliceOrIndex::Slice { start, end, step } => {\n                    self.slice_axis_inplace(Axis(axis), Slice { start, end, step })\n                }\n                SliceOrIndex::Index(index) => {\n                    let i_usize = abs_index(self.len_of(Axis(axis)), index);\n                    self.collapse_axis(Axis(axis), i_usize)\n                }\n            });\n    }\n\n    /// Slice the array in place without changing the number of dimensions.\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// (**Panics** if `D` is `IxDyn` and `indices` does not match the number of array axes.)\n    #[deprecated(note = \"renamed to `slice_collapse`\", since = \"0.12.1\")]\n    pub fn slice_inplace(&mut self, indices: &D::SliceArg) {\n        self.slice_collapse(indices)\n    }\n\n    /// Return a view of the array, sliced along the specified axis.\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// **Panics** if `axis` is out of bounds.\n    pub fn slice_axis(&self, axis: Axis, indices: Slice) -> ArrayView<'_, A, D>\n    where\n        S: Data,\n    {\n        let mut view = self.view();\n        view.slice_axis_inplace(axis, indices);\n        view\n    }\n\n    /// Return a mutable view of the array, sliced along the specified axis.\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// **Panics** if `axis` is out of bounds.\n    pub fn slice_axis_mut(&mut self, axis: Axis, indices: Slice) -> ArrayViewMut<'_, A, D>\n    where\n        S: DataMut,\n    {\n        let mut view_mut = self.view_mut();\n        view_mut.slice_axis_inplace(axis, indices);\n        view_mut\n    }\n\n    /// Slice the array in place along the specified axis.\n    ///\n    /// **Panics** if an index is out of bounds or step size is zero.<br>\n    /// **Panics** if `axis` is out of bounds.\n    pub fn slice_axis_inplace(&mut self, axis: Axis, indices: Slice) {\n        let offset = do_slice(\n            &mut self.dim.slice_mut()[axis.index()],\n            &mut self.strides.slice_mut()[axis.index()],\n            indices,\n        );\n        unsafe {\n            self.ptr = self.ptr.offset(offset);\n        }\n        debug_assert!(self.pointer_is_inbounds());\n    }\n\n    /// Return a reference to the element at `index`, or return `None`\n    /// if the index is out of bounds.\n    ///\n    /// Arrays also support indexing syntax: `array[index]`.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let a = arr2(&[[1., 2.],\n    ///                [3., 4.]]);\n    ///\n    /// assert!(\n    ///     a.get((0, 1)) == Some(&2.) &&\n    ///     a.get((0, 2)) == None &&\n    ///     a[(0, 1)] == 2. &&\n    ///     a[[0, 1]] == 2.\n    /// );\n    /// ```\n    pub fn get<I>(&self, index: I) -> Option<&A>\n    where\n        I: NdIndex<D>,\n        S: Data,\n    {\n        unsafe { self.get_ptr(index).map(|ptr| &*ptr) }\n    }\n\n    pub(crate) fn get_ptr<I>(&self, index: I) -> Option<*const A>\n    where\n        I: NdIndex<D>,\n    {\n        let ptr = self.ptr;\n        index\n            .index_checked(&self.dim, &self.strides)\n            .map(move |offset| unsafe { ptr.as_ptr().offset(offset) as *const _ })\n    }\n\n    /// Return a mutable reference to the element at `index`, or return `None`\n    /// if the index is out of bounds.\n    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut A>\n    where\n        S: DataMut,\n        I: NdIndex<D>,\n    {\n        unsafe { self.get_ptr_mut(index).map(|ptr| &mut *ptr) }\n    }\n\n    pub(crate) fn get_ptr_mut<I>(&mut self, index: I) -> Option<*mut A>\n    where\n        S: RawDataMut,\n        I: NdIndex<D>,\n    {\n        // const and mut are separate to enforce &mutness as well as the\n        // extra code in as_mut_ptr\n        let ptr = self.as_mut_ptr();\n        index\n            .index_checked(&self.dim, &self.strides)\n            .map(move |offset| unsafe { ptr.offset(offset) })\n    }\n\n    /// Perform *unchecked* array indexing.\n    ///\n    /// Return a reference to the element at `index`.\n    ///\n    /// **Note:** only unchecked for non-debug builds of ndarray.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that the index is in-bounds.\n    #[inline]\n    pub unsafe fn uget<I>(&self, index: I) -> &A\n    where\n        S: Data,\n        I: NdIndex<D>,\n    {\n        arraytraits::debug_bounds_check(self, &index);\n        let off = index.index_unchecked(&self.strides);\n        &*self.ptr.as_ptr().offset(off)\n    }\n\n    /// Perform *unchecked* array indexing.\n    ///\n    /// Return a mutable reference to the element at `index`.\n    ///\n    /// **Note:** Only unchecked for non-debug builds of ndarray.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    ///\n    /// 1. the index is in-bounds and\n    ///\n    /// 2. the data is uniquely held by the array. (This property is guaranteed\n    ///    for `Array` and `ArrayViewMut`, but not for `ArcArray` or `CowArray`.)\n    #[inline]\n    pub unsafe fn uget_mut<I>(&mut self, index: I) -> &mut A\n    where\n        S: DataMut,\n        I: NdIndex<D>,\n    {\n        debug_assert!(self.data.is_unique());\n        arraytraits::debug_bounds_check(self, &index);\n        let off = index.index_unchecked(&self.strides);\n        &mut *self.ptr.as_ptr().offset(off)\n    }\n\n    /// Swap elements at indices `index1` and `index2`.\n    ///\n    /// Indices may be equal.\n    ///\n    /// ***Panics*** if an index is out of bounds.\n    pub fn swap<I>(&mut self, index1: I, index2: I)\n    where\n        S: DataMut,\n        I: NdIndex<D>,\n    {\n        let ptr1: *mut _ = &mut self[index1];\n        let ptr2: *mut _ = &mut self[index2];\n        unsafe {\n            std_ptr::swap(ptr1, ptr2);\n        }\n    }\n\n    /// Swap elements *unchecked* at indices `index1` and `index2`.\n    ///\n    /// Indices may be equal.\n    ///\n    /// **Note:** only unchecked for non-debug builds of ndarray.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    ///\n    /// 1. both `index1 and `index2` are in-bounds and\n    ///\n    /// 2. the data is uniquely held by the array. (This property is guaranteed\n    ///    for `Array` and `ArrayViewMut`, but not for `ArcArray` or `CowArray`.)\n    pub unsafe fn uswap<I>(&mut self, index1: I, index2: I)\n    where\n        S: DataMut,\n        I: NdIndex<D>,\n    {\n        debug_assert!(self.data.is_unique());\n        arraytraits::debug_bounds_check(self, &index1);\n        arraytraits::debug_bounds_check(self, &index2);\n        let off1 = index1.index_unchecked(&self.strides);\n        let off2 = index2.index_unchecked(&self.strides);\n        std_ptr::swap(\n            self.ptr.as_ptr().offset(off1),\n            self.ptr.as_ptr().offset(off2),\n        );\n    }\n\n    // `get` for zero-dimensional arrays\n    // panics if dimension is not zero. otherwise an element is always present.\n    fn get_0d(&self) -> &A\n    where\n        S: Data,\n    {\n        assert!(self.ndim() == 0);\n        unsafe { &*self.as_ptr() }\n    }\n\n    /// Returns a view restricted to `index` along the axis, with the axis\n    /// removed.\n    ///\n    /// See [*Subviews*](#subviews) for full documentation.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    ///\n    /// ```\n    /// use ndarray::{arr2, ArrayView, Axis};\n    ///\n    /// let a = arr2(&[[1., 2. ],    // ... axis 0, row 0\n    ///                [3., 4. ],    // --- axis 0, row 1\n    ///                [5., 6. ]]);  // ... axis 0, row 2\n    /// //               .   \\\n    /// //                .   axis 1, column 1\n    /// //                 axis 1, column 0\n    /// assert!(\n    ///     a.index_axis(Axis(0), 1) == ArrayView::from(&[3., 4.]) &&\n    ///     a.index_axis(Axis(1), 1) == ArrayView::from(&[2., 4., 6.])\n    /// );\n    /// ```\n    pub fn index_axis(&self, axis: Axis, index: usize) -> ArrayView<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,\n    {\n        self.view().index_axis_move(axis, index)\n    }\n\n    /// Returns a mutable view restricted to `index` along the axis, with the\n    /// axis removed.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    ///\n    /// ```\n    /// use ndarray::{arr2, aview2, Axis};\n    ///\n    /// let mut a = arr2(&[[1., 2. ],\n    ///                    [3., 4. ]]);\n    /// //                   .   \\\n    /// //                    .   axis 1, column 1\n    /// //                     axis 1, column 0\n    ///\n    /// {\n    ///     let mut column1 = a.index_axis_mut(Axis(1), 1);\n    ///     column1 += 10.;\n    /// }\n    ///\n    /// assert!(\n    ///     a == aview2(&[[1., 12.],\n    ///                   [3., 14.]])\n    /// );\n    /// ```\n    pub fn index_axis_mut(&mut self, axis: Axis, index: usize) -> ArrayViewMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,\n    {\n        self.view_mut().index_axis_move(axis, index)\n    }\n\n    /// Collapses the array to `index` along the axis and removes the axis.\n    ///\n    /// See [`.index_axis()`](#method.index_axis) and [*Subviews*](#subviews) for full documentation.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    pub fn index_axis_move(mut self, axis: Axis, index: usize) -> ArrayBase<S, D::Smaller>\n    where\n        D: RemoveAxis,\n    {\n        self.collapse_axis(axis, index);\n        let dim = self.dim.remove_axis(axis);\n        let strides = self.strides.remove_axis(axis);\n        ArrayBase {\n            ptr: self.ptr,\n            data: self.data,\n            dim,\n            strides,\n        }\n    }\n\n    /// Selects `index` along the axis, collapsing the axis into length one.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    pub fn collapse_axis(&mut self, axis: Axis, index: usize) {\n        let offset = dimension::do_collapse_axis(&mut self.dim, &self.strides, axis.index(), index);\n        self.ptr = unsafe { self.ptr.offset(offset) };\n        debug_assert!(self.pointer_is_inbounds());\n    }\n\n    /// Along `axis`, select the subview `index` and return a\n    /// view with that axis removed.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    #[deprecated(note = \"renamed to `index_axis`\", since = \"0.12.1\")]\n    pub fn subview(&self, axis: Axis, index: Ix) -> ArrayView<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,\n    {\n        self.index_axis(axis, index)\n    }\n\n    /// Along `axis`, select the subview `index` and return a read-write view\n    /// with the axis removed.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    #[deprecated(note = \"renamed to `index_axis_mut`\", since = \"0.12.1\")]\n    pub fn subview_mut(&mut self, axis: Axis, index: Ix) -> ArrayViewMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,\n    {\n        self.index_axis_mut(axis, index)\n    }\n\n    /// Collapse dimension `axis` into length one,\n    /// and select the subview of `index` along that axis.\n    ///\n    /// **Panics** if `index` is past the length of the axis.\n    #[deprecated(note = \"renamed to `collapse_axis`\", since = \"0.12.1\")]\n    pub fn subview_inplace(&mut self, axis: Axis, index: Ix) {\n        self.collapse_axis(axis, index)\n    }\n\n    /// Along `axis`, select the subview `index` and return `self`\n    /// with that axis removed.\n    #[deprecated(note = \"renamed to `index_axis_move`\", since = \"0.12.1\")]\n    pub fn into_subview(self, axis: Axis, index: Ix) -> ArrayBase<S, D::Smaller>\n    where\n        D: RemoveAxis,\n    {\n        self.index_axis_move(axis, index)\n    }\n\n    /// Along `axis`, select arbitrary subviews corresponding to `indices`\n    /// and and copy them into a new array.\n    ///\n    /// **Panics** if `axis` or an element of `indices` is out of bounds.\n    ///\n    /// ```\n    /// use ndarray::{arr2, Axis};\n    ///\n    /// let x = arr2(&[[0., 1.],\n    ///                [2., 3.],\n    ///                [4., 5.],\n    ///                [6., 7.],\n    ///                [8., 9.]]);\n    ///\n    /// let r = x.select(Axis(0), &[0, 4, 3]);\n    /// assert!(\n    ///         r == arr2(&[[0., 1.],\n    ///                     [8., 9.],\n    ///                     [6., 7.]])\n    ///);\n    /// ```\n    pub fn select(&self, axis: Axis, indices: &[Ix]) -> Array<A, D>\n    where\n        A: Copy,\n        S: Data,\n        D: RemoveAxis,\n    {\n        let mut subs = vec![self.view(); indices.len()];\n        for (&i, sub) in zip(indices, &mut subs[..]) {\n            sub.collapse_axis(axis, i);\n        }\n        if subs.is_empty() {\n            let mut dim = self.raw_dim();\n            dim.set_axis(axis, 0);\n            unsafe { Array::from_shape_vec_unchecked(dim, vec![]) }\n        } else {\n            stack(axis, &subs).unwrap()\n        }\n    }\n\n    /// Return a producer and iterable that traverses over the *generalized*\n    /// rows of the array. For a 2D array these are the regular rows.\n    ///\n    /// This is equivalent to `.lanes(Axis(n - 1))` where *n* is `self.ndim()`.\n    ///\n    /// For an array of dimensions *a*  *b*  *c*  ...  *l*  *m*\n    /// it has *a*  *b*  *c*  ...  *l* rows each of length *m*.\n    ///\n    /// For example, in a 2  2  3 array, each row is 3 elements long\n    /// and there are 2  2 = 4 rows in total.\n    ///\n    /// Iterator element is `ArrayView1<A>` (1D array view).\n    ///\n    /// ```\n    /// use ndarray::{arr3, Axis, arr1};\n    ///\n    /// let a = arr3(&[[[ 0,  1,  2],    // -- row 0, 0\n    ///                 [ 3,  4,  5]],   // -- row 0, 1\n    ///                [[ 6,  7,  8],    // -- row 1, 0\n    ///                 [ 9, 10, 11]]]); // -- row 1, 1\n    ///\n    /// // `genrows` will yield the four generalized rows of the array.\n    /// for row in a.genrows() {\n    ///     /* loop body */\n    /// }\n    /// ```\n    pub fn genrows(&self) -> Lanes<'_, A, D::Smaller>\n    where\n        S: Data,\n    {\n        let mut n = self.ndim();\n        if n == 0 {\n            n += 1;\n        }\n        Lanes::new(self.view(), Axis(n - 1))\n    }\n\n    /// Return a producer and iterable that traverses over the *generalized*\n    /// rows of the array and yields mutable array views.\n    ///\n    /// Iterator element is `ArrayView1<A>` (1D read-write array view).\n    pub fn genrows_mut(&mut self) -> LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n    {\n        let mut n = self.ndim();\n        if n == 0 {\n            n += 1;\n        }\n        LanesMut::new(self.view_mut(), Axis(n - 1))\n    }\n\n    /// Return a producer and iterable that traverses over the *generalized*\n    /// columns of the array. For a 2D array these are the regular columns.\n    ///\n    /// This is equivalent to `.lanes(Axis(0))`.\n    ///\n    /// For an array of dimensions *a*  *b*  *c*  ...  *l*  *m*\n    /// it has *b*  *c*  ...  *l*  *m* columns each of length *a*.\n    ///\n    /// For example, in a 2  2  3 array, each column is 2 elements long\n    /// and there are 2  3 = 6 columns in total.\n    ///\n    /// Iterator element is `ArrayView1<A>` (1D array view).\n    ///\n    /// ```\n    /// use ndarray::{arr3, Axis, arr1};\n    ///\n    /// // The generalized columns of a 3D array:\n    /// // are directed along the 0th axis: 0 and 6, 1 and 7 and so on...\n    /// let a = arr3(&[[[ 0,  1,  2], [ 3,  4,  5]],\n    ///                [[ 6,  7,  8], [ 9, 10, 11]]]);\n    ///\n    /// // Here `gencolumns` will yield the six generalized columns of the array.\n    /// for row in a.gencolumns() {\n    ///     /* loop body */\n    /// }\n    /// ```\n    pub fn gencolumns(&self) -> Lanes<'_, A, D::Smaller>\n    where\n        S: Data,\n    {\n        Lanes::new(self.view(), Axis(0))\n    }\n\n    /// Return a producer and iterable that traverses over the *generalized*\n    /// columns of the array and yields mutable array views.\n    ///\n    /// Iterator element is `ArrayView1<A>` (1D read-write array view).\n    pub fn gencolumns_mut(&mut self) -> LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n    {\n        LanesMut::new(self.view_mut(), Axis(0))\n    }\n\n    /// Return a producer and iterable that traverses over all 1D lanes\n    /// pointing in the direction of `axis`.\n    ///\n    /// When the pointing in the direction of the first axis, they are *columns*,\n    /// in the direction of the last axis *rows*; in general they are all\n    /// *lanes* and are one dimensional.\n    ///\n    /// Iterator element is `ArrayView1<A>` (1D array view).\n    ///\n    /// ```\n    /// use ndarray::{arr3, aview1, Axis};\n    ///\n    /// let a = arr3(&[[[ 0,  1,  2],\n    ///                 [ 3,  4,  5]],\n    ///                [[ 6,  7,  8],\n    ///                 [ 9, 10, 11]]]);\n    ///\n    /// let inner0 = a.lanes(Axis(0));\n    /// let inner1 = a.lanes(Axis(1));\n    /// let inner2 = a.lanes(Axis(2));\n    ///\n    /// // The first lane for axis 0 is [0, 6]\n    /// assert_eq!(inner0.into_iter().next().unwrap(), aview1(&[0, 6]));\n    /// // The first lane for axis 1 is [0, 3]\n    /// assert_eq!(inner1.into_iter().next().unwrap(), aview1(&[0, 3]));\n    /// // The first lane for axis 2 is [0, 1, 2]\n    /// assert_eq!(inner2.into_iter().next().unwrap(), aview1(&[0, 1, 2]));\n    /// ```\n    pub fn lanes(&self, axis: Axis) -> Lanes<'_, A, D::Smaller>\n    where\n        S: Data,\n    {\n        Lanes::new(self.view(), axis)\n    }\n\n    /// Return a producer and iterable that traverses over all 1D lanes\n    /// pointing in the direction of `axis`.\n    ///\n    /// Iterator element is `ArrayViewMut1<A>` (1D read-write array view).\n    pub fn lanes_mut(&mut self, axis: Axis) -> LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n    {\n        LanesMut::new(self.view_mut(), axis)\n    }\n\n    /// Return an iterator that traverses over the outermost dimension\n    /// and yields each subview.\n    ///\n    /// This is equivalent to `.axis_iter(Axis(0))`.\n    ///\n    /// Iterator element is `ArrayView<A, D::Smaller>` (read-only array view).\n    #[allow(deprecated)]\n    pub fn outer_iter(&self) -> AxisIter<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,\n    {\n        self.view().into_outer_iter()\n    }\n\n    /// Return an iterator that traverses over the outermost dimension\n    /// and yields each subview.\n    ///\n    /// This is equivalent to `.axis_iter_mut(Axis(0))`.\n    ///\n    /// Iterator element is `ArrayViewMut<A, D::Smaller>` (read-write array view).\n    #[allow(deprecated)]\n    pub fn outer_iter_mut(&mut self) -> AxisIterMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,\n    {\n        self.view_mut().into_outer_iter()\n    }\n\n    /// Return an iterator that traverses over `axis`\n    /// and yields each subview along it.\n    ///\n    /// For example, in a 3  4  5 array, with `axis` equal to `Axis(2)`,\n    /// the iterator element\n    /// is a 3  4 subview (and there are 5 in total), as shown\n    /// in the picture below.\n    ///\n    /// Iterator element is `ArrayView<A, D::Smaller>` (read-only array view).\n    ///\n    /// See [*Subviews*](#subviews) for full documentation.\n    ///\n    /// **Panics** if `axis` is out of bounds.\n    ///\n    /// <img src=\"https://rust-ndarray.github.io/ndarray/images/axis_iter_3_4_5.svg\" height=\"250px\">\n    pub fn axis_iter(&self, axis: Axis) -> AxisIter<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,\n    {\n        AxisIter::new(self.view(), axis)\n    }\n\n    /// Return an iterator that traverses over `axis`\n    /// and yields each mutable subview along it.\n    ///\n    /// Iterator element is `ArrayViewMut<A, D::Smaller>`\n    /// (read-write array view).\n    ///\n    /// **Panics** if `axis` is out of bounds.\n    pub fn axis_iter_mut(&mut self, axis: Axis) -> AxisIterMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,\n    {\n        AxisIterMut::new(self.view_mut(), axis)\n    }\n\n    /// Return an iterator that traverses over `axis` by chunks of `size`,\n    /// yielding non-overlapping views along that axis.\n    ///\n    /// Iterator element is `ArrayView<A, D>`\n    ///\n    /// The last view may have less elements if `size` does not divide\n    /// the axis' dimension.\n    ///\n    /// **Panics** if `axis` is out of bounds or if `size` is zero.\n    ///\n    /// ```\n    /// use ndarray::Array;\n    /// use ndarray::{arr3, Axis};\n    /// use std::iter::FromIterator;\n    ///\n    /// let a = Array::from_iter(0..28).into_shape((2, 7, 2)).unwrap();\n    /// let mut iter = a.axis_chunks_iter(Axis(1), 2);\n    ///\n    /// // first iteration yields a 2  2  2 view\n    /// assert_eq!(iter.next().unwrap(),\n    ///            arr3(&[[[ 0,  1], [ 2, 3]],\n    ///                   [[14, 15], [16, 17]]]));\n    ///\n    /// // however the last element is a 2  1  2 view since 7 % 2 == 1\n    /// assert_eq!(iter.next_back().unwrap(), arr3(&[[[12, 13]],\n    ///                                              [[26, 27]]]));\n    /// ```\n    pub fn axis_chunks_iter(&self, axis: Axis, size: usize) -> AxisChunksIter<'_, A, D>\n    where\n        S: Data,\n    {\n        AxisChunksIter::new(self.view(), axis, size)\n    }\n\n    /// Return an iterator that traverses over `axis` by chunks of `size`,\n    /// yielding non-overlapping read-write views along that axis.\n    ///\n    /// Iterator element is `ArrayViewMut<A, D>`\n    ///\n    /// **Panics** if `axis` is out of bounds or if `size` is zero.\n    pub fn axis_chunks_iter_mut(&mut self, axis: Axis, size: usize) -> AxisChunksIterMut<'_, A, D>\n    where\n        S: DataMut,\n    {\n        AxisChunksIterMut::new(self.view_mut(), axis, size)\n    }\n\n    /// Return an exact chunks producer (and iterable).\n    ///\n    /// It produces the whole chunks of a given n-dimensional chunk size,\n    /// skipping the remainder along each dimension that doesn't fit evenly.\n    ///\n    /// The produced element is a `ArrayView<A, D>` with exactly the dimension\n    /// `chunk_size`.\n    ///\n    /// **Panics** if any dimension of `chunk_size` is zero<br>\n    /// (**Panics** if `D` is `IxDyn` and `chunk_size` does not match the\n    /// number of array axes.)\n    pub fn exact_chunks<E>(&self, chunk_size: E) -> ExactChunks<'_, A, D>\n    where\n        E: IntoDimension<Dim = D>,\n        S: Data,\n    {\n        ExactChunks::new(self.view(), chunk_size)\n    }\n\n    /// Return an exact chunks producer (and iterable).\n    ///\n    /// It produces the whole chunks of a given n-dimensional chunk size,\n    /// skipping the remainder along each dimension that doesn't fit evenly.\n    ///\n    /// The produced element is a `ArrayViewMut<A, D>` with exactly\n    /// the dimension `chunk_size`.\n    ///\n    /// **Panics** if any dimension of `chunk_size` is zero<br>\n    /// (**Panics** if `D` is `IxDyn` and `chunk_size` does not match the\n    /// number of array axes.)\n    ///\n    /// ```rust\n    /// use ndarray::Array;\n    /// use ndarray::arr2;\n    /// let mut a = Array::zeros((6, 7));\n    ///\n    /// // Fill each 2  2 chunk with the index of where it appeared in iteration\n    /// for (i, mut chunk) in a.exact_chunks_mut((2, 2)).into_iter().enumerate() {\n    ///     chunk.fill(i);\n    /// }\n    ///\n    /// // The resulting array is:\n    /// assert_eq!(\n    ///   a,\n    ///   arr2(&[[0, 0, 1, 1, 2, 2, 0],\n    ///          [0, 0, 1, 1, 2, 2, 0],\n    ///          [3, 3, 4, 4, 5, 5, 0],\n    ///          [3, 3, 4, 4, 5, 5, 0],\n    ///          [6, 6, 7, 7, 8, 8, 0],\n    ///          [6, 6, 7, 7, 8, 8, 0]]));\n    /// ```\n    pub fn exact_chunks_mut<E>(&mut self, chunk_size: E) -> ExactChunksMut<'_, A, D>\n    where\n        E: IntoDimension<Dim = D>,\n        S: DataMut,\n    {\n        ExactChunksMut::new(self.view_mut(), chunk_size)\n    }\n\n    /// Return a window producer and iterable.\n    ///\n    /// The windows are all distinct overlapping views of size `window_size`\n    /// that fit into the array's shape.\n    ///\n    /// Will yield over no elements if window size is larger\n    /// than the actual array size of any dimension.\n    ///\n    /// The produced element is an `ArrayView<A, D>` with exactly the dimension\n    /// `window_size`.\n    ///\n    /// **Panics** if any dimension of `window_size` is zero.<br>\n    /// (**Panics** if `D` is `IxDyn` and `window_size` does not match the\n    /// number of array axes.)\n    ///\n    /// This is an illustration of the 22 windows in a 34 array:\n    ///\n    /// ```text\n    ///           Axis(1)\n    ///\n    ///               \n    ///          a  a                    a  a                    a  a \n    /// Axis(0)        \n    ///           a  a                    a  a                    a  a \n    ///                \n    ///                                                                            \n    ///                \n    ///\n    ///                \n    ///                                                                            \n    ///                \n    ///           a  a                    a  a                    a  a \n    ///                \n    ///           a  a                    a  a                    a  a \n    ///                \n    /// ```\n    pub fn windows<E>(&self, window_size: E) -> Windows<'_, A, D>\n    where\n        E: IntoDimension<Dim = D>,\n        S: Data,\n    {\n        Windows::new(self.view(), window_size)\n    }\n\n    // Return (length, stride) for diagonal\n    fn diag_params(&self) -> (Ix, Ixs) {\n        /* empty shape has len 1 */\n        let len = self.dim.slice().iter().cloned().min().unwrap_or(1);\n        let stride = self.strides().iter().sum();\n        (len, stride)\n    }\n\n    /// Return an view of the diagonal elements of the array.\n    ///\n    /// The diagonal is simply the sequence indexed by *(0, 0, .., 0)*,\n    /// *(1, 1, ..., 1)* etc as long as all axes have elements.\n    pub fn diag(&self) -> ArrayView1<'_, A>\n    where\n        S: Data,\n    {\n        self.view().into_diag()\n    }\n\n    /// Return a read-write view over the diagonal elements of the array.\n    pub fn diag_mut(&mut self) -> ArrayViewMut1<'_, A>\n    where\n        S: DataMut,\n    {\n        self.view_mut().into_diag()\n    }\n\n    /// Return the diagonal as a one-dimensional array.\n    pub fn into_diag(self) -> ArrayBase<S, Ix1> {\n        let (len, stride) = self.diag_params();\n        ArrayBase {\n            data: self.data,\n            ptr: self.ptr,\n            dim: Ix1(len),\n            strides: Ix1(stride as Ix),\n        }\n    }\n\n    /// Try to make the array unshared.\n    ///\n    /// This is equivalent to `.ensure_unique()` if `S: DataMut`.\n    ///\n    /// This method is mostly only useful with unsafe code.\n    fn try_ensure_unique(&mut self)\n    where\n        S: RawDataMut,\n    {\n        debug_assert!(self.pointer_is_inbounds());\n        S::try_ensure_unique(self);\n        debug_assert!(self.pointer_is_inbounds());\n    }\n\n    /// Make the array unshared.\n    ///\n    /// This method is mostly only useful with unsafe code.\n    fn ensure_unique(&mut self)\n    where\n        S: DataMut,\n    {\n        debug_assert!(self.pointer_is_inbounds());\n        S::ensure_unique(self);\n        debug_assert!(self.pointer_is_inbounds());\n    }\n\n    /// Return `true` if the array data is laid out in contiguous C order in\n    /// memory (where the last index is the most rapidly varying).\n    ///\n    /// Return `false` otherwise, i.e the array is possibly not\n    /// contiguous in memory, it has custom strides, etc.\n    pub fn is_standard_layout(&self) -> bool {\n        fn is_standard_layout<D: Dimension>(dim: &D, strides: &D) -> bool {\n            if let Some(1) = D::NDIM {\n                return strides[0] == 1 || dim[0] <= 1;\n            }\n            if dim.slice().iter().any(|&d| d == 0) {\n                return true;\n            }\n            let defaults = dim.default_strides();\n            // check all dimensions -- a dimension of length 1 can have unequal strides\n            for (&dim, &s, &ds) in izip!(dim.slice(), strides.slice(), defaults.slice()) {\n                if dim != 1 && s != ds {\n                    return false;\n                }\n            }\n            true\n        }\n        is_standard_layout(&self.dim, &self.strides)\n    }\n\n    fn is_contiguous(&self) -> bool {\n        D::is_contiguous(&self.dim, &self.strides)\n    }\n\n    /// Return a standard-layout array containing the data, cloning if\n    /// necessary.\n    ///\n    /// If `self` is in standard layout, a COW view of the data is returned\n    /// without cloning. Otherwise, the data is cloned, and the returned array\n    /// owns the cloned data.\n    ///\n    /// ```\n    /// use ndarray::Array2;\n    ///\n    /// let standard = Array2::<f64>::zeros((3, 4));\n    /// assert!(standard.is_standard_layout());\n    /// let cow_view = standard.as_standard_layout();\n    /// assert!(cow_view.is_view());\n    /// assert!(cow_view.is_standard_layout());\n    ///\n    /// let fortran = standard.reversed_axes();\n    /// assert!(!fortran.is_standard_layout());\n    /// let cow_owned = fortran.as_standard_layout();\n    /// assert!(cow_owned.is_owned());\n    /// assert!(cow_owned.is_standard_layout());\n    /// ```\n    pub fn as_standard_layout(&self) -> CowArray<'_, A, D>\n    where\n        S: Data<Elem = A>,\n        A: Clone,\n    {\n        if self.is_standard_layout() {\n            CowArray::from(self.view())\n        } else {\n            let v: Vec<A> = self.iter().cloned().collect();\n            let dim = self.dim.clone();\n            assert_eq!(v.len(), dim.size());\n            let owned_array: Array<A, D> = unsafe {\n                // Safe because the shape and element type are from the existing array\n                // and the strides are the default strides.\n                Array::from_shape_vec_unchecked(dim, v)\n            };\n            CowArray::from(owned_array)\n        }\n    }\n\n    /// Return a pointer to the first element in the array.\n    ///\n    /// Raw access to array elements needs to follow the strided indexing\n    /// scheme: an element at multi-index *I* in an array with strides *S* is\n    /// located at offset\n    ///\n    /// *<sub>0  k < d</sub> I<sub>k</sub>  S<sub>k</sub>*\n    ///\n    /// where *d* is `self.ndim()`.\n    #[inline(always)]\n    pub fn as_ptr(&self) -> *const A {\n        self.ptr.as_ptr() as *const A\n    }\n\n    /// Return a mutable pointer to the first element in the array.\n    #[inline(always)]\n    pub fn as_mut_ptr(&mut self) -> *mut A\n    where\n        S: RawDataMut,\n    {\n        self.try_ensure_unique(); // for RcArray\n        self.ptr.as_ptr()\n    }\n\n    /// Return a raw view of the array.\n    #[inline]\n    pub fn raw_view(&self) -> RawArrayView<A, D> {\n        unsafe { RawArrayView::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }\n\n    /// Return a raw mutable view of the array.\n    #[inline]\n    pub fn raw_view_mut(&mut self) -> RawArrayViewMut<A, D>\n    where\n        S: RawDataMut,\n    {\n        self.try_ensure_unique(); // for RcArray\n        unsafe { RawArrayViewMut::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }\n\n    /// Return the arrays data as a slice, if it is contiguous and in standard order.\n    /// Return `None` otherwise.\n    ///\n    /// If this function returns `Some(_)`, then the element order in the slice\n    /// corresponds to the logical order of the arrays elements.\n    pub fn as_slice(&self) -> Option<&[A]>\n    where\n        S: Data,\n    {\n        if self.is_standard_layout() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }\n\n    /// Return the arrays data as a slice, if it is contiguous and in standard order.\n    /// Return `None` otherwise.\n    pub fn as_slice_mut(&mut self) -> Option<&mut [A]>\n    where\n        S: DataMut,\n    {\n        if self.is_standard_layout() {\n            self.ensure_unique();\n            unsafe { Some(slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }\n\n    /// Return the arrays data as a slice if it is contiguous,\n    /// return `None` otherwise.\n    ///\n    /// If this function returns `Some(_)`, then the elements in the slice\n    /// have whatever order the elements have in memory.\n    ///\n    /// Implementation notes: Does not yet support negatively strided arrays.\n    pub fn as_slice_memory_order(&self) -> Option<&[A]>\n    where\n        S: Data,\n    {\n        if self.is_contiguous() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }\n\n    /// Return the arrays data as a slice if it is contiguous,\n    /// return `None` otherwise.\n    pub fn as_slice_memory_order_mut(&mut self) -> Option<&mut [A]>\n    where\n        S: DataMut,\n    {\n        if self.is_contiguous() {\n            self.ensure_unique();\n            unsafe { Some(slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }\n\n    /// Transform the array into `shape`; any shape with the same number of\n    /// elements is accepted, but the source array or view must be in standard\n    /// or column-major (Fortran) layout.\n    ///\n    /// **Errors** if the shapes don't have the same number of elements.<br>\n    /// **Errors** if the input array is not c- or f-contiguous.\n    ///\n    /// ```\n    /// use ndarray::{aview1, aview2};\n    ///\n    /// assert!(\n    ///     aview1(&[1., 2., 3., 4.]).into_shape((2, 2)).unwrap()\n    ///     == aview2(&[[1., 2.],\n    ///                 [3., 4.]])\n    /// );\n    /// ```\n    pub fn into_shape<E>(self, shape: E) -> Result<ArrayBase<S, E::Dim>, ShapeError>\n    where\n        E: IntoDimension,\n    {\n        let shape = shape.into_dimension();\n        if size_of_shape_checked(&shape) != Ok(self.dim.size()) {\n            return Err(error::incompatible_shapes(&self.dim, &shape));\n        }\n        // Check if contiguous, if not => copy all, else just adapt strides\n        if self.is_standard_layout() {\n            Ok(ArrayBase {\n                data: self.data,\n                ptr: self.ptr,\n                strides: shape.default_strides(),\n                dim: shape,\n            })\n        } else if self.ndim() > 1 && self.raw_view().reversed_axes().is_standard_layout() {\n            Ok(ArrayBase {\n                data: self.data,\n                ptr: self.ptr,\n                strides: shape.fortran_strides(),\n                dim: shape,\n            })\n        } else {\n            Err(error::from_kind(error::ErrorKind::IncompatibleLayout))\n        }\n    }\n\n    /// *Note: Reshape is for `ArcArray` only. Use `.into_shape()` for\n    /// other arrays and array views.*\n    ///\n    /// Transform the array into `shape`; any shape with the same number of\n    /// elements is accepted.\n    ///\n    /// May clone all elements if needed to arrange elements in standard\n    /// layout (and break sharing).\n    ///\n    /// **Panics** if shapes are incompatible.\n    ///\n    /// ```\n    /// use ndarray::{rcarr1, rcarr2};\n    ///\n    /// assert!(\n    ///     rcarr1(&[1., 2., 3., 4.]).reshape((2, 2))\n    ///     == rcarr2(&[[1., 2.],\n    ///                 [3., 4.]])\n    /// );\n    /// ```\n    pub fn reshape<E>(&self, shape: E) -> ArrayBase<S, E::Dim>\n    where\n        S: DataShared + DataOwned,\n        A: Clone,\n        E: IntoDimension,\n    {\n        let shape = shape.into_dimension();\n        if size_of_shape_checked(&shape) != Ok(self.dim.size()) {\n            panic!(\n                \"ndarray: incompatible shapes in reshape, attempted from: {:?}, to: {:?}\",\n                self.dim.slice(),\n                shape.slice()\n            )\n        }\n        // Check if contiguous, if not => copy all, else just adapt strides\n        if self.is_standard_layout() {\n            let cl = self.clone();\n            ArrayBase {\n                data: cl.data,\n                ptr: cl.ptr,\n                strides: shape.default_strides(),\n                dim: shape,\n            }\n        } else {\n            let v = self.iter().cloned().collect::<Vec<A>>();\n            unsafe { ArrayBase::from_shape_vec_unchecked(shape, v) }\n        }\n    }\n\n    /// Convert any array or array view to a dynamic dimensional array or\n    /// array view (respectively).\n    ///\n    /// ```\n    /// use ndarray::{arr2, ArrayD};\n    ///\n    /// let array: ArrayD<i32> = arr2(&[[1, 2],\n    ///                                 [3, 4]]).into_dyn();\n    /// ```\n    pub fn into_dyn(self) -> ArrayBase<S, IxDyn> {\n        ArrayBase {\n            data: self.data,\n            ptr: self.ptr,\n            dim: self.dim.into_dyn(),\n            strides: self.strides.into_dyn(),\n        }\n    }\n\n    /// Convert an array or array view to another with the same type, but\n    /// different dimensionality type. Errors if the dimensions don't agree.\n    ///\n    /// ```\n    /// use ndarray::{ArrayD, Ix2, IxDyn};\n    ///\n    /// // Create a dynamic dimensionality array and convert it to an Array2\n    /// // (Ix2 dimension type).\n    ///\n    /// let array = ArrayD::<f64>::zeros(IxDyn(&[10, 10]));\n    ///\n    /// assert!(array.into_dimensionality::<Ix2>().is_ok());\n    /// ```\n    pub fn into_dimensionality<D2>(self) -> Result<ArrayBase<S, D2>, ShapeError>\n    where\n        D2: Dimension,\n    {\n        if let Some(dim) = D2::from_dimension(&self.dim) {\n            if let Some(strides) = D2::from_dimension(&self.strides) {\n                return Ok(ArrayBase {\n                    data: self.data,\n                    ptr: self.ptr,\n                    dim,\n                    strides,\n                });\n            }\n        }\n        Err(ShapeError::from_kind(ErrorKind::IncompatibleShape))\n    }\n\n    /// Act like a larger size and/or shape array by *broadcasting*\n    /// into a larger shape, if possible.\n    ///\n    /// Return `None` if shapes can not be broadcast together.\n    ///\n    /// ***Background***\n    ///\n    ///  * Two axes are compatible if they are equal, or one of them is 1.\n    ///  * In this instance, only the axes of the smaller side (self) can be 1.\n    ///\n    /// Compare axes beginning with the *last* axis of each shape.\n    ///\n    /// For example (1, 2, 4) can be broadcast into (7, 6, 2, 4)\n    /// because its axes are either equal or 1 (or missing);\n    /// while (2, 2) can *not* be broadcast into (2, 4).\n    ///\n    /// The implementation creates a view with strides set to zero for the\n    /// axes that are to be repeated.\n    ///\n    /// The broadcasting documentation for Numpy has more information.\n    ///\n    /// ```\n    /// use ndarray::{aview1, aview2};\n    ///\n    /// assert!(\n    ///     aview1(&[1., 0.]).broadcast((10, 2)).unwrap()\n    ///     == aview2(&[[1., 0.]; 10])\n    /// );\n    /// ```\n    pub fn broadcast<E>(&self, dim: E) -> Option<ArrayView<'_, A, E::Dim>>\n    where\n        E: IntoDimension,\n        S: Data,\n    {\n        /// Return new stride when trying to grow `from` into shape `to`\n        ///\n        /// Broadcasting works by returning a \"fake stride\" where elements\n        /// to repeat are in axes with 0 stride, so that several indexes point\n        /// to the same element.\n        ///\n        /// **Note:** Cannot be used for mutable iterators, since repeating\n        /// elements would create aliasing pointers.\n        fn upcast<D: Dimension, E: Dimension>(to: &D, from: &E, stride: &E) -> Option<D> {\n            // Make sure the product of non-zero axis lengths does not exceed\n            // `isize::MAX`. This is the only safety check we need to perform\n            // because all the other constraints of `ArrayBase` are guaranteed\n            // to be met since we're starting from a valid `ArrayBase`.\n            let _ = size_of_shape_checked(to).ok()?;\n\n            let mut new_stride = to.clone();\n            // begin at the back (the least significant dimension)\n            // size of the axis has to either agree or `from` has to be 1\n            if to.ndim() < from.ndim() {\n                return None;\n            }\n\n            {\n                let mut new_stride_iter = new_stride.slice_mut().iter_mut().rev();\n                for ((er, es), dr) in from\n                    .slice()\n                    .iter()\n                    .rev()\n                    .zip(stride.slice().iter().rev())\n                    .zip(new_stride_iter.by_ref())\n                {\n                    /* update strides */\n                    if *dr == *er {\n                        /* keep stride */\n                        *dr = *es;\n                    } else if *er == 1 {\n                        /* dead dimension, zero stride */\n                        *dr = 0\n                    } else {\n                        return None;\n                    }\n                }\n\n                /* set remaining strides to zero */\n                for dr in new_stride_iter {\n                    *dr = 0;\n                }\n            }\n            Some(new_stride)\n        }\n        let dim = dim.into_dimension();\n\n        // Note: zero strides are safe precisely because we return an read-only view\n        let broadcast_strides = match upcast(&dim, &self.dim, &self.strides) {\n            Some(st) => st,\n            None => return None,\n        };\n        unsafe { Some(ArrayView::new(self.ptr, dim, broadcast_strides)) }\n    }\n\n    /// Swap axes `ax` and `bx`.\n    ///\n    /// This does not move any data, it just adjusts the arrays dimensions\n    /// and strides.\n    ///\n    /// **Panics** if the axes are out of bounds.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let mut a = arr2(&[[1., 2., 3.]]);\n    /// a.swap_axes(0, 1);\n    /// assert!(\n    ///     a == arr2(&[[1.], [2.], [3.]])\n    /// );\n    /// ```\n    pub fn swap_axes(&mut self, ax: usize, bx: usize) {\n        self.dim.slice_mut().swap(ax, bx);\n        self.strides.slice_mut().swap(ax, bx);\n    }\n\n    /// Permute the axes.\n    ///\n    /// This does not move any data, it just adjusts the arrays dimensions\n    /// and strides.\n    ///\n    /// *i* in the *j*-th place in the axes sequence means `self`'s *i*-th axis\n    /// becomes `self.permuted_axes()`'s *j*-th axis\n    ///\n    /// **Panics** if any of the axes are out of bounds, if an axis is missing,\n    /// or if an axis is repeated more than once.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use ndarray::{arr2, Array3};\n    ///\n    /// let a = arr2(&[[0, 1], [2, 3]]);\n    /// assert_eq!(a.view().permuted_axes([1, 0]), a.t());\n    ///\n    /// let b = Array3::<u8>::zeros((1, 2, 3));\n    /// assert_eq!(b.permuted_axes([1, 0, 2]).shape(), &[2, 1, 3]);\n    /// ```\n    pub fn permuted_axes<T>(self, axes: T) -> ArrayBase<S, D>\n    where\n        T: IntoDimension<Dim = D>,\n    {\n        let axes = axes.into_dimension();\n        // Ensure that each axis is used exactly once.\n        let mut usage_counts = D::zeros(self.ndim());\n        for axis in axes.slice() {\n            usage_counts[*axis] += 1;\n        }\n        for count in usage_counts.slice() {\n            assert_eq!(*count, 1, \"each axis must be listed exactly once\");\n        }\n        // Determine the new shape and strides.\n        let mut new_dim = usage_counts; // reuse to avoid an allocation\n        let mut new_strides = D::zeros(self.ndim());\n        {\n            let dim = self.dim.slice();\n            let strides = self.strides.slice();\n            for (new_axis, &axis) in axes.slice().iter().enumerate() {\n                new_dim[new_axis] = dim[axis];\n                new_strides[new_axis] = strides[axis];\n            }\n        }\n        ArrayBase {\n            dim: new_dim,\n            strides: new_strides,\n            ..self\n        }\n    }\n\n    /// Transpose the array by reversing axes.\n    ///\n    /// Transposition reverses the order of the axes (dimensions and strides)\n    /// while retaining the same data.\n    pub fn reversed_axes(mut self) -> ArrayBase<S, D> {\n        self.dim.slice_mut().reverse();\n        self.strides.slice_mut().reverse();\n        self\n    }\n\n    /// Return a transposed view of the array.\n    ///\n    /// This is a shorthand for `self.view().reversed_axes()`.\n    ///\n    /// See also the more general methods `.reversed_axes()` and `.swap_axes()`.\n    pub fn t(&self) -> ArrayView<'_, A, D>\n    where\n        S: Data,\n    {\n        self.view().reversed_axes()\n    }\n\n    /// Return an iterator over the length and stride of each axis.\n    pub fn axes(&self) -> Axes<'_, D> {\n        axes_of(&self.dim, &self.strides)\n    }\n\n    /*\n    /// Return the axis with the least stride (by absolute value)\n    pub fn min_stride_axis(&self) -> Axis {\n        self.dim.min_stride_axis(&self.strides)\n    }\n    */\n\n    /// Return the axis with the greatest stride (by absolute value),\n    /// preferring axes with len > 1.\n    pub fn max_stride_axis(&self) -> Axis {\n        self.dim.max_stride_axis(&self.strides)\n    }\n\n    /// Reverse the stride of `axis`.\n    ///\n    /// ***Panics*** if the axis is out of bounds.\n    pub fn invert_axis(&mut self, axis: Axis) {\n        unsafe {\n            let s = self.strides.axis(axis) as Ixs;\n            let m = self.dim.axis(axis);\n            if m != 0 {\n                self.ptr = self.ptr.offset(stride_offset(m - 1, s as Ix));\n            }\n            self.strides.set_axis(axis, (-s) as Ix);\n        }\n    }\n\n    /// If possible, merge in the axis `take` to `into`.\n    ///\n    /// Returns `true` iff the axes are now merged.\n    ///\n    /// This method merges the axes if movement along the two original axes\n    /// (moving fastest along the `into` axis) can be equivalently represented\n    /// as movement along one (merged) axis. Merging the axes preserves this\n    /// order in the merged axis. If `take` and `into` are the same axis, then\n    /// the axis is \"merged\" if its length is  1.\n    ///\n    /// If the return value is `true`, then the following hold:\n    ///\n    /// * The new length of the `into` axis is the product of the original\n    ///   lengths of the two axes.\n    ///\n    /// * The new length of the `take` axis is 0 if the product of the original\n    ///   lengths of the two axes is 0, and 1 otherwise.\n    ///\n    /// If the return value is `false`, then merging is not possible, and the\n    /// original shape and strides have been preserved.\n    ///\n    /// Note that the ordering constraint means that if it's possible to merge\n    /// `take` into `into`, it's usually not possible to merge `into` into\n    /// `take`, and vice versa.\n    ///\n    /// ```\n    /// use ndarray::Array3;\n    /// use ndarray::Axis;\n    ///\n    /// let mut a = Array3::<f64>::zeros((2, 3, 4));\n    /// assert!(a.merge_axes(Axis(1), Axis(2)));\n    /// assert_eq!(a.shape(), &[2, 1, 12]);\n    /// ```\n    ///\n    /// ***Panics*** if an axis is out of bounds.\n    pub fn merge_axes(&mut self, take: Axis, into: Axis) -> bool {\n        merge_axes(&mut self.dim, &mut self.strides, take, into)\n    }\n\n    /// Insert new array axis at `axis` and return the result.\n    ///\n    /// ```\n    /// use ndarray::{Array3, Axis, arr1, arr2};\n    ///\n    /// // Convert a 1-D array into a row vector (2-D).\n    /// let a = arr1(&[1, 2, 3]);\n    /// let row = a.insert_axis(Axis(0));\n    /// assert_eq!(row, arr2(&[[1, 2, 3]]));\n    ///\n    /// // Convert a 1-D array into a column vector (2-D).\n    /// let b = arr1(&[1, 2, 3]);\n    /// let col = b.insert_axis(Axis(1));\n    /// assert_eq!(col, arr2(&[[1], [2], [3]]));\n    ///\n    /// // The new axis always has length 1.\n    /// let b = Array3::<f64>::zeros((3, 4, 5));\n    /// assert_eq!(b.insert_axis(Axis(2)).shape(), &[3, 4, 1, 5]);\n    /// ```\n    ///\n    /// ***Panics*** if the axis is out of bounds.\n    pub fn insert_axis(self, axis: Axis) -> ArrayBase<S, D::Larger> {\n        assert!(axis.index() <= self.ndim());\n        let ArrayBase {\n            ptr,\n            data,\n            dim,\n            strides,\n        } = self;\n        ArrayBase {\n            ptr,\n            data,\n            dim: dim.insert_axis(axis),\n            strides: strides.insert_axis(axis),\n        }\n    }\n\n    /// Remove array axis `axis` and return the result.\n    ///\n    /// **Panics** if the axis is out of bounds or its length is zero.\n    #[deprecated(note = \"use `.index_axis_move(Axis(_), 0)` instead\", since = \"0.12.1\")]\n    pub fn remove_axis(self, axis: Axis) -> ArrayBase<S, D::Smaller>\n    where\n        D: RemoveAxis,\n    {\n        self.index_axis_move(axis, 0)\n    }\n\n    fn pointer_is_inbounds(&self) -> bool {\n        match self.data._data_slice() {\n            None => {\n                // special case for non-owned views\n                true\n            }\n            Some(slc) => {\n                let ptr = slc.as_ptr() as *mut A;\n                let end = unsafe { ptr.add(slc.len()) };\n                self.ptr.as_ptr() >= ptr && self.ptr.as_ptr() <= end\n            }\n        }\n    }\n\n    /// Perform an elementwise assigment to `self` from `rhs`.\n    ///\n    /// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n    ///\n    /// **Panics** if broadcasting isnt possible.\n    pub fn assign<E: Dimension, S2>(&mut self, rhs: &ArrayBase<S2, E>)\n    where\n        S: DataMut,\n        A: Clone,\n        S2: Data<Elem = A>,\n    {\n        self.zip_mut_with(rhs, |x, y| *x = y.clone());\n    }\n\n    /// Perform an elementwise assigment to `self` from element `x`.\n    pub fn fill(&mut self, x: A)\n    where\n        S: DataMut,\n        A: Clone,\n    {\n        self.unordered_foreach_mut(move |elt| *elt = x.clone());\n    }\n\n    fn zip_mut_with_same_shape<B, S2, E, F>(&mut self, rhs: &ArrayBase<S2, E>, mut f: F)\n    where\n        S: DataMut,\n        S2: Data<Elem = B>,\n        E: Dimension,\n        F: FnMut(&mut A, &B),\n    {\n        debug_assert_eq!(self.shape(), rhs.shape());\n\n        if self.dim.strides_equivalent(&self.strides, &rhs.strides) {\n            if let Some(self_s) = self.as_slice_memory_order_mut() {\n                if let Some(rhs_s) = rhs.as_slice_memory_order() {\n                    for (s, r) in self_s.iter_mut().zip(rhs_s) {\n                        f(s, &r);\n                    }\n                    return;\n                }\n            }\n        }\n\n        // Otherwise, fall back to the outer iter\n        self.zip_mut_with_by_rows(rhs, f);\n    }\n\n    // zip two arrays where they have different layout or strides\n    #[inline(always)]\n    fn zip_mut_with_by_rows<B, S2, E, F>(&mut self, rhs: &ArrayBase<S2, E>, mut f: F)\n    where\n        S: DataMut,\n        S2: Data<Elem = B>,\n        E: Dimension,\n        F: FnMut(&mut A, &B),\n    {\n        debug_assert_eq!(self.shape(), rhs.shape());\n        debug_assert_ne!(self.ndim(), 0);\n\n        // break the arrays up into their inner rows\n        let n = self.ndim();\n        let dim = self.raw_dim();\n        Zip::from(LanesMut::new(self.view_mut(), Axis(n - 1)))\n            .and(Lanes::new(rhs.broadcast_assume(dim), Axis(n - 1)))\n            .apply(move |s_row, r_row| Zip::from(s_row).and(r_row).apply(|a, b| f(a, b)));\n    }\n\n    fn zip_mut_with_elem<B, F>(&mut self, rhs_elem: &B, mut f: F)\n    where\n        S: DataMut,\n        F: FnMut(&mut A, &B),\n    {\n        self.unordered_foreach_mut(move |elt| f(elt, rhs_elem));\n    }\n\n    /// Traverse two arrays in unspecified order, in lock step,\n    /// calling the closure `f` on each element pair.\n    ///\n    /// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n    ///\n    /// **Panics** if broadcasting isnt possible.\n    #[inline]\n    pub fn zip_mut_with<B, S2, E, F>(&mut self, rhs: &ArrayBase<S2, E>, f: F)\n    where\n        S: DataMut,\n        S2: Data<Elem = B>,\n        E: Dimension,\n        F: FnMut(&mut A, &B),\n    {\n        if rhs.dim.ndim() == 0 {\n            // Skip broadcast from 0-dim array\n            self.zip_mut_with_elem(rhs.get_0d(), f);\n        } else if self.dim.ndim() == rhs.dim.ndim() && self.shape() == rhs.shape() {\n            self.zip_mut_with_same_shape(rhs, f);\n        } else {\n            let rhs_broadcast = rhs.broadcast_unwrap(self.raw_dim());\n            self.zip_mut_with_by_rows(&rhs_broadcast, f);\n        }\n    }\n\n    /// Traverse the array elements and apply a fold,\n    /// returning the resulting value.\n    ///\n    /// Elements are visited in arbitrary order.\n    pub fn fold<'a, F, B>(&'a self, init: B, f: F) -> B\n    where\n        F: FnMut(B, &'a A) -> B,\n        A: 'a,\n        S: Data,\n    {\n        if let Some(slc) = self.as_slice_memory_order() {\n            slc.iter().fold(init, f)\n        } else {\n            let mut v = self.view();\n            // put the narrowest axis at the last position\n            match v.ndim() {\n                0 | 1 => {}\n                2 => {\n                    if self.len_of(Axis(1)) <= 1\n                        || self.len_of(Axis(0)) > 1\n                            && self.stride_of(Axis(0)).abs() < self.stride_of(Axis(1)).abs()\n                    {\n                        v.swap_axes(0, 1);\n                    }\n                }\n                n => {\n                    let last = n - 1;\n                    let narrow_axis = v\n                        .axes()\n                        .filter(|ax| ax.len() > 1)\n                        .min_by_key(|ax| ax.stride().abs())\n                        .map_or(last, |ax| ax.axis().index());\n                    v.swap_axes(last, narrow_axis);\n                }\n            }\n            v.into_elements_base().fold(init, f)\n        }\n    }\n\n    /// Call `f` by reference on each element and create a new array\n    /// with the new values.\n    ///\n    /// Elements are visited in arbitrary order.\n    ///\n    /// Return an array with the same shape as `self`.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let a = arr2(&[[ 0., 1.],\n    ///                [-1., 2.]]);\n    /// assert!(\n    ///     a.map(|x| *x >= 1.0)\n    ///     == arr2(&[[false, true],\n    ///               [false, true]])\n    /// );\n    /// ```\n    pub fn map<'a, B, F>(&'a self, f: F) -> Array<B, D>\n    where\n        F: FnMut(&'a A) -> B,\n        A: 'a,\n        S: Data,\n    {\n        if let Some(slc) = self.as_slice_memory_order() {\n            let v = crate::iterators::to_vec_mapped(slc.iter(), f);\n            unsafe {\n                ArrayBase::from_shape_vec_unchecked(\n                    self.dim.clone().strides(self.strides.clone()),\n                    v,\n                )\n            }\n        } else {\n            let v = crate::iterators::to_vec_mapped(self.iter(), f);\n            unsafe { ArrayBase::from_shape_vec_unchecked(self.dim.clone(), v) }\n        }\n    }\n\n    /// Call `f` on a mutable reference of each element and create a new array\n    /// with the new values.\n    ///\n    /// Elements are visited in arbitrary order.\n    ///\n    /// Return an array with the same shape as `self`.\n    pub fn map_mut<'a, B, F>(&'a mut self, f: F) -> Array<B, D>\n    where\n        F: FnMut(&'a mut A) -> B,\n        A: 'a,\n        S: DataMut,\n    {\n        let dim = self.dim.clone();\n        if self.is_contiguous() {\n            let strides = self.strides.clone();\n            let slc = self.as_slice_memory_order_mut().unwrap();\n            let v = crate::iterators::to_vec_mapped(slc.iter_mut(), f);\n            unsafe { ArrayBase::from_shape_vec_unchecked(dim.strides(strides), v) }\n        } else {\n            let v = crate::iterators::to_vec_mapped(self.iter_mut(), f);\n            unsafe { ArrayBase::from_shape_vec_unchecked(dim, v) }\n        }\n    }\n\n    /// Call `f` by **v**alue on each element and create a new array\n    /// with the new values.\n    ///\n    /// Elements are visited in arbitrary order.\n    ///\n    /// Return an array with the same shape as `self`.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let a = arr2(&[[ 0., 1.],\n    ///                [-1., 2.]]);\n    /// assert!(\n    ///     a.mapv(f32::abs) == arr2(&[[0., 1.],\n    ///                                [1., 2.]])\n    /// );\n    /// ```\n    pub fn mapv<B, F>(&self, mut f: F) -> Array<B, D>\n    where\n        F: FnMut(A) -> B,\n        A: Clone,\n        S: Data,\n    {\n        self.map(move |x| f(x.clone()))\n    }\n\n    /// Call `f` by **v**alue on each element, update the array with the new values\n    /// and return it.\n    ///\n    /// Elements are visited in arbitrary order.\n    pub fn mapv_into<F>(mut self, f: F) -> Self\n    where\n        S: DataMut,\n        F: FnMut(A) -> A,\n        A: Clone,\n    {\n        self.mapv_inplace(f);\n        self\n    }\n\n    /// Modify the array in place by calling `f` by mutable reference on each element.\n    ///\n    /// Elements are visited in arbitrary order.\n    pub fn map_inplace<F>(&mut self, f: F)\n    where\n        S: DataMut,\n        F: FnMut(&mut A),\n    {\n        self.unordered_foreach_mut(f);\n    }\n\n    /// Modify the array in place by calling `f` by **v**alue on each element.\n    /// The array is updated with the new values.\n    ///\n    /// Elements are visited in arbitrary order.\n    ///\n    /// ```\n    /// use approx::assert_abs_diff_eq;\n    /// use ndarray::arr2;\n    ///\n    /// # #[cfg(feature = \"approx\")] {\n    /// let mut a = arr2(&[[ 0., 1.],\n    ///                    [-1., 2.]]);\n    /// a.mapv_inplace(f32::exp);\n    /// assert_abs_diff_eq!(\n    ///     a,\n    ///     arr2(&[[1.00000, 2.71828],\n    ///            [0.36788, 7.38906]]),\n    ///     epsilon = 1e-5,\n    /// );\n    /// # }\n    /// ```\n    pub fn mapv_inplace<F>(&mut self, mut f: F)\n    where\n        S: DataMut,\n        F: FnMut(A) -> A,\n        A: Clone,\n    {\n        self.unordered_foreach_mut(move |x| *x = f(x.clone()));\n    }\n\n    /// Visit each element in the array by calling `f` by reference\n    /// on each element.\n    ///\n    /// Elements are visited in arbitrary order.\n    pub fn visit<'a, F>(&'a self, mut f: F)\n    where\n        F: FnMut(&'a A),\n        A: 'a,\n        S: Data,\n    {\n        self.fold((), move |(), elt| f(elt))\n    }\n\n    /// Fold along an axis.\n    ///\n    /// Combine the elements of each subview with the previous using the `fold`\n    /// function and initial value `init`.\n    ///\n    /// Return the result as an `Array`.\n    ///\n    /// **Panics** if `axis` is out of bounds.\n    pub fn fold_axis<B, F>(&self, axis: Axis, init: B, mut fold: F) -> Array<B, D::Smaller>\n    where\n        D: RemoveAxis,\n        F: FnMut(&B, &A) -> B,\n        B: Clone,\n        S: Data,\n    {\n        let mut res = Array::from_elem(self.raw_dim().remove_axis(axis), init);\n        for subview in self.axis_iter(axis) {\n            res.zip_mut_with(&subview, |x, y| *x = fold(x, y));\n        }\n        res\n    }\n\n    /// Reduce the values along an axis into just one value, producing a new\n    /// array with one less dimension.\n    ///\n    /// Elements are visited in arbitrary order.\n    ///\n    /// Return the result as an `Array`.\n    ///\n    /// **Panics** if `axis` is out of bounds.\n    pub fn map_axis<'a, B, F>(&'a self, axis: Axis, mut mapping: F) -> Array<B, D::Smaller>\n    where\n        D: RemoveAxis,\n        F: FnMut(ArrayView1<'a, A>) -> B,\n        A: 'a,\n        S: Data,\n    {\n        let view_len = self.len_of(axis);\n        let view_stride = self.strides.axis(axis);\n        if view_len == 0 {\n            let new_dim = self.dim.remove_axis(axis);\n            Array::from_shape_simple_fn(new_dim, move || mapping(ArrayView::from(&[])))\n        } else {\n            // use the 0th subview as a map to each 1d array view extended from\n            // the 0th element.\n            self.index_axis(axis, 0).map(|first_elt| unsafe {\n                mapping(ArrayView::new_(first_elt, Ix1(view_len), Ix1(view_stride)))\n            })\n        }\n    }\n\n    /// Reduce the values along an axis into just one value, producing a new\n    /// array with one less dimension.\n    /// 1-dimensional lanes are passed as mutable references to the reducer,\n    /// allowing for side-effects.\n    ///\n    /// Elements are visited in arbitrary order.\n    ///\n    /// Return the result as an `Array`.\n    ///\n    /// **Panics** if `axis` is out of bounds.\n    pub fn map_axis_mut<'a, B, F>(&'a mut self, axis: Axis, mut mapping: F) -> Array<B, D::Smaller>\n    where\n        D: RemoveAxis,\n        F: FnMut(ArrayViewMut1<'a, A>) -> B,\n        A: 'a,\n        S: DataMut,\n    {\n        let view_len = self.len_of(axis);\n        let view_stride = self.strides.axis(axis);\n        if view_len == 0 {\n            let new_dim = self.dim.remove_axis(axis);\n            Array::from_shape_simple_fn(new_dim, move || mapping(ArrayViewMut::from(&mut [])))\n        } else {\n            // use the 0th subview as a map to each 1d array view extended from\n            // the 0th element.\n            self.index_axis_mut(axis, 0).map_mut(|first_elt| unsafe {\n                mapping(ArrayViewMut::new_(\n                    first_elt,\n                    Ix1(view_len),\n                    Ix1(view_stride),\n                ))\n            })\n        }\n    }\n\n    /// Iterates over pairs of consecutive elements along the axis.\n    ///\n    /// The first argument to the closure is an element, and the second\n    /// argument is the next element along the axis. Iteration is guaranteed to\n    /// proceed in order along the specified axis, but in all other respects\n    /// the iteration order is unspecified.\n    ///\n    /// # Example\n    ///\n    /// For example, this can be used to compute the cumulative sum along an\n    /// axis:\n    ///\n    /// ```\n    /// use ndarray::{array, Axis};\n    ///\n    /// let mut arr = array![\n    ///     [[1, 2], [3, 4], [5, 6]],\n    ///     [[7, 8], [9, 10], [11, 12]],\n    /// ];\n    /// arr.accumulate_axis_inplace(Axis(1), |&prev, curr| *curr += prev);\n    /// assert_eq!(\n    ///     arr,\n    ///     array![\n    ///         [[1, 2], [4, 6], [9, 12]],\n    ///         [[7, 8], [16, 18], [27, 30]],\n    ///     ],\n    /// );\n    /// ```\n    pub fn accumulate_axis_inplace<F>(&mut self, axis: Axis, mut f: F)\n    where\n        F: FnMut(&A, &mut A),\n        S: DataMut,\n    {\n        if self.len_of(axis) <= 1 {\n            return;\n        }\n        let mut curr = self.raw_view_mut(); // mut borrow of the array here\n        let mut prev = curr.raw_view(); // derive further raw views from the same borrow\n        prev.slice_axis_inplace(axis, Slice::from(..-1));\n        curr.slice_axis_inplace(axis, Slice::from(1..));\n        // This implementation relies on `Zip` iterating along `axis` in order.\n        Zip::from(prev).and(curr).apply(|prev, curr| unsafe {\n            // These pointer dereferences and borrows are safe because:\n            //\n            // 1. They're pointers to elements in the array.\n            //\n            // 2. `S: DataMut` guarantees that elements are safe to borrow\n            //    mutably and that they don't alias.\n            //\n            // 3. The lifetimes of the borrows last only for the duration\n            //    of the call to `f`, so aliasing across calls to `f`\n            //    cannot occur.\n            f(&*prev, &mut *curr)\n        });\n    }\n}","impl<A, S, D> ArrayBase<S, D>\nwhere\n    S: RawDataSubst<A, Elem=MaybeUninit<A>>,\n    D: Dimension,\n{\n    /// **Promise** that the array's elements are all fully initialized, and convert\n    /// the array from element type `MaybeUninit<A>` to `A`.\n    ///\n    /// For example, it can convert an `Array<MaybeUninit<f64>, D>` to `Array<f64, D>`.\n    ///\n    /// ## Safety\n    ///\n    /// Safe to use if all the array's elements have been initialized.\n    ///\n    /// Note that for owned and shared ownership arrays, the promise must include all of the\n    /// array's storage; it is for example possible to slice these in place, but that must\n    /// only be done after all elements have been initialized.\n    pub unsafe fn assume_init(self) -> ArrayBase<<S as RawDataSubst<A>>::Output, D> {\n        // NOTE: Fully initialized includes elements not reachable in current slicing/view.\n\n        let ArrayBase { data, ptr, dim, strides } = self;\n\n        // transmute from storage of MaybeUninit<A> to storage of A\n        let data = unlimited_transmute::<S, S::Output>(data);\n        let ptr = ptr.cast::<A>();\n\n        ArrayBase {\n            data,\n            ptr,\n            dim,\n            strides,\n        }\n    }\n}","impl<A, S, D> Default for ArrayBase<S, D>\nwhere\n    S: DataOwned<Elem = A>,\n    D: Dimension,\n    A: Default,\n{\n    // NOTE: We can implement Default for non-zero dimensional array views by\n    // using an empty slice, however we need a trait for nonzero Dimension.\n    fn default() -> Self {\n        ArrayBase::default(D::default())\n    }\n}","impl<A, S, D> Neg for ArrayBase<S, D>\n    where\n        A: Clone + Neg<Output = A>,\n        S: DataOwned<Elem = A> + DataMut,\n        D: Dimension,\n    {\n        type Output = Self;\n        /// Perform an elementwise negation of `self` and return the result.\n        fn neg(mut self) -> Self {\n            self.unordered_foreach_mut(|elt| {\n                *elt = -elt.clone();\n            });\n            self\n        }\n    }","impl<A, S, D> Not for ArrayBase<S, D>\n    where\n        A: Clone + Not<Output = A>,\n        S: DataOwned<Elem = A> + DataMut,\n        D: Dimension,\n    {\n        type Output = Self;\n        /// Perform an elementwise unary not of `self` and return the result.\n        fn not(mut self) -> Self {\n            self.unordered_foreach_mut(|elt| {\n                *elt = !elt.clone();\n            });\n            self\n        }\n    }","impl<A, S, S2> Dot<ArrayBase<S2, Ix1>> for ArrayBase<S, Ix1>\nwhere\n    S: Data<Elem = A>,\n    S2: Data<Elem = A>,\n    A: LinalgScalar,\n{\n    type Output = A;\n\n    /// Compute the dot product of one-dimensional arrays.\n    ///\n    /// The dot product is a sum of the elementwise products (no conjugation\n    /// of complex operands, and thus not their inner product).\n    ///\n    /// **Panics** if the arrays are not of the same length.<br>\n    /// *Note:* If enabled, uses blas `dot` for elements of `f32, f64` when memory\n    /// layout allows.\n    fn dot(&self, rhs: &ArrayBase<S2, Ix1>) -> A {\n        self.dot_impl(rhs)\n    }\n}","impl<A, S, S2> Dot<ArrayBase<S2, Ix1>> for ArrayBase<S, Ix2>\nwhere\n    S: Data<Elem = A>,\n    S2: Data<Elem = A>,\n    A: LinalgScalar,\n{\n    type Output = Array<A, Ix1>;\n    fn dot(&self, rhs: &ArrayBase<S2, Ix1>) -> Array<A, Ix1> {\n        let ((m, a), n) = (self.dim(), rhs.dim());\n        if a != n {\n            dot_shape_error(m, a, n, 1);\n        }\n\n        // Avoid initializing the memory in vec -- set it during iteration\n        unsafe {\n            let mut c = Array::uninitialized(m);\n            general_mat_vec_mul(A::one(), self, rhs, A::zero(), &mut c);\n            c\n        }\n    }\n}","impl<A, S, S2> Dot<ArrayBase<S2, Ix2>> for ArrayBase<S, Ix1>\nwhere\n    S: Data<Elem = A>,\n    S2: Data<Elem = A>,\n    A: LinalgScalar,\n{\n    type Output = Array<A, Ix1>;\n\n    /// Perform the matrix multiplication of the row vector `self` and\n    /// rectangular matrix `rhs`.\n    ///\n    /// The array shapes must agree in the way that\n    /// if `self` is *M*, then `rhs` is *M*  *N*.\n    ///\n    /// Return a result array with shape *N*.\n    ///\n    /// **Panics** if shapes are incompatible.\n    fn dot(&self, rhs: &ArrayBase<S2, Ix2>) -> Array<A, Ix1> {\n        rhs.t().dot(self)\n    }\n}","impl<A, S, S2> Dot<ArrayBase<S2, Ix2>> for ArrayBase<S, Ix2>\nwhere\n    S: Data<Elem = A>,\n    S2: Data<Elem = A>,\n    A: LinalgScalar,\n{\n    type Output = Array2<A>;\n    fn dot(&self, b: &ArrayBase<S2, Ix2>) -> Array2<A> {\n        let a = self.view();\n        let b = b.view();\n        let ((m, k), (k2, n)) = (a.dim(), b.dim());\n        if k != k2 || m.checked_mul(n).is_none() {\n            dot_shape_error(m, k, k2, n);\n        }\n\n        let lhs_s0 = a.strides()[0];\n        let rhs_s0 = b.strides()[0];\n        let column_major = lhs_s0 == 1 && rhs_s0 == 1;\n        // A is Copy so this is safe\n        let mut v = Vec::with_capacity(m * n);\n        let mut c;\n        unsafe {\n            v.set_len(m * n);\n            c = Array::from_shape_vec_unchecked((m, n).set_f(column_major), v);\n        }\n        mat_mul_impl(A::one(), &a, &b, A::zero(), &mut c.view_mut());\n        c\n    }\n}","impl<A, S> ArrayBase<S, Ix1>\nwhere\n    S: Data<Elem = A>,\n{\n    /// Perform dot product or matrix multiplication of arrays `self` and `rhs`.\n    ///\n    /// `Rhs` may be either a one-dimensional or a two-dimensional array.\n    ///\n    /// If `Rhs` is one-dimensional, then the operation is a vector dot\n    /// product, which is the sum of the elementwise products (no conjugation\n    /// of complex operands, and thus not their inner product). In this case,\n    /// `self` and `rhs` must be the same length.\n    ///\n    /// If `Rhs` is two-dimensional, then the operation is matrix\n    /// multiplication, where `self` is treated as a row vector. In this case,\n    /// if `self` is shape *M*, then `rhs` is shape *M*  *N* and the result is\n    /// shape *N*.\n    ///\n    /// **Panics** if the array shapes are incompatible.<br>\n    /// *Note:* If enabled, uses blas `dot` for elements of `f32, f64` when memory\n    /// layout allows.\n    pub fn dot<Rhs>(&self, rhs: &Rhs) -> <Self as Dot<Rhs>>::Output\n    where\n        Self: Dot<Rhs>,\n    {\n        Dot::dot(self, rhs)\n    }\n\n    fn dot_generic<S2>(&self, rhs: &ArrayBase<S2, Ix1>) -> A\n    where\n        S2: Data<Elem = A>,\n        A: LinalgScalar,\n    {\n        debug_assert_eq!(self.len(), rhs.len());\n        assert!(self.len() == rhs.len());\n        if let Some(self_s) = self.as_slice() {\n            if let Some(rhs_s) = rhs.as_slice() {\n                return numeric_util::unrolled_dot(self_s, rhs_s);\n            }\n        }\n        let mut sum = A::zero();\n        for i in 0..self.len() {\n            unsafe {\n                sum = sum + *self.uget(i) * *rhs.uget(i);\n            }\n        }\n        sum\n    }\n\n    #[cfg(not(feature = \"blas\"))]\n    fn dot_impl<S2>(&self, rhs: &ArrayBase<S2, Ix1>) -> A\n    where\n        S2: Data<Elem = A>,\n        A: LinalgScalar,\n    {\n        self.dot_generic(rhs)\n    }\n\n    #[cfg(feature = \"blas\")]\n    fn dot_impl<S2>(&self, rhs: &ArrayBase<S2, Ix1>) -> A\n    where\n        S2: Data<Elem = A>,\n        A: LinalgScalar,\n    {\n        // Use only if the vector is large enough to be worth it\n        if self.len() >= DOT_BLAS_CUTOFF {\n            debug_assert_eq!(self.len(), rhs.len());\n            assert!(self.len() == rhs.len());\n            macro_rules! dot {\n                ($ty:ty, $func:ident) => {{\n                    if blas_compat_1d::<$ty, _>(self) && blas_compat_1d::<$ty, _>(rhs) {\n                        unsafe {\n                            let (lhs_ptr, n, incx) =\n                                blas_1d_params(self.ptr.as_ptr(), self.len(), self.strides()[0]);\n                            let (rhs_ptr, _, incy) =\n                                blas_1d_params(rhs.ptr.as_ptr(), rhs.len(), rhs.strides()[0]);\n                            let ret = blas_sys::$func(\n                                n,\n                                lhs_ptr as *const $ty,\n                                incx,\n                                rhs_ptr as *const $ty,\n                                incy,\n                            );\n                            return cast_as::<$ty, A>(&ret);\n                        }\n                    }\n                }};\n            }\n\n            dot! {f32, cblas_sdot};\n            dot! {f64, cblas_ddot};\n        }\n        self.dot_generic(rhs)\n    }\n}","impl<A, S> ArrayBase<S, Ix1>\nwhere\n    S: RawData<Elem = A>,\n{\n    /// Return an vector with the elements of the one-dimensional array.\n    pub fn to_vec(&self) -> Vec<A>\n    where\n        A: Clone,\n        S: Data,\n    {\n        if let Some(slc) = self.as_slice() {\n            slc.to_vec()\n        } else {\n            crate::iterators::to_vec(self.iter().cloned())\n        }\n    }\n}","impl<A, S> ArrayBase<S, Ix2>\nwhere\n    S: Data<Elem = A>,\n{\n    /// Perform matrix multiplication of rectangular arrays `self` and `rhs`.\n    ///\n    /// `Rhs` may be either a one-dimensional or a two-dimensional array.\n    ///\n    /// If Rhs is two-dimensional, they array shapes must agree in the way that\n    /// if `self` is *M*  *N*, then `rhs` is *N*  *K*.\n    ///\n    /// Return a result array with shape *M*  *K*.\n    ///\n    /// **Panics** if shapes are incompatible or the number of elements in the\n    /// result would overflow `isize`.\n    ///\n    /// *Note:* If enabled, uses blas `gemv/gemm` for elements of `f32, f64`\n    /// when memory layout allows. The default matrixmultiply backend\n    /// is otherwise used for `f32, f64` for all memory layouts.\n    ///\n    /// ```\n    /// use ndarray::arr2;\n    ///\n    /// let a = arr2(&[[1., 2.],\n    ///                [0., 1.]]);\n    /// let b = arr2(&[[1., 2.],\n    ///                [2., 3.]]);\n    ///\n    /// assert!(\n    ///     a.dot(&b) == arr2(&[[5., 8.],\n    ///                         [2., 3.]])\n    /// );\n    /// ```\n    pub fn dot<Rhs>(&self, rhs: &Rhs) -> <Self as Dot<Rhs>>::Output\n    where\n        Self: Dot<Rhs>,\n    {\n        Dot::dot(self, rhs)\n    }\n}","impl<A, S> ArrayBase<S, Ix2>\nwhere\n    S: RawData<Elem = A>,\n{\n    /// Return an array view of row `index`.\n    ///\n    /// **Panics** if `index` is out of bounds.\n    pub fn row(&self, index: Ix) -> ArrayView1<'_, A>\n    where\n        S: Data,\n    {\n        self.index_axis(Axis(0), index)\n    }\n\n    /// Return a mutable array view of row `index`.\n    ///\n    /// **Panics** if `index` is out of bounds.\n    pub fn row_mut(&mut self, index: Ix) -> ArrayViewMut1<'_, A>\n    where\n        S: DataMut,\n    {\n        self.index_axis_mut(Axis(0), index)\n    }\n\n    /// Return the number of rows (length of `Axis(0)`) in the two-dimensional array.\n    pub fn nrows(&self) -> usize {\n        self.len_of(Axis(0))\n    }\n\n    /// Return the number of rows (length of `Axis(0)`) in the two-dimensional array.\n    #[deprecated(note = \"Renamed to .nrows(), please use the new name\")]\n    pub fn rows(&self) -> usize {\n        self.nrows()\n    }\n\n    /// Return an array view of column `index`.\n    ///\n    /// **Panics** if `index` is out of bounds.\n    pub fn column(&self, index: Ix) -> ArrayView1<'_, A>\n    where\n        S: Data,\n    {\n        self.index_axis(Axis(1), index)\n    }\n\n    /// Return a mutable array view of column `index`.\n    ///\n    /// **Panics** if `index` is out of bounds.\n    pub fn column_mut(&mut self, index: Ix) -> ArrayViewMut1<'_, A>\n    where\n        S: DataMut,\n    {\n        self.index_axis_mut(Axis(1), index)\n    }\n\n    /// Return the number of columns (length of `Axis(1)`) in the two-dimensional array.\n    pub fn ncols(&self) -> usize {\n        self.len_of(Axis(1))\n    }\n\n    /// Return the number of columns (length of `Axis(1)`) in the two-dimensional array.\n    #[deprecated(note = \"Renamed to .ncols(), please use the new name\")]\n    pub fn cols(&self) -> usize {\n        self.ncols()\n    }\n\n    /// Return true if the array is square, false otherwise.\n    pub fn is_square(&self) -> bool {\n        self.nrows() == self.ncols()\n    }\n}","impl<A, S> ArrayBase<S, IxDyn>\nwhere\n    S: Data<Elem = A>,\n{\n    /// Insert new array axis of length 1 at `axis`, modifying the shape and\n    /// strides in-place.\n    ///\n    /// **Panics** if the axis is out of bounds.\n    ///\n    /// ```\n    /// use ndarray::{Axis, arr2, arr3};\n    ///\n    /// let mut a = arr2(&[[1, 2, 3], [4, 5, 6]]).into_dyn();\n    /// assert_eq!(a.shape(), &[2, 3]);\n    ///\n    /// a.insert_axis_inplace(Axis(1));\n    /// assert_eq!(a, arr3(&[[[1, 2, 3]], [[4, 5, 6]]]).into_dyn());\n    /// assert_eq!(a.shape(), &[2, 1, 3]);\n    /// ```\n    pub fn insert_axis_inplace(&mut self, axis: Axis) {\n        assert!(axis.index() <= self.ndim());\n        self.dim = self.dim.insert_axis(axis);\n        self.strides = self.strides.insert_axis(axis);\n    }\n\n    /// Collapses the array to `index` along the axis and removes the axis,\n    /// modifying the shape and strides in-place.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    ///\n    /// ```\n    /// use ndarray::{Axis, arr1, arr2};\n    ///\n    /// let mut a = arr2(&[[1, 2, 3], [4, 5, 6]]).into_dyn();\n    /// assert_eq!(a.shape(), &[2, 3]);\n    ///\n    /// a.index_axis_inplace(Axis(1), 1);\n    /// assert_eq!(a, arr1(&[2, 5]).into_dyn());\n    /// assert_eq!(a.shape(), &[2]);\n    /// ```\n    pub fn index_axis_inplace(&mut self, axis: Axis, index: usize) {\n        self.collapse_axis(axis, index);\n        self.dim = self.dim.remove_axis(axis);\n        self.strides = self.strides.remove_axis(axis);\n    }\n}","impl<A, S> From<Vec<A>> for ArrayBase<S, Ix1>\nwhere\n    S: DataOwned<Elem = A>,\n{\n    /// Create a one-dimensional array from a vector (no copying needed).\n    ///\n    /// **Panics** if the length is greater than `isize::MAX`.\n    ///\n    /// ```rust\n    /// use ndarray::Array;\n    ///\n    /// let array = Array::from(vec![1., 2., 3., 4.]);\n    /// ```\n    fn from(v: Vec<A>) -> Self {\n        if mem::size_of::<A>() == 0 {\n            assert!(\n                v.len() <= isize::MAX as usize,\n                \"Length must fit in `isize`.\",\n            );\n        }\n        unsafe { Self::from_shape_vec_unchecked(v.len() as Ix, v) }\n    }\n}","impl<A, S> FromIterator<A> for ArrayBase<S, Ix1>\nwhere\n    S: DataOwned<Elem = A>,\n{\n    /// Create a one-dimensional array from an iterable.\n    ///\n    /// **Panics** if the length is greater than `isize::MAX`.\n    ///\n    /// ```rust\n    /// use ndarray::{Array, arr1};\n    /// use std::iter::FromIterator;\n    ///\n    /// // Either use `from_iter` directly or use `Iterator::collect`.\n    /// let array = Array::from_iter((0..5).map(|x| x * x));\n    /// assert!(array == arr1(&[0, 1, 4, 9, 16]))\n    /// ```\n    fn from_iter<I>(iterable: I) -> ArrayBase<S, Ix1>\n    where\n        I: IntoIterator<Item = A>,\n    {\n        Self::from(iterable.into_iter().collect::<Vec<A>>())\n    }\n}","impl<S, A, D> ArrayBase<S, D>\nwhere\n    S: DataOwned<Elem = A>,\n    D: Dimension,\n{\n    /// Create an array with copies of `elem`, shape `shape`.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    ///\n    /// ```\n    /// use ndarray::{Array, arr3, ShapeBuilder};\n    ///\n    /// let a = Array::from_elem((2, 2, 2), 1.);\n    ///\n    /// assert!(\n    ///     a == arr3(&[[[1., 1.],\n    ///                  [1., 1.]],\n    ///                 [[1., 1.],\n    ///                  [1., 1.]]])\n    /// );\n    /// assert!(a.strides() == &[4, 2, 1]);\n    ///\n    /// let b = Array::from_elem((2, 2, 2).f(), 1.);\n    /// assert!(b.strides() == &[1, 2, 4]);\n    /// ```\n    pub fn from_elem<Sh>(shape: Sh, elem: A) -> Self\n    where\n        A: Clone,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        let shape = shape.into_shape();\n        let size = size_of_shape_checked_unwrap!(&shape.dim);\n        let v = vec![elem; size];\n        unsafe { Self::from_shape_vec_unchecked(shape, v) }\n    }\n\n    /// Create an array with zeros, shape `shape`.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    pub fn zeros<Sh>(shape: Sh) -> Self\n    where\n        A: Clone + Zero,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        Self::from_elem(shape, A::zero())\n    }\n\n    /// Create an array with ones, shape `shape`.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    pub fn ones<Sh>(shape: Sh) -> Self\n    where\n        A: Clone + One,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        Self::from_elem(shape, A::one())\n    }\n\n    /// Create an array with default values, shape `shape`\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    pub fn default<Sh>(shape: Sh) -> Self\n    where\n        A: Default,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        Self::from_shape_simple_fn(shape, A::default)\n    }\n\n    /// Create an array with values created by the function `f`.\n    ///\n    /// `f` is called with no argument, and it should return the element to\n    /// create. If the precise index of the element to create is needed,\n    /// use [`from_shape_fn`](ArrayBase::from_shape_fn) instead.\n    ///\n    /// This constructor can be useful if the element order is not important,\n    /// for example if they are identical or random.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    pub fn from_shape_simple_fn<Sh, F>(shape: Sh, mut f: F) -> Self\n    where\n        Sh: ShapeBuilder<Dim = D>,\n        F: FnMut() -> A,\n    {\n        let shape = shape.into_shape();\n        let len = size_of_shape_checked_unwrap!(&shape.dim);\n        let v = to_vec_mapped(0..len, move |_| f());\n        unsafe { Self::from_shape_vec_unchecked(shape, v) }\n    }\n\n    /// Create an array with values created by the function `f`.\n    ///\n    /// `f` is called with the index of the element to create; the elements are\n    /// visited in arbitrary order.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    ///\n    /// ```\n    /// use ndarray::{Array, arr2};\n    ///\n    /// // Create a table of i j (with i and j from 1 to 3)\n    /// let ij_table = Array::from_shape_fn((3, 3), |(i, j)| (1 + i) * (1 + j));\n    ///\n    /// assert_eq!(\n    ///     ij_table,\n    ///     arr2(&[[1, 2, 3],\n    ///            [2, 4, 6],\n    ///            [3, 6, 9]])\n    /// );\n    /// ```\n    pub fn from_shape_fn<Sh, F>(shape: Sh, f: F) -> Self\n    where\n        Sh: ShapeBuilder<Dim = D>,\n        F: FnMut(D::Pattern) -> A,\n    {\n        let shape = shape.into_shape();\n        let _ = size_of_shape_checked_unwrap!(&shape.dim);\n        if shape.is_c {\n            let v = to_vec_mapped(indices(shape.dim.clone()).into_iter(), f);\n            unsafe { Self::from_shape_vec_unchecked(shape, v) }\n        } else {\n            let dim = shape.dim.clone();\n            let v = to_vec_mapped(indexes::indices_iter_f(dim), f);\n            unsafe { Self::from_shape_vec_unchecked(shape, v) }\n        }\n    }\n\n    /// Create an array with the given shape from a vector. (No cloning of\n    /// elements needed.)\n    ///\n    /// ----\n    ///\n    /// For a contiguous c- or f-order shape, the following applies:\n    ///\n    /// **Errors** if `shape` does not correspond to the number of elements in\n    /// `v` or if the shape/strides would result in overflowing `isize`.\n    ///\n    /// ----\n    ///\n    /// For custom strides, the following applies:\n    ///\n    /// **Errors** if strides and dimensions can point out of bounds of `v`, if\n    /// strides allow multiple indices to point to the same element, or if the\n    /// shape/strides would result in overflowing `isize`.\n    ///\n    /// ```\n    /// use ndarray::Array;\n    /// use ndarray::ShapeBuilder; // Needed for .strides() method\n    /// use ndarray::arr2;\n    ///\n    /// let a = Array::from_shape_vec((2, 2), vec![1., 2., 3., 4.]);\n    /// assert!(a.is_ok());\n    ///\n    /// let b = Array::from_shape_vec((2, 2).strides((1, 2)),\n    ///                               vec![1., 2., 3., 4.]).unwrap();\n    /// assert!(\n    ///     b == arr2(&[[1., 3.],\n    ///                 [2., 4.]])\n    /// );\n    /// ```\n    pub fn from_shape_vec<Sh>(shape: Sh, v: Vec<A>) -> Result<Self, ShapeError>\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        // eliminate the type parameter Sh as soon as possible\n        Self::from_shape_vec_impl(shape.into(), v)\n    }\n\n    fn from_shape_vec_impl(shape: StrideShape<D>, v: Vec<A>) -> Result<Self, ShapeError> {\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if shape.custom {\n            dimension::can_index_slice(&v, &dim, &strides)?;\n        } else {\n            dimension::can_index_slice_not_custom::<A, _>(&v, &dim)?;\n            if dim.size() != v.len() {\n                return Err(error::incompatible_shapes(&Ix1(v.len()), &dim));\n            }\n        }\n        unsafe { Ok(Self::from_vec_dim_stride_unchecked(dim, strides, v)) }\n    }\n\n    /// Creates an array from a vector and interpret it according to the\n    /// provided shape and strides. (No cloning of elements needed.)\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that the following conditions are met:\n    ///\n    /// 1. The ndim of `dim` and `strides` must be the same.\n    ///\n    /// 2. The product of non-zero axis lengths must not exceed `isize::MAX`.\n    ///\n    /// 3. For axes with length > 1, the stride must be nonnegative.\n    ///\n    /// 4. If the array will be empty (any axes are zero-length), the\n    ///    difference between the least address and greatest address accessible\n    ///    by moving along all axes must be  `v.len()`.\n    ///\n    ///    If the array will not be empty, the difference between the least\n    ///    address and greatest address accessible by moving along all axes\n    ///    must be < `v.len()`.\n    ///\n    /// 5. The strides must not allow any element to be referenced by two different\n    ///    indices.\n    pub unsafe fn from_shape_vec_unchecked<Sh>(shape: Sh, v: Vec<A>) -> Self\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        let shape = shape.into();\n        Self::from_vec_dim_stride_unchecked(shape.dim, shape.strides, v)\n    }\n\n    unsafe fn from_vec_dim_stride_unchecked(dim: D, strides: D, mut v: Vec<A>) -> Self {\n        // debug check for issues that indicates wrong use of this constructor\n        debug_assert!(dimension::can_index_slice(&v, &dim, &strides).is_ok());\n        ArrayBase {\n            ptr: nonnull_from_vec_data(&mut v),\n            data: DataOwned::new(v),\n            strides,\n            dim,\n        }\n    }\n\n    /// Create an array with uninitalized elements, shape `shape`.\n    ///\n    /// Prefer to use [`maybe_uninit()`](ArrayBase::maybe_uninit) if possible, because it is\n    /// easier to use correctly.\n    ///\n    /// **Panics** if the number of elements in `shape` would overflow isize.\n    ///\n    /// ### Safety\n    ///\n    /// Accessing uninitalized values is undefined behaviour. You must overwrite *all* the elements\n    /// in the array after it is created; for example using\n    /// [`raw_view_mut`](ArrayBase::raw_view_mut) or other low-level element access.\n    ///\n    /// The contents of the array is indeterminate before initialization and it\n    /// is an error to perform operations that use the previous values. For\n    /// example it would not be legal to use `a += 1.;` on such an array.\n    ///\n    /// This constructor is limited to elements where `A: Copy` (no destructors)\n    /// to avoid users shooting themselves too hard in the foot.\n    /// \n    /// (Also note that the constructors `from_shape_vec` and\n    /// `from_shape_vec_unchecked` allow the user yet more control, in the sense\n    /// that Arrays can be created from arbitrary vectors.)\n    pub unsafe fn uninitialized<Sh>(shape: Sh) -> Self\n    where\n        A: Copy,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        let shape = shape.into_shape();\n        let size = size_of_shape_checked_unwrap!(&shape.dim);\n        let mut v = Vec::with_capacity(size);\n        v.set_len(size);\n        Self::from_shape_vec_unchecked(shape, v)\n    }\n}","impl<S, A, D> ArrayBase<S, D>\nwhere\n    S: DataOwned<Elem = MaybeUninit<A>>,\n    D: Dimension,\n{\n    /// Create an array with uninitalized elements, shape `shape`.\n    ///\n    /// The uninitialized elements of type `A` are represented by the type `MaybeUninit<A>`,\n    /// an easier way to handle uninit values correctly.\n    ///\n    /// Only *when* the array is completely initialized with valid elements, can it be\n    /// converted to an array of `A` elements using [`.assume_init()`].\n    ///\n    /// **Panics** if the number of elements in `shape` would overflow isize.\n    ///\n    /// ### Safety\n    ///\n    /// The whole of the array must be initialized before it is converted\n    /// using [`.assume_init()`] or otherwise traversed.\n    ///\n    /// ### Examples\n    ///\n    /// It is possible to assign individual values through `*elt = MaybeUninit::new(value)`\n    /// and so on.\n    ///\n    /// [`.assume_init()`]: ArrayBase::assume_init\n    ///\n    /// ```\n    /// use ndarray::{s, Array2};\n    /// use ndarray::Zip;\n    /// use ndarray::Axis;\n    ///\n    /// // Example Task: Let's create a column shifted copy of the input\n    ///\n    /// fn shift_by_two(a: &Array2<f32>) -> Array2<f32> {\n    ///     // create an uninitialized array\n    ///     let mut b = Array2::maybe_uninit(a.dim());\n    ///\n    ///     // two first columns in b are two last in a\n    ///     // rest of columns in b are the initial columns in a\n    ///\n    ///     assign_to(a.slice(s![.., -2..]), b.slice_mut(s![.., ..2]));\n    ///     assign_to(a.slice(s![.., 2..]), b.slice_mut(s![.., ..-2]));\n    ///\n    ///     // Now we can promise that `b` is safe to use with all operations\n    ///     unsafe {\n    ///         b.assume_init()\n    ///     }\n    /// }\n    ///\n    /// use ndarray::{IntoNdProducer, AssignElem};\n    ///\n    /// // This function clones elements from the first input to the second;\n    /// // the two producers must have the same shape\n    /// fn assign_to<'a, P1, P2, A>(from: P1, to: P2)\n    ///     where P1: IntoNdProducer<Item = &'a A>,\n    ///           P2: IntoNdProducer<Dim = P1::Dim>,\n    ///           P2::Item: AssignElem<A>,\n    ///           A: Clone + 'a\n    /// {\n    ///     Zip::from(from)\n    ///         .apply_assign_into(to, A::clone);\n    /// }\n    ///\n    /// # shift_by_two(&Array2::zeros((8, 8)));\n    /// ```\n    pub fn maybe_uninit<Sh>(shape: Sh) -> Self\n    where\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        unsafe {\n            let shape = shape.into_shape();\n            let size = size_of_shape_checked_unwrap!(&shape.dim);\n            let mut v = Vec::with_capacity(size);\n            v.set_len(size);\n            Self::from_shape_vec_unchecked(shape, v)\n        }\n    }\n}","impl<S, A> ArrayBase<S, Ix1>\nwhere\n    S: DataOwned<Elem = A>,\n{\n    /// Create a one-dimensional array from a vector (no copying needed).\n    ///\n    /// **Panics** if the length is greater than `isize::MAX`.\n    ///\n    /// ```rust\n    /// use ndarray::Array;\n    ///\n    /// let array = Array::from(vec![1., 2., 3., 4.]);\n    /// ```\n    #[deprecated(note = \"use standard `from`\", since = \"0.13.0\")]\n    pub fn from_vec(v: Vec<A>) -> Self {\n        Self::from(v)\n    }\n\n    /// Create a one-dimensional array with `n` evenly spaced elements from\n    /// `start` to `end` (inclusive). `A` must be a floating point type.\n    ///\n    /// Note that if `start > end`, the first element will still be `start`,\n    /// and the following elements will be decreasing. This is different from\n    /// the behavior of `std::ops::RangeInclusive`, which interprets `start >\n    /// end` to mean that the range is empty.\n    ///\n    /// **Panics** if `n` is greater than `isize::MAX` or if converting `n - 1`\n    /// to type `A` fails.\n    ///\n    /// ```rust\n    /// use ndarray::{Array, arr1};\n    ///\n    /// let array = Array::linspace(0., 1., 5);\n    /// assert!(array == arr1(&[0.0, 0.25, 0.5, 0.75, 1.0]))\n    /// ```\n    pub fn linspace(start: A, end: A, n: usize) -> Self\n    where\n        A: Float,\n    {\n        Self::from(to_vec(linspace::linspace(start, end, n)))\n    }\n\n    /// Create a one-dimensional array with elements from `start` to `end`\n    /// (exclusive), incrementing by `step`. `A` must be a floating point type.\n    ///\n    /// **Panics** if the length is greater than `isize::MAX`.\n    ///\n    /// ```rust\n    /// use ndarray::{Array, arr1};\n    ///\n    /// let array = Array::range(0., 5., 1.);\n    /// assert!(array == arr1(&[0., 1., 2., 3., 4.]))\n    /// ```\n    pub fn range(start: A, end: A, step: A) -> Self\n    where\n        A: Float,\n    {\n        Self::from(to_vec(linspace::range(start, end, step)))\n    }\n\n    /// Create a one-dimensional array with `n` logarithmically spaced\n    /// elements, with the starting value being `base.powf(start)` and the\n    /// final one being `base.powf(end)`. `A` must be a floating point type.\n    ///\n    /// If `base` is negative, all values will be negative.\n    ///\n    /// **Panics** if `n` is greater than `isize::MAX` or if converting `n - 1`\n    /// to type `A` fails.\n    ///\n    /// ```rust\n    /// use approx::assert_abs_diff_eq;\n    /// use ndarray::{Array, arr1};\n    ///\n    /// # #[cfg(feature = \"approx\")] {\n    /// let array = Array::logspace(10.0, 0.0, 3.0, 4);\n    /// assert_abs_diff_eq!(array, arr1(&[1e0, 1e1, 1e2, 1e3]));\n    ///\n    /// let array = Array::logspace(-10.0, 3.0, 0.0, 4);\n    /// assert_abs_diff_eq!(array, arr1(&[-1e3, -1e2, -1e1, -1e0]));\n    /// # }\n    /// ```\n    pub fn logspace(base: A, start: A, end: A, n: usize) -> Self\n    where\n        A: Float,\n    {\n        Self::from(to_vec(logspace::logspace(base, start, end, n)))\n    }\n\n    /// Create a one-dimensional array with `n` geometrically spaced elements\n    /// from `start` to `end` (inclusive). `A` must be a floating point type.\n    ///\n    /// Returns `None` if `start` and `end` have different signs or if either\n    /// one is zero. Conceptually, this means that in order to obtain a `Some`\n    /// result, `end / start` must be positive.\n    ///\n    /// **Panics** if `n` is greater than `isize::MAX` or if converting `n - 1`\n    /// to type `A` fails.\n    ///\n    /// ```rust\n    /// use approx::assert_abs_diff_eq;\n    /// use ndarray::{Array, arr1};\n    ///\n    /// # fn example() -> Option<()> {\n    /// # #[cfg(feature = \"approx\")] {\n    /// let array = Array::geomspace(1e0, 1e3, 4)?;\n    /// assert_abs_diff_eq!(array, arr1(&[1e0, 1e1, 1e2, 1e3]), epsilon = 1e-12);\n    ///\n    /// let array = Array::geomspace(-1e3, -1e0, 4)?;\n    /// assert_abs_diff_eq!(array, arr1(&[-1e3, -1e2, -1e1, -1e0]), epsilon = 1e-12);\n    /// # }\n    /// # Some(())\n    /// # }\n    /// #\n    /// # example().unwrap();\n    /// ```\n    pub fn geomspace(start: A, end: A, n: usize) -> Option<Self>\n    where\n        A: Float,\n    {\n        Some(Self::from(to_vec(geomspace::geomspace(start, end, n)?)))\n    }\n}","impl<S, A> ArrayBase<S, Ix2>\nwhere\n    S: DataOwned<Elem = A>,\n{\n    /// Create an identity matrix of size `n` (square 2D array).\n    ///\n    /// **Panics** if `n * n` would overflow `isize`.\n    pub fn eye(n: Ix) -> Self\n    where\n        S: DataMut,\n        A: Clone + Zero + One,\n    {\n        let mut eye = Self::zeros((n, n));\n        for a_ii in eye.diag_mut() {\n            *a_ii = A::one();\n        }\n        eye\n    }\n\n    /// Create a 2D matrix from its diagonal\n    ///\n    /// **Panics** if `diag.len() * diag.len()` would overflow `isize`.\n    ///\n    /// ```rust\n    /// use ndarray::{Array2, arr1, arr2};\n    ///\n    /// let diag = arr1(&[1, 2]);\n    /// let array = Array2::from_diag(&diag);\n    /// assert_eq!(array, arr2(&[[1, 0], [0, 2]]));\n    /// ```\n    pub fn from_diag<S2>(diag: &ArrayBase<S2, Ix1>) -> Self\n    where\n        A: Clone + Zero,\n        S: DataMut,\n        S2: Data<Elem = A>,\n    {\n        let n = diag.len();\n        let mut arr = Self::zeros((n, n));\n        arr.diag_mut().assign(&diag);\n        arr\n    }\n}","impl<S, D, I> Index<I> for ArrayBase<S, D>\nwhere\n    D: Dimension,\n    I: NdIndex<D>,\n    S: Data,\n{\n    type Output = S::Elem;\n    #[inline]\n    fn index(&self, index: I) -> &S::Elem {\n        debug_bounds_check!(self, index);\n        unsafe {\n            &*self.ptr.as_ptr().offset(\n                index\n                    .index_checked(&self.dim, &self.strides)\n                    .unwrap_or_else(|| array_out_of_bounds()),\n            )\n        }\n    }\n}","impl<S, D, I> IndexMut<I> for ArrayBase<S, D>\nwhere\n    D: Dimension,\n    I: NdIndex<D>,\n    S: DataMut,\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut S::Elem {\n        debug_bounds_check!(self, index);\n        unsafe {\n            &mut *self.as_mut_ptr().offset(\n                index\n                    .index_checked(&self.dim, &self.strides)\n                    .unwrap_or_else(|| array_out_of_bounds()),\n            )\n        }\n    }\n}","impl<S, D> ArrayBase<S, D>\nwhere\n    S: RawData,\n    D: Dimension,\n{\n    pub(crate) fn layout_impl(&self) -> Layout {\n        Layout::new(if self.is_standard_layout() {\n            if self.ndim() <= 1 {\n                FORDER | CORDER\n            } else {\n                CORDER\n            }\n        } else if self.ndim() > 1 && self.raw_view().reversed_axes().is_standard_layout() {\n            FORDER\n        } else {\n            0\n        })\n    }\n}","impl<S, D> Eq for ArrayBase<S, D>\nwhere\n    D: Dimension,\n    S: Data,\n    S::Elem: Eq,\n{\n}","impl<S: RawDataClone + Copy, D: Copy> Copy for ArrayBase<S, D> {}","impl<S: RawDataClone, D: Clone> Clone for ArrayBase<S, D> {\n    fn clone(&self) -> ArrayBase<S, D> {\n        unsafe {\n            let (data, ptr) = self.data.clone_with_ptr(self.ptr);\n            ArrayBase {\n                data,\n                ptr,\n                dim: self.dim.clone(),\n                strides: self.strides.clone(),\n            }\n        }\n    }\n\n    /// `Array` implements `.clone_from()` to reuse an array's existing\n    /// allocation. Semantically equivalent to `*self = other.clone()`, but\n    /// potentially more efficient.\n    fn clone_from(&mut self, other: &Self) {\n        unsafe {\n            self.ptr = self.data.clone_from_with_ptr(&other.data, other.ptr);\n            self.dim.clone_from(&other.dim);\n            self.strides.clone_from(&other.strides);\n        }\n    }\n}","unsafe impl<S, D> Send for ArrayBase<S, D>\nwhere\n    S: Send + Data,\n    D: Send,\n{\n}","unsafe impl<S, D> Sync for ArrayBase<S, D>\nwhere\n    S: Sync + Data,\n    D: Sync,\n{\n}"],"ArrayView":["impl<'a, A, D, E> Broadcast<E> for ArrayView<'a, A, D>\nwhere\n    E: IntoDimension,\n    D: Dimension,\n{\n    type Output = ArrayView<'a, A, E::Dim>;\n    fn broadcast_unwrap(self, shape: E) -> Self::Output {\n        let res: ArrayView<'_, A, E::Dim> = (&self).broadcast_unwrap(shape.into_dimension());\n        unsafe { ArrayView::new(res.ptr, res.dim, res.strides) }\n    }\n    private_impl! {}\n}","impl<'a, A, D: Dimension> NdProducer for ArrayView<'a, A, D> {\n    type Item = &'a A;\n    type Dim = D;\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    private_impl! {}\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        self.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn equal_dim(&self, dim: &Self::Dim) -> bool {\n        self.dim.equal(dim)\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.as_ptr() as _\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.layout_impl()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: *mut A) -> Self::Item {\n        &*ptr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.stride_of(axis)\n    }\n\n    #[inline(always)]\n    fn contiguous_stride(&self) -> Self::Stride {\n        1\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        self.split_at(axis, index)\n    }\n}","impl<'a, A, D> ArrayView<'a, A, D>\nwhere\n    D: Dimension,\n{\n    #[inline]\n    pub(crate) fn into_base_iter(self) -> Baseiter<A, D> {\n        unsafe { Baseiter::new(self.ptr.as_ptr(), self.dim, self.strides) }\n    }\n\n    #[inline]\n    pub(crate) fn into_elements_base(self) -> ElementsBase<'a, A, D> {\n        ElementsBase::new(self)\n    }\n\n    pub(crate) fn into_iter_(self) -> Iter<'a, A, D> {\n        Iter::new(self)\n    }\n\n    /// Return an outer iterator for this view.\n    #[doc(hidden)] // not official\n    #[deprecated(note = \"This method will be replaced.\")]\n    pub fn into_outer_iter(self) -> iter::AxisIter<'a, A, D::Smaller>\n    where\n        D: RemoveAxis,\n    {\n        AxisIter::new(self, Axis(0))\n    }\n}","impl<'a, A, D> ArrayView<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Convert the view into an `ArrayView<'b, A, D>` where `'b` is a lifetime\n    /// outlived by `'a'`.\n    pub fn reborrow<'b>(self) -> ArrayView<'b, A, D>\n    where\n        'a: 'b,\n    {\n        unsafe { ArrayView::new(self.ptr, self.dim, self.strides) }\n    }\n\n    /// Return the arrays data as a slice, if it is contiguous and in standard order.\n    /// Return `None` otherwise.\n    #[deprecated(note = \"`into_slice` has been renamed to `to_slice`\", since = \"0.13.0\")]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn into_slice(&self) -> Option<&'a [A]> {\n        if self.is_standard_layout() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }\n\n    /// Return the arrays data as a slice, if it is contiguous and in standard order.\n    /// Return `None` otherwise.\n    pub fn to_slice(&self) -> Option<&'a [A]> {\n        if self.is_standard_layout() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }\n\n    /// Converts to a raw array view.\n    pub(crate) fn into_raw_view(self) -> RawArrayView<A, D> {\n        unsafe { RawArrayView::new(self.ptr, self.dim, self.strides) }\n    }\n}","impl<'a, A, D> ArrayView<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Create a new `ArrayView`\n    ///\n    /// Unsafe because: `ptr` must be valid for the given dimension and strides.\n    #[inline(always)]\n    pub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self {\n        if cfg!(debug_assertions) {\n            assert!(is_aligned(ptr.as_ptr()), \"The pointer must be aligned.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        ArrayView {\n            data: ViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }\n\n    /// Unsafe because: `ptr` must be valid for the given dimension and strides.\n    #[inline]\n    pub(crate) unsafe fn new_(ptr: *const A, dim: D, strides: D) -> Self {\n        Self::new(nonnull_debug_checked_from_ptr(ptr as *mut A), dim, strides)\n    }\n}","impl<'a, A, D> ArrayView<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Create a read-only array view borrowing its data from a slice.\n    ///\n    /// Checks whether `shape` are compatible with the slice's\n    /// length, returning an `Err` if not compatible.\n    ///\n    /// ```\n    /// use ndarray::ArrayView;\n    /// use ndarray::arr3;\n    /// use ndarray::ShapeBuilder;\n    ///\n    /// let s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    /// let a = ArrayView::from_shape((2, 3, 2).strides((1, 4, 2)),\n    ///                               &s).unwrap();\n    ///\n    /// assert!(\n    ///     a == arr3(&[[[0, 2],\n    ///                  [4, 6],\n    ///                  [8, 10]],\n    ///                 [[1, 3],\n    ///                  [5, 7],\n    ///                  [9, 11]]])\n    /// );\n    /// assert!(a.strides() == &[1, 4, 2]);\n    /// ```\n    pub fn from_shape<Sh>(shape: Sh, xs: &'a [A]) -> Result<Self, ShapeError>\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        // eliminate the type parameter Sh as soon as possible\n        Self::from_shape_impl(shape.into(), xs)\n    }\n\n    fn from_shape_impl(shape: StrideShape<D>, xs: &'a [A]) -> Result<Self, ShapeError> {\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if shape.custom {\n            dimension::can_index_slice(xs, &dim, &strides)?;\n        } else {\n            dimension::can_index_slice_not_custom::<A, _>(xs, &dim)?;\n        }\n        unsafe { Ok(Self::new_(xs.as_ptr(), dim, strides)) }\n    }\n\n    /// Create an `ArrayView<A, D>` from shape information and a raw pointer to\n    /// the elements.\n    ///\n    /// # Safety\n    ///\n    /// The caller is responsible for ensuring all of the following:\n    ///\n    /// * The elements seen by moving `ptr` according to the shape and strides\n    ///   must live at least as long as `'a` and must not be not mutably\n    ///   aliased for the duration of `'a`.\n    ///\n    /// * `ptr` must be non-null and aligned, and it must be safe to\n    ///   [`.offset()`] `ptr` by zero.\n    ///\n    /// * It must be safe to [`.offset()`] the pointer repeatedly along all\n    ///   axes and calculate the `count`s for the `.offset()` calls without\n    ///   overflow, even if the array is empty or the elements are zero-sized.\n    ///\n    ///   In other words,\n    ///\n    ///   * All possible pointers generated by moving along all axes must be in\n    ///     bounds or one byte past the end of a single allocation with element\n    ///     type `A`. The only exceptions are if the array is empty or the element\n    ///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n    ///     still be safe to [`.offset()`] the pointer along the axes.\n    ///\n    ///   * The offset in units of bytes between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents the computed offset, in bytes, from overflowing\n    ///     `isize` regardless of the starting point due to past offsets.\n    ///\n    ///   * The offset in units of `A` between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents overflow when calculating the `count` parameter to\n    ///     [`.offset()`] regardless of the starting point due to past offsets.\n    ///\n    /// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n    ///\n    /// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\n    pub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *const A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        RawArrayView::from_shape_ptr(shape, ptr).deref_into_view()\n    }\n}","impl<'a, A, D> ArrayView<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Split the array view along `axis` and return one view strictly before the\n    /// split and one view after the split.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    ///\n    /// **Examples:**\n    /// ```rust\n    /// # use ndarray::prelude::*;\n    /// let a = aview2(&[[0, 1, 2, 3],\n    ///                  [4, 5, 6, 7],\n    ///                  [8, 9, 0, 1]]);\n    ///\n    /// ```\n    /// The array view `a` has two axes and shape 3  4:\n    /// ```text\n    ///           Axis(1)\n    ///          0\n    ///         a  a  a  a \n    ///         1\n    ///  Axis(0) a  a  a  a \n    ///          2\n    ///          a  a  a  a \n    ///          3 \n    ///         0     1     2     3     4  possible split_at indices.\n    /// ```\n    ///\n    /// Row indices increase along `Axis(0)`, and column indices increase along\n    /// `Axis(1)`. Note that we split before an element index, and that\n    /// both 0 and the endpoint are valid split indices.\n    ///\n    /// **Example 1**: Split `a` along the first axis, in this case the rows, at\n    /// index 2.<br>\n    /// This produces views v1 and v2 of shapes 2  4 and 1  4:\n    ///\n    /// ```rust\n    /// # use ndarray::prelude::*;\n    /// # let a = aview2(&[[0; 4]; 3]);\n    /// let (v1, v2) = a.split_at(Axis(0), 1);\n    /// ```\n    /// ```text\n    ///                0   indices\n    ///          a  a  a  a             along Axis(0)\n    ///          v1    1\n    ///          a  a  a  a \n    ///         \n    ///                2\n    ///         \n    ///          a  a  a  a  v2\n    ///                3\n    /// ```\n    ///\n    /// **Example 2**: Split `a` along the second axis, in this case the\n    /// columns, at index 2.<br>\n    /// This produces views u1 and u2 of shapes 3 2 and 3  2:\n    ///\n    /// ```rust\n    /// # use ndarray::prelude::*;\n    /// # let a = aview2(&[[0; 4]; 3]);\n    /// let (u1, u2) = a.split_at(Axis(1), 2);\n    ///\n    /// ```\n    /// ```text\n    ///              u1             u2\n    ///         \n    ///          a  a  a  a \n    ///         \n    ///          a  a  a  a \n    ///         \n    ///          a  a  a  a \n    ///         \n    ///         0     1      2      3     4  indices \n    ///                                      along Axis(1)\n    /// ```\n    pub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self) {\n        unsafe {\n            let (left, right) = self.into_raw_view().split_at(axis, index);\n            (left.deref_into_view(), right.deref_into_view())\n        }\n    }\n}","impl<'a, A, D> IntoIterator for ArrayView<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = &'a A;\n    type IntoIter = Iter<'a, A, D>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.into_iter_()\n    }\n}","impl<'a, A, S, D> From<&'a ArrayBase<S, D>> for ArrayView<'a, A, D>\nwhere\n    S: Data<Elem = A>,\n    D: Dimension,\n{\n    /// Create a read-only array view of the array.\n    fn from(array: &'a ArrayBase<S, D>) -> Self {\n        array.view()\n    }\n}","impl<'a, A, Slice: ?Sized> From<&'a Slice> for ArrayView<'a, A, Ix1>\nwhere\n    Slice: AsRef<[A]>,\n{\n    /// Create a one-dimensional read-only array view of the data in `slice`.\n    ///\n    /// **Panics** if the slice length is greater than `isize::MAX`.\n    fn from(slice: &'a Slice) -> Self {\n        let xs = slice.as_ref();\n        if mem::size_of::<A>() == 0 {\n            assert!(\n                xs.len() <= ::std::isize::MAX as usize,\n                \"Slice length must fit in `isize`.\",\n            );\n        }\n        unsafe { Self::from_shape_ptr(xs.len(), xs.as_ptr()) }\n    }\n}","impl<'a, A> ArrayView<'a, A, Ix0> {\n    /// Consume the view and return a reference to the single element in the array.\n    ///\n    /// The lifetime of the returned reference matches the lifetime of the data\n    /// the array view was pointing to.\n    ///\n    /// ```\n    /// use ndarray::{arr0, Array0};\n    ///\n    /// // `Foo` doesn't implement `Clone`.\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct Foo;\n    ///\n    /// let array: Array0<Foo> = arr0(Foo);\n    /// let view = array.view();\n    /// let scalar: &Foo = view.into_scalar();\n    /// assert_eq!(scalar, &Foo);\n    /// ```\n    pub fn into_scalar(self) -> &'a A {\n        self.index(Ix0())\n    }\n}"],"ArrayViewMut":["impl<'a, A, D: Dimension> NdProducer for ArrayViewMut<'a, A, D> {\n    type Item = &'a mut A;\n    type Dim = D;\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    private_impl! {}\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        self.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn equal_dim(&self, dim: &Self::Dim) -> bool {\n        self.dim.equal(dim)\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.as_ptr() as _\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.layout_impl()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: *mut A) -> Self::Item {\n        &mut *ptr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.stride_of(axis)\n    }\n\n    #[inline(always)]\n    fn contiguous_stride(&self) -> Self::Stride {\n        1\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        self.split_at(axis, index)\n    }\n}","impl<'a, A, D> ArrayViewMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    // Convert into a read-only view\n    pub(crate) fn into_view(self) -> ArrayView<'a, A, D> {\n        unsafe { ArrayView::new(self.ptr, self.dim, self.strides) }\n    }\n\n    /// Converts to a mutable raw array view.\n    pub(crate) fn into_raw_view_mut(self) -> RawArrayViewMut<A, D> {\n        unsafe { RawArrayViewMut::new(self.ptr, self.dim, self.strides) }\n    }\n\n    #[inline]\n    pub(crate) fn into_base_iter(self) -> Baseiter<A, D> {\n        unsafe { Baseiter::new(self.ptr.as_ptr(), self.dim, self.strides) }\n    }\n\n    #[inline]\n    pub(crate) fn into_elements_base(self) -> ElementsBaseMut<'a, A, D> {\n        ElementsBaseMut::new(self)\n    }\n\n    pub(crate) fn into_slice_(self) -> Result<&'a mut [A], Self> {\n        if self.is_standard_layout() {\n            unsafe { Ok(slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())) }\n        } else {\n            Err(self)\n        }\n    }\n\n    pub(crate) fn into_iter_(self) -> IterMut<'a, A, D> {\n        IterMut::new(self)\n    }\n\n    /// Return an outer iterator for this view.\n    #[doc(hidden)] // not official\n    #[deprecated(note = \"This method will be replaced.\")]\n    pub fn into_outer_iter(self) -> iter::AxisIterMut<'a, A, D::Smaller>\n    where\n        D: RemoveAxis,\n    {\n        AxisIterMut::new(self, Axis(0))\n    }\n}","impl<'a, A, D> ArrayViewMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Create a new `ArrayView`\n    ///\n    /// Unsafe because: `ptr` must be valid for the given dimension and strides.\n    #[inline(always)]\n    pub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self {\n        if cfg!(debug_assertions) {\n            assert!(is_aligned(ptr.as_ptr()), \"The pointer must be aligned.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        ArrayViewMut {\n            data: ViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }\n\n    /// Create a new `ArrayView`\n    ///\n    /// Unsafe because: `ptr` must be valid for the given dimension and strides.\n    #[inline(always)]\n    pub(crate) unsafe fn new_(ptr: *mut A, dim: D, strides: D) -> Self {\n        Self::new(nonnull_debug_checked_from_ptr(ptr), dim, strides)\n    }\n}","impl<'a, A, D> ArrayViewMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Create a read-write array view borrowing its data from a slice.\n    ///\n    /// Checks whether `dim` and `strides` are compatible with the slice's\n    /// length, returning an `Err` if not compatible.\n    ///\n    /// ```\n    /// use ndarray::ArrayViewMut;\n    /// use ndarray::arr3;\n    /// use ndarray::ShapeBuilder;\n    ///\n    /// let mut s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    /// let mut a = ArrayViewMut::from_shape((2, 3, 2).strides((1, 4, 2)),\n    ///                                      &mut s).unwrap();\n    ///\n    /// a[[0, 0, 0]] = 1;\n    /// assert!(\n    ///     a == arr3(&[[[1, 2],\n    ///                  [4, 6],\n    ///                  [8, 10]],\n    ///                 [[1, 3],\n    ///                  [5, 7],\n    ///                  [9, 11]]])\n    /// );\n    /// assert!(a.strides() == &[1, 4, 2]);\n    /// ```\n    pub fn from_shape<Sh>(shape: Sh, xs: &'a mut [A]) -> Result<Self, ShapeError>\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        // eliminate the type parameter Sh as soon as possible\n        Self::from_shape_impl(shape.into(), xs)\n    }\n\n    fn from_shape_impl(shape: StrideShape<D>, xs: &'a mut [A]) -> Result<Self, ShapeError> {\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if shape.custom {\n            dimension::can_index_slice(xs, &dim, &strides)?;\n        } else {\n            dimension::can_index_slice_not_custom::<A, _>(xs, &dim)?;\n        }\n        unsafe { Ok(Self::new_(xs.as_mut_ptr(), dim, strides)) }\n    }\n\n    /// Create an `ArrayViewMut<A, D>` from shape information and a\n    /// raw pointer to the elements.\n    ///\n    /// # Safety\n    ///\n    /// The caller is responsible for ensuring all of the following:\n    ///\n    /// * The elements seen by moving `ptr` according to the shape and strides\n    ///   must live at least as long as `'a` and must not be aliased for the\n    ///   duration of `'a`.\n    ///\n    /// * `ptr` must be non-null and aligned, and it must be safe to\n    ///   [`.offset()`] `ptr` by zero.\n    ///\n    /// * It must be safe to [`.offset()`] the pointer repeatedly along all\n    ///   axes and calculate the `count`s for the `.offset()` calls without\n    ///   overflow, even if the array is empty or the elements are zero-sized.\n    ///\n    ///   In other words,\n    ///\n    ///   * All possible pointers generated by moving along all axes must be in\n    ///     bounds or one byte past the end of a single allocation with element\n    ///     type `A`. The only exceptions are if the array is empty or the element\n    ///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n    ///     still be safe to [`.offset()`] the pointer along the axes.\n    ///\n    ///   * The offset in units of bytes between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents the computed offset, in bytes, from overflowing\n    ///     `isize` regardless of the starting point due to past offsets.\n    ///\n    ///   * The offset in units of `A` between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents overflow when calculating the `count` parameter to\n    ///     [`.offset()`] regardless of the starting point due to past offsets.\n    ///\n    /// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n    ///\n    /// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\n    pub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *mut A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        RawArrayViewMut::from_shape_ptr(shape, ptr).deref_into_view_mut()\n    }\n\n    /// Convert the view into an `ArrayViewMut<'b, A, D>` where `'b` is a lifetime\n    /// outlived by `'a'`.\n    pub fn reborrow<'b>(self) -> ArrayViewMut<'b, A, D>\n    where\n        'a: 'b,\n    {\n        unsafe { ArrayViewMut::new(self.ptr, self.dim, self.strides) }\n    }\n}","impl<'a, A, D> ArrayViewMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Return the arrays data as a slice, if it is contiguous and in standard order.\n    /// Return `None` otherwise.\n    pub fn into_slice(self) -> Option<&'a mut [A]> {\n        self.into_slice_().ok()\n    }\n}","impl<'a, A, D> ArrayViewMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Split the array view along `axis` and return one mutable view strictly\n    /// before the split and one mutable view after the split.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    pub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self) {\n        unsafe {\n            let (left, right) = self.into_raw_view_mut().split_at(axis, index);\n            (left.deref_into_view_mut(), right.deref_into_view_mut())\n        }\n    }\n\n    /// Split the view into multiple disjoint slices.\n    ///\n    /// This is similar to [`.multi_slice_mut()`], but `.multi_slice_move()`\n    /// consumes `self` and produces views with lifetimes matching that of\n    /// `self`.\n    ///\n    /// See [*Slicing*](#slicing) for full documentation.\n    /// See also [`SliceInfo`] and [`D::SliceArg`].\n    ///\n    /// [`.multi_slice_mut()`]: struct.ArrayBase.html#method.multi_slice_mut\n    /// [`SliceInfo`]: struct.SliceInfo.html\n    /// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n    ///\n    /// **Panics** if any of the following occur:\n    ///\n    /// * if any of the views would intersect (i.e. if any element would appear in multiple slices)\n    /// * if an index is out of bounds or step size is zero\n    /// * if `D` is `IxDyn` and `info` does not match the number of array axes\n    pub fn multi_slice_move<M>(self, info: M) -> M::Output\n    where\n        M: MultiSlice<'a, A, D>,\n    {\n        info.multi_slice_move(self)\n    }\n}","impl<'a, A, D> IntoIterator for ArrayViewMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = &'a mut A;\n    type IntoIter = IterMut<'a, A, D>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.into_iter_()\n    }\n}","impl<'a, A, S, D> From<&'a mut ArrayBase<S, D>> for ArrayViewMut<'a, A, D>\nwhere\n    S: DataMut<Elem = A>,\n    D: Dimension,\n{\n    /// Create a read-write array view of the array.\n    fn from(array: &'a mut ArrayBase<S, D>) -> Self {\n        array.view_mut()\n    }\n}","impl<'a, A, Slice: ?Sized> From<&'a mut Slice> for ArrayViewMut<'a, A, Ix1>\nwhere\n    Slice: AsMut<[A]>,\n{\n    /// Create a one-dimensional read-write array view of the data in `slice`.\n    ///\n    /// **Panics** if the slice length is greater than `isize::MAX`.\n    fn from(slice: &'a mut Slice) -> Self {\n        let xs = slice.as_mut();\n        if mem::size_of::<A>() == 0 {\n            assert!(\n                xs.len() <= ::std::isize::MAX as usize,\n                \"Slice length must fit in `isize`.\",\n            );\n        }\n        unsafe { Self::from_shape_ptr(xs.len(), xs.as_mut_ptr()) }\n    }\n}","impl<'a, A> ArrayViewMut<'a, A, Ix0> {\n    /// Consume the mutable view and return a mutable reference to the single element in the array.\n    ///\n    /// The lifetime of the returned reference matches the lifetime of the data\n    /// the array view was pointing to.\n    ///\n    /// ```\n    /// use ndarray::{arr0, Array0};\n    ///\n    /// let mut array: Array0<f64> = arr0(5.);\n    /// let view = array.view_mut();\n    /// let mut scalar = view.into_scalar();\n    /// *scalar = 7.;\n    /// assert_eq!(scalar, &7.);\n    /// assert_eq!(array[()], 7.);\n    /// ```\n    pub fn into_scalar(self) -> &'a mut A {\n        self.index(Ix0())\n    }\n}","impl<'a, I, A, D> IndexLonger<I> for ArrayViewMut<'a, A, D>\nwhere\n    I: NdIndex<D>,\n    D: Dimension,\n{\n    type Output = &'a mut A;\n\n    /// Convert a mutable array view to a mutable reference of a element.\n    ///\n    /// This method is like `IndexMut::index_mut` but with a longer lifetime\n    /// (matching the array view); which we can only do for the array view and\n    /// not in the `Index` trait.\n    ///\n    /// See also [the `get_mut` method][1] which works for all arrays and array\n    /// views.\n    ///\n    /// [1]: struct.ArrayBase.html#method.get_mut\n    ///\n    /// **Panics** if index is out of bounds.\n    fn index(mut self, index: I) -> &'a mut A {\n        debug_bounds_check!(self, index);\n        unsafe {\n            match self.get_ptr_mut(index) {\n                Some(ptr) => &mut *ptr,\n                None => array_out_of_bounds(),\n            }\n        }\n    }\n\n    /// Convert a mutable array view to a mutable reference of a element, with\n    /// checked access.\n    ///\n    /// See also [the `get_mut` method][1] which works for all arrays and array\n    /// views.\n    ///\n    /// [1]: struct.ArrayBase.html#method.get_mut\n    ///\n    fn get(mut self, index: I) -> Option<&'a mut A> {\n        debug_bounds_check!(self, index);\n        unsafe {\n            match self.get_ptr_mut(index) {\n                Some(ptr) => Some(&mut *ptr),\n                None => None,\n            }\n        }\n    }\n\n    /// Convert a mutable array view to a mutable reference of a element without\n    /// boundary check.\n    ///\n    /// See also [the `uget_mut` method][1] which works for all arrays and array\n    /// views.\n    ///\n    /// [1]: struct.ArrayBase.html#method.uget_mut\n    ///\n    /// **Note:** only unchecked for non-debug builds of ndarray.\n    unsafe fn uget(mut self, index: I) -> &'a mut A {\n        debug_bounds_check!(self, index);\n        &mut *self\n            .as_mut_ptr()\n            .offset(index.index_unchecked(&self.strides))\n    }\n}"],"CowArray":["impl<'a, A, D> CowArray<'a, A, D>\nwhere\n    D: Dimension,\n{\n    /// Returns `true` iff the array is the view (borrowed) variant.\n    pub fn is_view(&self) -> bool {\n        self.data.is_view()\n    }\n\n    /// Returns `true` iff the array is the owned variant.\n    pub fn is_owned(&self) -> bool {\n        self.data.is_owned()\n    }\n}","impl<'a, A, D> From<Array<A, D>> for CowArray<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn from(array: Array<A, D>) -> CowArray<'a, A, D> {\n        ArrayBase {\n            data: CowRepr::Owned(array.data),\n            ptr: array.ptr,\n            dim: array.dim,\n            strides: array.strides,\n        }\n    }\n}","impl<'a, A, D> From<ArrayView<'a, A, D>> for CowArray<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn from(view: ArrayView<'a, A, D>) -> CowArray<'a, A, D> {\n        ArrayBase {\n            data: CowRepr::View(view.data),\n            ptr: view.ptr,\n            dim: view.dim,\n            strides: view.strides,\n        }\n    }\n}"],"CowRepr":["impl<'a, A> CowRepr<'a, A> {\n    /// Returns `true` iff the data is the `View` variant.\n    pub fn is_view(&self) -> bool {\n        match self {\n            CowRepr::View(_) => true,\n            CowRepr::Owned(_) => false,\n        }\n    }\n\n    /// Returns `true` iff the data is the `Owned` variant.\n    pub fn is_owned(&self) -> bool {\n        match self {\n            CowRepr::View(_) => false,\n            CowRepr::Owned(_) => true,\n        }\n    }\n}","unsafe impl<'a, A> Data for CowRepr<'a, A> {\n    #[inline]\n    fn into_owned<D>(self_: ArrayBase<CowRepr<'a, A>, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        A: Clone,\n        D: Dimension,\n    {\n        match self_.data {\n            CowRepr::View(_) => self_.to_owned(),\n            CowRepr::Owned(data) => ArrayBase {\n                data,\n                ptr: self_.ptr,\n                dim: self_.dim,\n                strides: self_.strides,\n            },\n        }\n    }\n}","unsafe impl<'a, A> DataMut for CowRepr<'a, A> where A: Clone {}","unsafe impl<'a, A> RawData for CowRepr<'a, A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        match self {\n            CowRepr::View(view) => view._data_slice(),\n            CowRepr::Owned(data) => data._data_slice(),\n        }\n    }\n    private_impl! {}\n}","unsafe impl<'a, A> RawDataClone for CowRepr<'a, A>\nwhere\n    A: Clone,\n{\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>) {\n        match self {\n            CowRepr::View(view) => {\n                let (new_view, ptr) = view.clone_with_ptr(ptr);\n                (CowRepr::View(new_view), ptr)\n            }\n            CowRepr::Owned(data) => {\n                let (new_data, ptr) = data.clone_with_ptr(ptr);\n                (CowRepr::Owned(new_data), ptr)\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn clone_from_with_ptr(\n        &mut self,\n        other: &Self,\n        ptr: NonNull<Self::Elem>,\n    ) -> NonNull<Self::Elem> {\n        match (&mut *self, other) {\n            (CowRepr::View(self_), CowRepr::View(other)) => self_.clone_from_with_ptr(other, ptr),\n            (CowRepr::Owned(self_), CowRepr::Owned(other)) => self_.clone_from_with_ptr(other, ptr),\n            (_, CowRepr::Owned(other)) => {\n                let (cloned, ptr) = other.clone_with_ptr(ptr);\n                *self = CowRepr::Owned(cloned);\n                ptr\n            }\n            (_, CowRepr::View(other)) => {\n                let (cloned, ptr) = other.clone_with_ptr(ptr);\n                *self = CowRepr::View(cloned);\n                ptr\n            }\n        }\n    }\n}","unsafe impl<'a, A> RawDataMut for CowRepr<'a, A>\nwhere\n    A: Clone,\n{\n    #[inline]\n    fn try_ensure_unique<D>(array: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,\n    {\n        match array.data {\n            CowRepr::View(_) => {\n                let owned = array.to_owned();\n                array.data = CowRepr::Owned(owned.data);\n                array.ptr = owned.ptr;\n                array.dim = owned.dim;\n                array.strides = owned.strides;\n            }\n            CowRepr::Owned(_) => {}\n        }\n    }\n\n    #[inline]\n    fn try_is_unique(&mut self) -> Option<bool> {\n        Some(self.is_owned())\n    }\n}"],"Ix":["impl IntoDimension for Ix {\n    type Dim = Ix1;\n    #[inline(always)]\n    fn into_dimension(self) -> Ix1 {\n        Ix1(self)\n    }\n}","unsafe impl NdIndex<Ix1> for Ix {\n    #[inline]\n    fn index_checked(&self, dim: &Ix1, strides: &Ix1) -> Option<isize> {\n        dim.stride_offset_checked(strides, &Ix1(*self))\n    }\n    #[inline(always)]\n    fn index_unchecked(&self, strides: &Ix1) -> isize {\n        stride_offset(*self, get!(strides, 0))\n    }\n}","unsafe impl NdIndex<IxDyn> for Ix {\n    #[inline]\n    fn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize> {\n        debug_assert_eq!(dim.ndim(), 1);\n        stride_offset_checked(dim.ix(), strides.ix(), &[*self])\n    }\n    #[inline(always)]\n    fn index_unchecked(&self, strides: &IxDyn) -> isize {\n        debug_assert_eq!(strides.ndim(), 1);\n        stride_offset(*self, get!(strides, 0))\n    }\n}"],"OwnedArcRepr":["Debug","impl<A, B> RawDataSubst<B> for OwnedArcRepr<A> {\n    type Output = OwnedArcRepr<B>;\n}","impl<A> Clone for OwnedArcRepr<A> {\n    fn clone(&self) -> Self {\n        OwnedArcRepr(self.0.clone())\n    }\n}","unsafe impl<A> Data for OwnedArcRepr<A> {\n    fn into_owned<D>(mut self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        A: Clone,\n        D: Dimension,\n    {\n        Self::ensure_unique(&mut self_);\n        let data = Arc::try_unwrap(self_.data.0).ok().unwrap();\n        ArrayBase {\n            data,\n            ptr: self_.ptr,\n            dim: self_.dim,\n            strides: self_.strides,\n        }\n    }\n}","unsafe impl<A> DataMut for OwnedArcRepr<A> where A: Clone {}","unsafe impl<A> DataOwned for OwnedArcRepr<A> {\n    fn new(elements: Vec<A>) -> Self {\n        OwnedArcRepr(Arc::new(OwnedRepr::from(elements)))\n    }\n\n    fn into_shared(self) -> OwnedRcRepr<A> {\n        self\n    }\n}","unsafe impl<A> DataShared for OwnedRcRepr<A> {}","unsafe impl<A> RawData for OwnedArcRepr<A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        Some(self.0.as_slice())\n    }\n    private_impl! {}\n}","unsafe impl<A> RawDataClone for OwnedArcRepr<A> {\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>) {\n        // pointer is preserved\n        (self.clone(), ptr)\n    }\n}","unsafe impl<A> RawDataMut for OwnedArcRepr<A>\nwhere\n    A: Clone,\n{\n    fn try_ensure_unique<D>(self_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,\n    {\n        if Arc::get_mut(&mut self_.data.0).is_some() {\n            return;\n        }\n        if self_.dim.size() <= self_.data.0.len() / 2 {\n            // Create a new vec if the current view is less than half of\n            // backing data.\n            unsafe {\n                *self_ = ArrayBase::from_shape_vec_unchecked(\n                    self_.dim.clone(),\n                    self_.iter().cloned().collect(),\n                );\n            }\n            return;\n        }\n        let rcvec = &mut self_.data.0;\n        let a_size = mem::size_of::<A>() as isize;\n        let our_off = if a_size != 0 {\n            (self_.ptr.as_ptr() as isize - rcvec.as_ptr() as isize) / a_size\n        } else {\n            0\n        };\n        let rvec = Arc::make_mut(rcvec);\n        unsafe {\n            self_.ptr = rvec.as_nonnull_mut().offset(our_off);\n        }\n    }\n\n    fn try_is_unique(&mut self) -> Option<bool> {\n        Some(Arc::get_mut(&mut self.0).is_some())\n    }\n}"],"RawArrayView":["impl<A, D: Dimension> NdProducer for RawArrayView<A, D> {\n    type Item = *const A;\n    type Dim = D;\n    type Ptr = *const A;\n    type Stride = isize;\n\n    private_impl! {}\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        self.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn equal_dim(&self, dim: &Self::Dim) -> bool {\n        self.dim.equal(dim)\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *const A {\n        self.as_ptr()\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.layout_impl()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: *const A) -> *const A {\n        ptr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *const A {\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.stride_of(axis)\n    }\n\n    #[inline(always)]\n    fn contiguous_stride(&self) -> Self::Stride {\n        1\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        self.split_at(axis, index)\n    }\n}","impl<A, D> RawArrayView<A, D>\nwhere\n    D: Dimension,\n{\n    /// Create a new `RawArrayView`.\n    ///\n    /// Unsafe because caller is responsible for ensuring that the array will\n    /// meet all of the invariants of the `ArrayBase` type.\n    #[inline]\n    pub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self {\n        RawArrayView {\n            data: RawViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }\n\n    unsafe fn new_(ptr: *const A, dim: D, strides: D) -> Self {\n        Self::new(nonnull_debug_checked_from_ptr(ptr as *mut A), dim, strides)\n    }\n\n    /// Create an `RawArrayView<A, D>` from shape information and a raw pointer\n    /// to the elements.\n    ///\n    /// # Safety\n    ///\n    /// The caller is responsible for ensuring all of the following:\n    ///\n    /// * `ptr` must be non-null, and it must be safe to [`.offset()`] `ptr` by\n    ///   zero.\n    ///\n    /// * It must be safe to [`.offset()`] the pointer repeatedly along all\n    ///   axes and calculate the `count`s for the `.offset()` calls without\n    ///   overflow, even if the array is empty or the elements are zero-sized.\n    ///\n    ///   In other words,\n    ///\n    ///   * All possible pointers generated by moving along all axes must be in\n    ///     bounds or one byte past the end of a single allocation with element\n    ///     type `A`. The only exceptions are if the array is empty or the element\n    ///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n    ///     still be safe to [`.offset()`] the pointer along the axes.\n    ///\n    ///   * The offset in units of bytes between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents the computed offset, in bytes, from overflowing\n    ///     `isize` regardless of the starting point due to past offsets.\n    ///\n    ///   * The offset in units of `A` between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents overflow when calculating the `count` parameter to\n    ///     [`.offset()`] regardless of the starting point due to past offsets.\n    ///\n    /// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n    ///\n    /// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\n    pub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *const A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        let shape = shape.into();\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if cfg!(debug_assertions) {\n            assert!(!ptr.is_null(), \"The pointer must be non-null.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        RawArrayView::new_(ptr, dim, strides)\n    }\n\n    /// Converts to a read-only view of the array.\n    ///\n    /// # Safety\n    ///\n    /// From a safety standpoint, this is equivalent to dereferencing a raw\n    /// pointer for every element in the array. You must ensure that all of the\n    /// data is valid, ensure that the pointer is aligned, and choose the\n    /// correct lifetime.\n    #[inline]\n    pub unsafe fn deref_into_view<'a>(self) -> ArrayView<'a, A, D> {\n        debug_assert!(\n            is_aligned(self.ptr.as_ptr()),\n            \"The pointer must be aligned.\"\n        );\n        ArrayView::new(self.ptr, self.dim, self.strides)\n    }\n\n    /// Split the array view along `axis` and return one array pointer strictly\n    /// before the split and one array pointer after the split.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    pub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self) {\n        assert!(index <= self.len_of(axis));\n        let left_ptr = self.ptr.as_ptr();\n        let right_ptr = if index == self.len_of(axis) {\n            self.ptr.as_ptr()\n        } else {\n            let offset = stride_offset(index, self.strides.axis(axis));\n            // The `.offset()` is safe due to the guarantees of `RawData`.\n            unsafe { self.ptr.as_ptr().offset(offset) }\n        };\n\n        let mut dim_left = self.dim.clone();\n        dim_left.set_axis(axis, index);\n        let left = unsafe { Self::new_(left_ptr, dim_left, self.strides.clone()) };\n\n        let mut dim_right = self.dim;\n        let right_len = dim_right.axis(axis) - index;\n        dim_right.set_axis(axis, right_len);\n        let right = unsafe { Self::new_(right_ptr, dim_right, self.strides) };\n\n        (left, right)\n    }\n\n    /// Cast the raw pointer of the raw array view to a different type\n    ///\n    /// **Panics** if element size is not compatible.\n    ///\n    /// Lack of panic does not imply it is a valid cast. The cast works the same\n    /// way as regular raw pointer casts.\n    ///\n    /// While this method is safe, for the same reason as regular raw pointer\n    /// casts are safe, access through the produced raw view is only possible\n    /// in an unsafe block or function.\n    pub fn cast<B>(self) -> RawArrayView<B, D> {\n        assert_eq!(\n            mem::size_of::<B>(),\n            mem::size_of::<A>(),\n            \"size mismatch in raw view cast\"\n        );\n        let ptr = self.ptr.cast::<B>();\n        unsafe { RawArrayView::new(ptr, self.dim, self.strides) }\n    }\n}"],"RawArrayViewMut":["impl<A, D: Dimension> NdProducer for RawArrayViewMut<A, D> {\n    type Item = *mut A;\n    type Dim = D;\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    private_impl! {}\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        self.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn equal_dim(&self, dim: &Self::Dim) -> bool {\n        self.dim.equal(dim)\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.as_ptr() as _\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.layout_impl()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: *mut A) -> *mut A {\n        ptr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.stride_of(axis)\n    }\n\n    #[inline(always)]\n    fn contiguous_stride(&self) -> Self::Stride {\n        1\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        self.split_at(axis, index)\n    }\n}","impl<A, D> RawArrayViewMut<A, D>\nwhere\n    D: Dimension,\n{\n    /// Create a new `RawArrayViewMut`.\n    ///\n    /// Unsafe because caller is responsible for ensuring that the array will\n    /// meet all of the invariants of the `ArrayBase` type.\n    #[inline]\n    pub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self {\n        RawArrayViewMut {\n            data: RawViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }\n\n    unsafe fn new_(ptr: *mut A, dim: D, strides: D) -> Self {\n        Self::new(nonnull_debug_checked_from_ptr(ptr), dim, strides)\n    }\n\n    /// Create an `RawArrayViewMut<A, D>` from shape information and a raw\n    /// pointer to the elements.\n    ///\n    /// # Safety\n    ///\n    /// The caller is responsible for ensuring all of the following:\n    ///\n    /// * `ptr` must be non-null, and it must be safe to [`.offset()`] `ptr` by\n    ///   zero.\n    ///\n    /// * It must be safe to [`.offset()`] the pointer repeatedly along all\n    ///   axes and calculate the `count`s for the `.offset()` calls without\n    ///   overflow, even if the array is empty or the elements are zero-sized.\n    ///\n    ///   In other words,\n    ///\n    ///   * All possible pointers generated by moving along all axes must be in\n    ///     bounds or one byte past the end of a single allocation with element\n    ///     type `A`. The only exceptions are if the array is empty or the element\n    ///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n    ///     still be safe to [`.offset()`] the pointer along the axes.\n    ///\n    ///   * The offset in units of bytes between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents the computed offset, in bytes, from overflowing\n    ///     `isize` regardless of the starting point due to past offsets.\n    ///\n    ///   * The offset in units of `A` between the least address and greatest\n    ///     address by moving along all axes must not exceed `isize::MAX`. This\n    ///     constraint prevents overflow when calculating the `count` parameter to\n    ///     [`.offset()`] regardless of the starting point due to past offsets.\n    ///\n    /// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n    ///\n    /// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\n    pub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *mut A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,\n    {\n        let shape = shape.into();\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if cfg!(debug_assertions) {\n            assert!(!ptr.is_null(), \"The pointer must be non-null.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        RawArrayViewMut::new_(ptr, dim, strides)\n    }\n\n    /// Converts to a non-mutable `RawArrayView`.\n    #[inline]\n    pub(crate) fn into_raw_view(self) -> RawArrayView<A, D> {\n        unsafe { RawArrayView::new(self.ptr, self.dim, self.strides) }\n    }\n\n    /// Converts to a read-only view of the array.\n    ///\n    /// # Safety\n    ///\n    /// From a safety standpoint, this is equivalent to dereferencing a raw\n    /// pointer for every element in the array. You must ensure that all of the\n    /// data is valid, ensure that the pointer is aligned, and choose the\n    /// correct lifetime.\n    #[inline]\n    pub unsafe fn deref_into_view<'a>(self) -> ArrayView<'a, A, D> {\n        debug_assert!(\n            is_aligned(self.ptr.as_ptr()),\n            \"The pointer must be aligned.\"\n        );\n        ArrayView::new(self.ptr, self.dim, self.strides)\n    }\n\n    /// Converts to a mutable view of the array.\n    ///\n    /// # Safety\n    ///\n    /// From a safety standpoint, this is equivalent to dereferencing a raw\n    /// pointer for every element in the array. You must ensure that all of the\n    /// data is valid, ensure that the pointer is aligned, and choose the\n    /// correct lifetime.\n    #[inline]\n    pub unsafe fn deref_into_view_mut<'a>(self) -> ArrayViewMut<'a, A, D> {\n        debug_assert!(\n            is_aligned(self.ptr.as_ptr()),\n            \"The pointer must be aligned.\"\n        );\n        ArrayViewMut::new(self.ptr, self.dim, self.strides)\n    }\n\n    /// Split the array view along `axis` and return one array pointer strictly\n    /// before the split and one array pointer after the split.\n    ///\n    /// **Panics** if `axis` or `index` is out of bounds.\n    pub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self) {\n        let (left, right) = self.into_raw_view().split_at(axis, index);\n        unsafe {\n            (\n                Self::new(left.ptr, left.dim, left.strides),\n                Self::new(right.ptr, right.dim, right.strides),\n            )\n        }\n    }\n\n    /// Cast the raw pointer of the raw array view to a different type\n    ///\n    /// **Panics** if element size is not compatible.\n    ///\n    /// Lack of panic does not imply it is a valid cast. The cast works the same\n    /// way as regular raw pointer casts.\n    ///\n    /// While this method is safe, for the same reason as regular raw pointer\n    /// casts are safe, access through the produced raw view is only possible\n    /// in an unsafe block or function.\n    pub fn cast<B>(self) -> RawArrayViewMut<B, D> {\n        assert_eq!(\n            mem::size_of::<B>(),\n            mem::size_of::<A>(),\n            \"size mismatch in raw view cast\"\n        );\n        let ptr = self.ptr.cast::<B>();\n        unsafe { RawArrayViewMut::new(ptr, self.dim, self.strides) }\n    }\n}"],"RawViewRepr":["Clone","Copy","impl<A, B> RawDataSubst<B> for RawViewRepr<*const A> {\n    type Output = RawViewRepr<*const B>;\n}","impl<A, B> RawDataSubst<B> for RawViewRepr<*mut A> {\n    type Output = RawViewRepr<*mut B>;\n}","impl<A> RawViewRepr<A> {\n    #[inline(always)]\n    fn new() -> Self {\n        RawViewRepr { ptr: PhantomData }\n    }\n}","unsafe impl<A> RawData for RawViewRepr<*const A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        None\n    }\n    private_impl! {}\n}","unsafe impl<A> RawData for RawViewRepr<*mut A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        None\n    }\n    private_impl! {}\n}","unsafe impl<A> RawDataClone for RawViewRepr<*const A> {\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>) {\n        (*self, ptr)\n    }\n}","unsafe impl<A> RawDataClone for RawViewRepr<*mut A> {\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>) {\n        (*self, ptr)\n    }\n}","unsafe impl<A> RawDataMut for RawViewRepr<*mut A> {\n    #[inline]\n    fn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,\n    {\n    }\n\n    #[inline]\n    fn try_is_unique(&mut self) -> Option<bool> {\n        None\n    }\n}"],"Shape":["Clone","Copy","Debug","impl<D> From<D> for Shape<D>\nwhere\n    D: Dimension,\n{\n    /// Create a `Shape` from `dimension`, using the default memory layout.\n    fn from(dimension: D) -> Shape<D> {\n        dimension.into_shape()\n    }\n}","impl<D> Shape<D>\nwhere\n    D: Dimension,\n{\n    // Return a reference to the dimension\n    //pub fn dimension(&self) -> &D { &self.dim }\n    /// Return the size of the shape in number of elements\n    pub fn size(&self) -> usize {\n        self.dim.size()\n    }\n}","impl<D> ShapeBuilder for Shape<D>\nwhere\n    D: Dimension,\n{\n    type Dim = D;\n    type Strides = D;\n    fn into_shape(self) -> Shape<D> {\n        self\n    }\n    fn f(self) -> Self {\n        self.set_f(true)\n    }\n    fn set_f(mut self, is_f: bool) -> Self {\n        self.is_c = !is_f;\n        self\n    }\n    fn strides(self, st: D) -> StrideShape<D> {\n        StrideShape {\n            dim: self.dim,\n            strides: st,\n            custom: true,\n        }\n    }\n}"],"StrideShape":["Clone","Copy","Debug","impl<T, D> From<T> for StrideShape<D>\nwhere\n    D: Dimension,\n    T: ShapeBuilder<Dim = D>,\n{\n    fn from(value: T) -> Self {\n        let shape = value.into_shape();\n        let d = shape.dim;\n        let st = if shape.is_c {\n            d.default_strides()\n        } else {\n            d.fortran_strides()\n        };\n        StrideShape {\n            strides: st,\n            dim: d,\n            custom: false,\n        }\n    }\n}"],"ViewRepr":["Clone","Copy","impl<'a, A: 'a, B: 'a> RawDataSubst<B> for ViewRepr<&'a A> {\n    type Output = ViewRepr<&'a B>;\n}","impl<'a, A: 'a, B: 'a> RawDataSubst<B> for ViewRepr<&'a mut A> {\n    type Output = ViewRepr<&'a mut B>;\n}","impl<A> ViewRepr<A> {\n    #[inline(always)]\n    fn new() -> Self {\n        ViewRepr { life: PhantomData }\n    }\n}","unsafe impl<'a, A> Data for ViewRepr<&'a A> {\n    fn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        Self::Elem: Clone,\n        D: Dimension,\n    {\n        self_.to_owned()\n    }\n}","unsafe impl<'a, A> Data for ViewRepr<&'a mut A> {\n    fn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        Self::Elem: Clone,\n        D: Dimension,\n    {\n        self_.to_owned()\n    }\n}","unsafe impl<'a, A> DataMut for ViewRepr<&'a mut A> {}","unsafe impl<'a, A> DataShared for ViewRepr<&'a A> {}","unsafe impl<'a, A> RawData for ViewRepr<&'a A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        None\n    }\n    private_impl! {}\n}","unsafe impl<'a, A> RawData for ViewRepr<&'a mut A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        None\n    }\n    private_impl! {}\n}","unsafe impl<'a, A> RawDataClone for ViewRepr<&'a A> {\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>) {\n        (*self, ptr)\n    }\n}","unsafe impl<'a, A> RawDataMut for ViewRepr<&'a mut A> {\n    #[inline]\n    fn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,\n    {\n    }\n\n    #[inline]\n    fn try_is_unique(&mut self) -> Option<bool> {\n        Some(true)\n    }\n}"],"aliases::Array2":["impl<A, V> From<Vec<V>> for Array2<A>\nwhere\n    V: FixedInitializer<Elem = A>,\n{\n    /// Converts the `Vec` of arrays to an owned 2-D array.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    fn from(mut xs: Vec<V>) -> Self {\n        let dim = Ix2(xs.len(), V::len());\n        let ptr = xs.as_mut_ptr();\n        let cap = xs.capacity();\n        let expand_len = dimension::size_of_shape_checked(&dim)\n            .expect(\"Product of non-zero axis lengths must not overflow isize.\");\n        forget(xs);\n        unsafe {\n            let v = if size_of::<A>() == 0 {\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_len)\n            } else if V::len() == 0 {\n                Vec::new()\n            } else {\n                // Guaranteed not to overflow in this case since A is non-ZST\n                // and Vec never allocates more than isize bytes.\n                let expand_cap = cap * V::len();\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_cap)\n            };\n            ArrayBase::from_shape_vec_unchecked(dim, v)\n        }\n    }\n}"],"aliases::Array3":["impl<A, V, U> From<Vec<V>> for Array3<A>\nwhere\n    V: FixedInitializer<Elem = U>,\n    U: FixedInitializer<Elem = A>,\n{\n    /// Converts the `Vec` of arrays to an owned 3-D array.\n    ///\n    /// **Panics** if the product of non-zero axis lengths overflows `isize`.\n    fn from(mut xs: Vec<V>) -> Self {\n        let dim = Ix3(xs.len(), V::len(), U::len());\n        let ptr = xs.as_mut_ptr();\n        let cap = xs.capacity();\n        let expand_len = dimension::size_of_shape_checked(&dim)\n            .expect(\"Product of non-zero axis lengths must not overflow isize.\");\n        forget(xs);\n        unsafe {\n            let v = if size_of::<A>() == 0 {\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_len)\n            } else if V::len() == 0 || U::len() == 0 {\n                Vec::new()\n            } else {\n                // Guaranteed not to overflow in this case since A is non-ZST\n                // and Vec never allocates more than isize bytes.\n                let expand_cap = cap * V::len() * U::len();\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_cap)\n            };\n            ArrayBase::from_shape_vec_unchecked(dim, v)\n        }\n    }\n}"],"aliases::IxDyn":["impl Dimension for IxDyn {\n    const NDIM: Option<usize> = None;\n    type SliceArg = [SliceOrIndex];\n    type Pattern = Self;\n    type Smaller = Self;\n    type Larger = Self;\n    #[inline]\n    fn ndim(&self) -> usize {\n        self.ix().len()\n    }\n    #[inline]\n    fn slice(&self) -> &[Ix] {\n        self.ix()\n    }\n    #[inline]\n    fn slice_mut(&mut self) -> &mut [Ix] {\n        self.ixm()\n    }\n    #[inline]\n    fn into_pattern(self) -> Self::Pattern {\n        self\n    }\n\n    #[inline]\n    fn zeros(ndim: usize) -> Self {\n        IxDyn::zeros(ndim)\n    }\n\n    #[inline]\n    fn insert_axis(&self, axis: Axis) -> Self::Larger {\n        debug_assert!(axis.index() <= self.ndim());\n        Dim::new(self.ix().insert(axis.index()))\n    }\n\n    #[inline]\n    fn try_remove_axis(&self, axis: Axis) -> Self::Smaller {\n        if self.ndim() > 0 {\n            self.remove_axis(axis)\n        } else {\n            self.clone()\n        }\n    }\n\n    fn from_dimension<D2: Dimension>(d: &D2) -> Option<Self> {\n        Some(IxDyn(d.slice()))\n    }\n    private_impl! {}\n}","impl IxDyn {\n    /// Create a new dimension value with `n` axes, all zeros\n    #[inline]\n    pub fn zeros(n: usize) -> IxDyn {\n        const ZEROS: &[usize] = &[0; 4];\n        if n <= ZEROS.len() {\n            Dim(&ZEROS[..n])\n        } else {\n            Dim(vec![0; n])\n        }\n    }\n}"],"arrayformat::FormatOptions":["Clone","Debug","impl FormatOptions {\n    pub(crate) fn default_for_array(nelem: usize, no_limit: bool) -> Self {\n        let default = Self {\n            axis_collapse_limit: AXIS_LIMIT_STACKED,\n            axis_collapse_limit_next_last: AXIS_LIMIT_COL,\n            axis_collapse_limit_last: AXIS_LIMIT_ROW,\n        };\n        default.set_no_limit(no_limit || nelem < ARRAY_MANY_ELEMENT_LIMIT)\n    }\n\n    fn set_no_limit(mut self, no_limit: bool) -> Self {\n        if no_limit {\n            self.axis_collapse_limit = std::usize::MAX;\n            self.axis_collapse_limit_next_last = std::usize::MAX;\n            self.axis_collapse_limit_last = std::usize::MAX;\n            self\n        } else {\n            self\n        }\n    }\n\n    /// Axis length collapse limit before ellipsizing, where `axis_rindex` is\n    /// the index of the axis from the back.\n    pub(crate) fn collapse_limit(&self, axis_rindex: usize) -> usize {\n        match axis_rindex {\n            0 => self.axis_collapse_limit_last,\n            1 => self.axis_collapse_limit_next_last,\n            _ => self.axis_collapse_limit,\n        }\n    }\n}"],"data_repr::OwnedRepr":["Debug","impl<A, B> RawDataSubst<B> for OwnedRepr<A> {\n    type Output = OwnedRepr<B>;\n}","impl<A> Clone for OwnedRepr<A>\n    where A: Clone\n{\n    fn clone(&self) -> Self {\n        Self::from(self.as_slice().to_owned())\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        let mut v = self.take_as_vec();\n        let other = other.as_slice();\n\n        if v.len() > other.len() {\n            v.truncate(other.len());\n        }\n        let (front, back) = other.split_at(v.len());\n        v.clone_from_slice(front);\n        v.extend_from_slice(back);\n        *self = Self::from(v);\n    }\n}","impl<A> Drop for OwnedRepr<A> {\n    fn drop(&mut self) {\n        if self.capacity > 0 {\n            // correct because: If the elements don't need dropping, an\n            // empty Vec is ok. Only the Vec's allocation needs dropping.\n            //\n            // implemented because: in some places in ndarray\n            // where A: Copy (hence does not need drop) we use uninitialized elements in\n            // vectors. Setting the length to 0 avoids that the vector tries to\n            // drop, slice or otherwise produce values of these elements.\n            // (The details of the validity letting this happen with nonzero len, are\n            // under discussion as of this writing.)\n            if !mem::needs_drop::<A>() {\n                self.len = 0;\n            }\n            // drop as a Vec.\n            self.take_as_vec();\n        }\n    }\n}","impl<A> OwnedRepr<A> {\n    pub(crate) fn from(v: Vec<A>) -> Self {\n        let mut v = ManuallyDrop::new(v);\n        let len = v.len();\n        let capacity = v.capacity();\n        let ptr = nonnull::nonnull_from_vec_data(&mut v);\n        Self {\n            ptr,\n            len,\n            capacity,\n        }\n    }\n\n    pub(crate) fn into_vec(self) -> Vec<A> {\n        ManuallyDrop::new(self).take_as_vec()\n    }\n\n    pub(crate) fn as_slice(&self) -> &[A] {\n        unsafe {\n            slice::from_raw_parts(self.ptr.as_ptr(), self.len)\n        }\n    }\n\n    pub(crate) fn len(&self) -> usize { self.len }\n\n    pub(crate) fn as_ptr(&self) -> *const A {\n        self.ptr.as_ptr()\n    }\n\n    pub(crate) fn as_nonnull_mut(&mut self) -> NonNull<A> {\n        self.ptr\n    }\n\n    fn take_as_vec(&mut self) -> Vec<A> {\n        let capacity = self.capacity;\n        let len = self.len;\n        self.len = 0;\n        self.capacity = 0;\n        unsafe {\n            Vec::from_raw_parts(self.ptr.as_ptr(), len, capacity)\n        }\n    }\n}","unsafe impl<A> Data for OwnedRepr<A> {\n    #[inline]\n    fn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        A: Clone,\n        D: Dimension,\n    {\n        self_\n    }\n}","unsafe impl<A> DataMut for OwnedRepr<A> {}","unsafe impl<A> DataOwned for OwnedRepr<A> {\n    fn new(elements: Vec<A>) -> Self {\n        OwnedRepr::from(elements)\n    }\n    fn into_shared(self) -> OwnedRcRepr<A> {\n        OwnedArcRepr(Arc::new(self))\n    }\n}","unsafe impl<A> RawData for OwnedRepr<A> {\n    type Elem = A;\n    fn _data_slice(&self) -> Option<&[A]> {\n        Some(self.as_slice())\n    }\n    private_impl! {}\n}","unsafe impl<A> RawDataClone for OwnedRepr<A>\nwhere\n    A: Clone,\n{\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>) {\n        let mut u = self.clone();\n        let mut new_ptr = u.as_nonnull_mut();\n        if size_of::<A>() != 0 {\n            let our_off =\n                (ptr.as_ptr() as isize - self.as_ptr() as isize) / mem::size_of::<A>() as isize;\n            new_ptr = new_ptr.offset(our_off);\n        }\n        (u, new_ptr)\n    }\n\n    unsafe fn clone_from_with_ptr(\n        &mut self,\n        other: &Self,\n        ptr: NonNull<Self::Elem>,\n    ) -> NonNull<Self::Elem> {\n        let our_off = if size_of::<A>() != 0 {\n            (ptr.as_ptr() as isize - other.as_ptr() as isize) / mem::size_of::<A>() as isize\n        } else {\n            0\n        };\n        self.clone_from(&other);\n        self.as_nonnull_mut().offset(our_off)\n    }\n}","unsafe impl<A> RawDataMut for OwnedRepr<A> {\n    #[inline]\n    fn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,\n    {\n    }\n\n    #[inline]\n    fn try_is_unique(&mut self) -> Option<bool> {\n        Some(true)\n    }\n}","unsafe impl<A> Send for OwnedRepr<A> where A: Send { }","unsafe impl<A> Sync for OwnedRepr<A> where A: Sync { }"],"dimension::axes::Axes":["Debug","impl<$($parm)*> Clone for $type_ {\n            #[inline(always)]\n            fn clone(&self) -> Self { *self }\n        }","impl<$($parm)*> Copy for $type_ { }","impl<'a, D> DoubleEndedIterator for Axes<'a, D>\nwhere\n    D: Dimension,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.start < self.end {\n            let i = self.end.pre_dec();\n            Some(AxisDescription(\n                Axis(i),\n                self.dim[i],\n                self.strides[i] as Ixs,\n            ))\n        } else {\n            None\n        }\n    }\n}","impl<'a, D> Iterator for Axes<'a, D>\nwhere\n    D: Dimension,\n{\n    /// Description of the axis, its length and its stride.\n    type Item = AxisDescription;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.start < self.end {\n            let i = self.start.post_inc();\n            Some(AxisDescription(\n                Axis(i),\n                self.dim[i],\n                self.strides[i] as Ixs,\n            ))\n        } else {\n            None\n        }\n    }\n\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, AxisDescription) -> B,\n    {\n        (self.start..self.end)\n            .map(move |i| AxisDescription(Axis(i), self.dim[i], self.strides[i] as isize))\n            .fold(init, f)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.end - self.start;\n        (len, Some(len))\n    }\n}"],"dimension::axes::AxisDescription":["Debug","impl AxisDescription {\n    /// Return axis\n    #[inline(always)]\n    pub fn axis(self) -> Axis {\n        self.0\n    }\n    /// Return length\n    #[inline(always)]\n    pub fn len(self) -> Ix {\n        self.1\n    }\n    /// Return stride\n    #[inline(always)]\n    pub fn stride(self) -> Ixs {\n        self.2\n    }\n}","impl<$($parm)*> Clone for $type_ {\n            #[inline(always)]\n            fn clone(&self) -> Self { *self }\n        }","impl<$($parm)*> Copy for $type_ { }"],"dimension::axis::Axis":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Axis {\n    /// Return the index of the axis.\n    #[inline(always)]\n    pub fn index(self) -> usize {\n        self.0\n    }\n}"],"dimension::dim::Dim":["Clone","Copy","Default","Eq","Hash","PartialEq","impl $op<Ix> for Dim<[Ix; 1]> {\n            type Output = Self;\n            #[inline]\n            fn $op_m(mut self, rhs: Ix) -> Self {\n                $expr!(self, rhs);\n                self\n            }\n        }","impl $opassign<Ix> for Dim<[Ix; 1]> {\n            #[inline]\n            fn $opassign_m(&mut self, rhs: Ix) {\n                $expr!((*self)[0], rhs);\n            }\n        }","impl Dimension for Dim<[Ix; $n]> {\n            const NDIM: Option<usize> = Some($n);\n            type SliceArg = [SliceOrIndex; $n];\n            type Pattern = $pattern;\n            type Smaller = Dim<[Ix; $n - 1]>;\n            type Larger = $larger;\n            #[inline]\n            fn ndim(&self) -> usize { $n }\n            #[inline]\n            fn into_pattern(self) -> Self::Pattern {\n                self.ix().convert()\n            }\n            #[inline]\n            fn slice(&self) -> &[Ix] { self.ix() }\n            #[inline]\n            fn slice_mut(&mut self) -> &mut [Ix] { self.ixm() }\n            #[inline]\n            fn zeros(ndim: usize) -> Self {\n                assert_eq!(ndim, $n);\n                Self::default()\n            }\n            #[inline]\n            $($insert_axis)*\n            #[inline]\n            fn try_remove_axis(&self, axis: Axis) -> Self::Smaller {\n                self.remove_axis(axis)\n            }\n            private_impl!{}\n        }","impl Dimension for Dim<[Ix; 0]> {\n    const NDIM: Option<usize> = Some(0);\n    type SliceArg = [SliceOrIndex; 0];\n    type Pattern = ();\n    type Smaller = Self;\n    type Larger = Ix1;\n    // empty product is 1 -> size is 1\n    #[inline]\n    fn ndim(&self) -> usize {\n        0\n    }\n    #[inline]\n    fn slice(&self) -> &[Ix] {\n        &[]\n    }\n    #[inline]\n    fn slice_mut(&mut self) -> &mut [Ix] {\n        &mut []\n    }\n    #[inline]\n    fn _fastest_varying_stride_order(&self) -> Self {\n        Ix0()\n    }\n    #[inline]\n    fn into_pattern(self) -> Self::Pattern {}\n    #[inline]\n    fn zeros(ndim: usize) -> Self {\n        assert_eq!(ndim, 0);\n        Self::default()\n    }\n    #[inline]\n    fn next_for(&self, _index: Self) -> Option<Self> {\n        None\n    }\n    #[inline]\n    impl_insert_axis_array!(0);\n    #[inline]\n    fn try_remove_axis(&self, _ignore: Axis) -> Self::Smaller {\n        *self\n    }\n\n    private_impl! {}\n}","impl Dimension for Dim<[Ix; 1]> {\n    const NDIM: Option<usize> = Some(1);\n    type SliceArg = [SliceOrIndex; 1];\n    type Pattern = Ix;\n    type Smaller = Ix0;\n    type Larger = Ix2;\n    #[inline]\n    fn ndim(&self) -> usize {\n        1\n    }\n    #[inline]\n    fn slice(&self) -> &[Ix] {\n        self.ix()\n    }\n    #[inline]\n    fn slice_mut(&mut self) -> &mut [Ix] {\n        self.ixm()\n    }\n    #[inline]\n    fn into_pattern(self) -> Self::Pattern {\n        get!(&self, 0)\n    }\n    #[inline]\n    fn zeros(ndim: usize) -> Self {\n        assert_eq!(ndim, 1);\n        Self::default()\n    }\n    #[inline]\n    fn next_for(&self, mut index: Self) -> Option<Self> {\n        getm!(index, 0) += 1;\n        if get!(&index, 0) < get!(self, 0) {\n            Some(index)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn equal(&self, rhs: &Self) -> bool {\n        get!(self, 0) == get!(rhs, 0)\n    }\n\n    #[inline]\n    fn size(&self) -> usize {\n        get!(self, 0)\n    }\n    #[inline]\n    fn size_checked(&self) -> Option<usize> {\n        Some(get!(self, 0))\n    }\n\n    #[inline]\n    fn default_strides(&self) -> Self {\n        if get!(self, 0) == 0 {\n            Ix1(0)\n        } else {\n            Ix1(1)\n        }\n    }\n\n    #[inline]\n    fn _fastest_varying_stride_order(&self) -> Self {\n        Ix1(0)\n    }\n\n    #[inline(always)]\n    fn min_stride_axis(&self, _: &Self) -> Axis {\n        Axis(0)\n    }\n\n    #[inline(always)]\n    fn max_stride_axis(&self, _: &Self) -> Axis {\n        Axis(0)\n    }\n\n    #[inline]\n    fn first_index(&self) -> Option<Self> {\n        if get!(self, 0) != 0 {\n            Some(Ix1(0))\n        } else {\n            None\n        }\n    }\n\n    /// Self is an index, return the stride offset\n    #[inline(always)]\n    fn stride_offset(index: &Self, stride: &Self) -> isize {\n        stride_offset(get!(index, 0), get!(stride, 0))\n    }\n\n    /// Return stride offset for this dimension and index.\n    #[inline]\n    fn stride_offset_checked(&self, stride: &Self, index: &Self) -> Option<isize> {\n        if get!(index, 0) < get!(self, 0) {\n            Some(stride_offset(get!(index, 0), get!(stride, 0)))\n        } else {\n            None\n        }\n    }\n    #[inline]\n    impl_insert_axis_array!(1);\n    #[inline]\n    fn try_remove_axis(&self, axis: Axis) -> Self::Smaller {\n        self.remove_axis(axis)\n    }\n    private_impl! {}\n}","impl Dimension for Dim<[Ix; 2]> {\n    const NDIM: Option<usize> = Some(2);\n    type SliceArg = [SliceOrIndex; 2];\n    type Pattern = (Ix, Ix);\n    type Smaller = Ix1;\n    type Larger = Ix3;\n    #[inline]\n    fn ndim(&self) -> usize {\n        2\n    }\n    #[inline]\n    fn into_pattern(self) -> Self::Pattern {\n        self.ix().convert()\n    }\n    #[inline]\n    fn slice(&self) -> &[Ix] {\n        self.ix()\n    }\n    #[inline]\n    fn slice_mut(&mut self) -> &mut [Ix] {\n        self.ixm()\n    }\n    #[inline]\n    fn zeros(ndim: usize) -> Self {\n        assert_eq!(ndim, 2);\n        Self::default()\n    }\n    #[inline]\n    fn next_for(&self, index: Self) -> Option<Self> {\n        let mut i = get!(&index, 0);\n        let mut j = get!(&index, 1);\n        let imax = get!(self, 0);\n        let jmax = get!(self, 1);\n        j += 1;\n        if j >= jmax {\n            j = 0;\n            i += 1;\n            if i >= imax {\n                return None;\n            }\n        }\n        Some(Ix2(i, j))\n    }\n\n    #[inline]\n    fn equal(&self, rhs: &Self) -> bool {\n        get!(self, 0) == get!(rhs, 0) && get!(self, 1) == get!(rhs, 1)\n    }\n\n    #[inline]\n    fn size(&self) -> usize {\n        get!(self, 0) * get!(self, 1)\n    }\n\n    #[inline]\n    fn size_checked(&self) -> Option<usize> {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        (m as usize).checked_mul(n as usize)\n    }\n\n    #[inline]\n    fn last_elem(&self) -> usize {\n        get!(self, 1)\n    }\n\n    #[inline]\n    fn set_last_elem(&mut self, i: usize) {\n        getm!(self, 1) = i;\n    }\n\n    #[inline]\n    fn default_strides(&self) -> Self {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        if m == 0 || n == 0 {\n            Ix2(0, 0)\n        } else {\n            Ix2(n, 1)\n        }\n    }\n    #[inline]\n    fn fortran_strides(&self) -> Self {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        if m == 0 || n == 0 {\n            Ix2(0, 0)\n        } else {\n            Ix2(1, m)\n        }\n    }\n\n    #[inline]\n    fn _fastest_varying_stride_order(&self) -> Self {\n        if get!(self, 0) as Ixs <= get!(self, 1) as Ixs {\n            Ix2(0, 1)\n        } else {\n            Ix2(1, 0)\n        }\n    }\n\n    #[inline]\n    fn min_stride_axis(&self, strides: &Self) -> Axis {\n        let s = get!(strides, 0) as Ixs;\n        let t = get!(strides, 1) as Ixs;\n        if s.abs() < t.abs() {\n            Axis(0)\n        } else {\n            Axis(1)\n        }\n    }\n\n    #[inline]\n    fn first_index(&self) -> Option<Self> {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        if m != 0 && n != 0 {\n            Some(Ix2(0, 0))\n        } else {\n            None\n        }\n    }\n\n    /// Self is an index, return the stride offset\n    #[inline(always)]\n    fn stride_offset(index: &Self, strides: &Self) -> isize {\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        stride_offset(i, s) + stride_offset(j, t)\n    }\n\n    /// Return stride offset for this dimension and index.\n    #[inline]\n    fn stride_offset_checked(&self, strides: &Self, index: &Self) -> Option<isize> {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        if i < m && j < n {\n            Some(stride_offset(i, s) + stride_offset(j, t))\n        } else {\n            None\n        }\n    }\n    #[inline]\n    impl_insert_axis_array!(2);\n    #[inline]\n    fn try_remove_axis(&self, axis: Axis) -> Self::Smaller {\n        self.remove_axis(axis)\n    }\n    private_impl! {}\n}","impl Dimension for Dim<[Ix; 3]> {\n    const NDIM: Option<usize> = Some(3);\n    type SliceArg = [SliceOrIndex; 3];\n    type Pattern = (Ix, Ix, Ix);\n    type Smaller = Ix2;\n    type Larger = Ix4;\n    #[inline]\n    fn ndim(&self) -> usize {\n        3\n    }\n    #[inline]\n    fn into_pattern(self) -> Self::Pattern {\n        self.ix().convert()\n    }\n    #[inline]\n    fn slice(&self) -> &[Ix] {\n        self.ix()\n    }\n    #[inline]\n    fn slice_mut(&mut self) -> &mut [Ix] {\n        self.ixm()\n    }\n\n    #[inline]\n    fn size(&self) -> usize {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        let o = get!(self, 2);\n        m as usize * n as usize * o as usize\n    }\n\n    #[inline]\n    fn zeros(ndim: usize) -> Self {\n        assert_eq!(ndim, 3);\n        Self::default()\n    }\n\n    #[inline]\n    fn next_for(&self, index: Self) -> Option<Self> {\n        let mut i = get!(&index, 0);\n        let mut j = get!(&index, 1);\n        let mut k = get!(&index, 2);\n        let imax = get!(self, 0);\n        let jmax = get!(self, 1);\n        let kmax = get!(self, 2);\n        k += 1;\n        if k == kmax {\n            k = 0;\n            j += 1;\n            if j == jmax {\n                j = 0;\n                i += 1;\n                if i == imax {\n                    return None;\n                }\n            }\n        }\n        Some(Ix3(i, j, k))\n    }\n\n    /// Self is an index, return the stride offset\n    #[inline]\n    fn stride_offset(index: &Self, strides: &Self) -> isize {\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let k = get!(index, 2);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        let u = get!(strides, 2);\n        stride_offset(i, s) + stride_offset(j, t) + stride_offset(k, u)\n    }\n\n    /// Return stride offset for this dimension and index.\n    #[inline]\n    fn stride_offset_checked(&self, strides: &Self, index: &Self) -> Option<isize> {\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        let l = get!(self, 2);\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let k = get!(index, 2);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        let u = get!(strides, 2);\n        if i < m && j < n && k < l {\n            Some(stride_offset(i, s) + stride_offset(j, t) + stride_offset(k, u))\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn _fastest_varying_stride_order(&self) -> Self {\n        let mut stride = *self;\n        let mut order = Ix3(0, 1, 2);\n        macro_rules! swap {\n            ($stride:expr, $order:expr, $x:expr, $y:expr) => {\n                if $stride[$x] > $stride[$y] {\n                    $stride.swap($x, $y);\n                    $order.ixm().swap($x, $y);\n                }\n            };\n        }\n        {\n            // stable sorting network for 3 elements\n            let strides = stride.slice_mut();\n            swap![strides, order, 1, 2];\n            swap![strides, order, 0, 1];\n            swap![strides, order, 1, 2];\n        }\n        order\n    }\n    #[inline]\n    impl_insert_axis_array!(3);\n    #[inline]\n    fn try_remove_axis(&self, axis: Axis) -> Self::Smaller {\n        self.remove_axis(axis)\n    }\n    private_impl! {}\n}","impl Index<usize> for Dim<IxDynImpl> {\n    type Output = <IxDynImpl as Index<usize>>::Output;\n    fn index(&self, index: usize) -> &Self::Output {\n        &self.ix()[index]\n    }\n}","impl Index<usize> for Dim<[Ix; $n]> {\n            type Output = usize;\n            #[inline(always)]\n            fn index(&self, index: usize) -> &Self::Output {\n                &self.ix()[index]\n            }\n        }","impl IndexMut<usize> for Dim<IxDynImpl> {\n    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.ixm()[index]\n    }\n}","impl IndexMut<usize> for Dim<[Ix; $n]> {\n            #[inline(always)]\n            fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n                &mut self.ixm()[index]\n            }\n        }","impl RemoveAxis for Dim<IxDynImpl> {\n    fn remove_axis(&self, axis: Axis) -> Self {\n        debug_assert!(axis.index() < self.ndim());\n        Dim::new(self.ix().remove(axis.index()))\n    }\n}","impl RemoveAxis for Dim<[Ix; $n]>\n        {\n            #[inline]\n            fn remove_axis(&self, axis: Axis) -> Self::Smaller {\n                debug_assert!(axis.index() < self.ndim());\n                let mut result = Dim([0; $n - 1]);\n                {\n                    let src = self.slice();\n                    let dst = result.slice_mut();\n                    dst[..axis.index()].copy_from_slice(&src[..axis.index()]);\n                    dst[axis.index()..].copy_from_slice(&src[axis.index() + 1..]);\n                }\n                result\n            }\n        }","impl RemoveAxis for Dim<[Ix; 1]> {\n    #[inline]\n    fn remove_axis(&self, axis: Axis) -> Ix0 {\n        debug_assert!(axis.index() < self.ndim());\n        Ix0()\n    }\n}","impl RemoveAxis for Dim<[Ix; 2]> {\n    #[inline]\n    fn remove_axis(&self, axis: Axis) -> Ix1 {\n        let axis = axis.index();\n        debug_assert!(axis < self.ndim());\n        if axis == 0 {\n            Ix1(get!(self, 1))\n        } else {\n            Ix1(get!(self, 0))\n        }\n    }\n}","impl Zero for Dim<[Ix; $n]> {\n            #[inline]\n            fn zero() -> Self {\n                Dim::new(index!(array_zero [] $n))\n            }\n            fn is_zero(&self) -> bool {\n                self.slice().iter().all(|x| *x == 0)\n            }\n        }","impl<'a, I> $opassign<&'a Dim<I>> for Dim<I>\n        where\n            Dim<I>: Dimension,\n        {\n            fn $opassign_m(&mut self, rhs: &Self) {\n                for (x, &y) in zip(self.slice_mut(), rhs.slice()) {\n                    $expr!(*x, y);\n                }\n            }\n        }","impl<I: ?Sized> PartialEq<I> for Dim<I>\nwhere\n    I: PartialEq,\n{\n    fn eq(&self, rhs: &I) -> bool {\n        self.index == *rhs\n    }\n}","impl<I> $op for Dim<I>\n        where\n            Dim<I>: Dimension,\n        {\n            type Output = Self;\n            fn $op_m(mut self, rhs: Self) -> Self {\n                $expr!(self, &rhs);\n                self\n            }\n        }","impl<I> $op<Ix> for Dim<I>\n        where\n            Dim<I>: Dimension,\n        {\n            type Output = Self;\n            fn $op_m(mut self, rhs: Ix) -> Self {\n                $expr!(self, rhs);\n                self\n            }\n        }","impl<I> $opassign for Dim<I>\n        where\n            Dim<I>: Dimension,\n        {\n            fn $opassign_m(&mut self, rhs: Self) {\n                $expr!(*self, &rhs);\n            }\n        }","impl<I> $opassign<Ix> for Dim<I>\n        where\n            Dim<I>: Dimension,\n        {\n            fn $opassign_m(&mut self, rhs: Ix) {\n                for x in self.slice_mut() {\n                    $expr!(*x, rhs);\n                }\n            }\n        }","impl<I> Dim<I> {\n    /// Private constructor and accessors for Dim\n    pub(crate) fn new(index: I) -> Dim<I> {\n        Dim { index }\n    }\n    #[inline(always)]\n    pub(crate) fn ix(&self) -> &I {\n        &self.index\n    }\n    #[inline(always)]\n    pub(crate) fn ixm(&mut self) -> &mut I {\n        &mut self.index\n    }\n}","impl<I> fmt::Debug for Dim<I>\nwhere\n    I: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:?}\", self.index)\n    }\n}","unsafe impl NdIndex<IxDyn> for Dim<[Ix; $n]> {\n            #[inline]\n            fn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize> {\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }\n\n            #[inline]\n            fn index_unchecked(&self, strides: &IxDyn) -> isize {\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }\n        }"],"dimension::dynindeximpl::IxDynImpl":["Clone","Debug","Default","Eq","Hash","PartialEq","impl Deref for IxDynImpl {\n    type Target = [Ix];\n    #[inline]\n    fn deref(&self) -> &[Ix] {\n        &self.0\n    }\n}","impl DerefMut for IxDynImpl {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [Ix] {\n        &mut self.0\n    }\n}","impl From<Vec<Ix>> for IxDynImpl {\n    #[inline]\n    fn from(ix: Vec<Ix>) -> Self {\n        IxDynImpl(IxDynRepr::from_vec_auto(ix))\n    }\n}","impl IntoDimension for IxDynImpl {\n    type Dim = IxDyn;\n    #[inline(always)]\n    fn into_dimension(self) -> Self::Dim {\n        Dim::new(self)\n    }\n}","impl IxDynImpl {\n    pub(crate) fn insert(&self, i: usize) -> Self {\n        let len = self.len();\n        debug_assert!(i <= len);\n        IxDynImpl(if len < CAP {\n            let mut out = [1; CAP];\n            out[0..i].copy_from_slice(&self[0..i]);\n            out[i + 1..=len].copy_from_slice(&self[i..len]);\n            IxDynRepr::Inline((len + 1) as u32, out)\n        } else {\n            let mut out = Vec::with_capacity(len + 1);\n            out.extend_from_slice(&self[0..i]);\n            out.push(1);\n            out.extend_from_slice(&self[i..len]);\n            IxDynRepr::from_vec(out)\n        })\n    }\n\n    fn remove(&self, i: usize) -> Self {\n        IxDynImpl(match self.0 {\n            IxDynRepr::Inline(0, _) => IxDynRepr::Inline(0, [0; CAP]),\n            IxDynRepr::Inline(1, _) => IxDynRepr::Inline(0, [0; CAP]),\n            IxDynRepr::Inline(2, ref arr) => {\n                let mut out = [0; CAP];\n                out[0] = arr[1 - i];\n                IxDynRepr::Inline(1, out)\n            }\n            ref ixdyn => {\n                let len = ixdyn.len();\n                let mut result = IxDynRepr::copy_from(&ixdyn[..len - 1]);\n                for j in i..len - 1 {\n                    result[j] = ixdyn[j + 1]\n                }\n                result\n            }\n        })\n    }\n}","impl<'a> From<&'a [Ix]> for IxDynImpl {\n    #[inline]\n    fn from(ix: &'a [Ix]) -> Self {\n        IxDynImpl(IxDynRepr::copy_from(ix))\n    }\n}","impl<J> Index<J> for IxDynImpl\nwhere\n    [Ix]: Index<J>,\n{\n    type Output = <[Ix] as Index<J>>::Output;\n    fn index(&self, index: J) -> &Self::Output {\n        &self.0[index]\n    }\n}","impl<J> IndexMut<J> for IxDynImpl\nwhere\n    [Ix]: IndexMut<J>,\n{\n    fn index_mut(&mut self, index: J) -> &mut Self::Output {\n        &mut self.0[index]\n    }\n}"],"dimension::dynindeximpl::IxDynRepr":["Debug","impl Default for IxDynRepr<Ix> {\n    fn default() -> Self {\n        Self::copy_from(&[0])\n    }\n}","impl<T: Copy + Zero> IxDynRepr<T> {\n    // make an Inline or Alloc version as appropriate\n    fn from_vec_auto(v: Vec<T>) -> Self {\n        if v.len() <= CAP {\n            Self::copy_from(&v)\n        } else {\n            Self::from_vec(v)\n        }\n    }\n}","impl<T: Copy + Zero> IxDynRepr<T> {\n    pub fn copy_from(x: &[T]) -> Self {\n        if x.len() <= CAP {\n            let mut arr = [T::zero(); CAP];\n            arr[..x.len()].copy_from_slice(&x[..]);\n            IxDynRepr::Inline(x.len() as _, arr)\n        } else {\n            Self::from(x)\n        }\n    }\n}","impl<T: Copy> Clone for IxDynRepr<T> {\n    fn clone(&self) -> Self {\n        match *self {\n            IxDynRepr::Inline(len, arr) => IxDynRepr::Inline(len, arr),\n            _ => Self::from(&self[..]),\n        }\n    }\n}","impl<T: Copy> IxDynRepr<T> {\n    fn from_vec(v: Vec<T>) -> Self {\n        IxDynRepr::Alloc(v.into_boxed_slice())\n    }\n\n    fn from(x: &[T]) -> Self {\n        Self::from_vec(x.to_vec())\n    }\n}","impl<T: Eq> Eq for IxDynRepr<T> {}","impl<T: Hash> Hash for IxDynRepr<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        Hash::hash(&self[..], state)\n    }\n}","impl<T: PartialEq> PartialEq for IxDynRepr<T> {\n    fn eq(&self, rhs: &Self) -> bool {\n        match (self, rhs) {\n            (&IxDynRepr::Inline(slen, ref sarr), &IxDynRepr::Inline(rlen, ref rarr)) => {\n                slen == rlen\n                    && (0..CAP as usize)\n                        .filter(|&i| i < slen as usize)\n                        .all(|i| sarr[i] == rarr[i])\n            }\n            _ => self[..] == rhs[..],\n        }\n    }\n}","impl<T> Deref for IxDynRepr<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        match *self {\n            IxDynRepr::Inline(len, ref ar) => {\n                debug_assert!(len as usize <= ar.len());\n                unsafe { ar.get_unchecked(..len as usize) }\n            }\n            IxDynRepr::Alloc(ref ar) => &*ar,\n        }\n    }\n}","impl<T> DerefMut for IxDynRepr<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        match *self {\n            IxDynRepr::Inline(len, ref mut ar) => {\n                debug_assert!(len as usize <= ar.len());\n                unsafe { ar.get_unchecked_mut(..len as usize) }\n            }\n            IxDynRepr::Alloc(ref mut ar) => &mut *ar,\n        }\n    }\n}"],"error::ErrorKind":["Clone","Copy","Debug","impl PartialEq for ErrorKind {\n    #[inline(always)]\n    fn eq(&self, rhs: &Self) -> bool {\n        *self as u8 == *rhs as u8\n    }\n}"],"error::ShapeError":["Clone","impl Error for ShapeError {}","impl PartialEq for ShapeError {\n    #[inline(always)]\n    fn eq(&self, rhs: &Self) -> bool {\n        self.repr == rhs.repr\n    }\n}","impl ShapeError {\n    /// Return the `ErrorKind` of this error.\n    #[inline]\n    pub fn kind(&self) -> ErrorKind {\n        self.repr\n    }\n\n    /// Create a new `ShapeError`\n    pub fn from_kind(error: ErrorKind) -> Self {\n        from_kind(error)\n    }\n}","impl fmt::Debug for ShapeError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self)\n    }\n}","impl fmt::Display for ShapeError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let description = match self.kind() {\n            ErrorKind::IncompatibleShape => \"incompatible shapes\",\n            ErrorKind::IncompatibleLayout => \"incompatible memory layout\",\n            ErrorKind::RangeLimited => \"the shape does not fit in type limits\",\n            ErrorKind::OutOfBounds => \"out of bounds indexing\",\n            ErrorKind::Unsupported => \"unsupported operation\",\n            ErrorKind::Overflow => \"arithmetic overflow\",\n            ErrorKind::__Incomplete => \"this error variant is not in use\",\n        };\n        write!(f, \"ShapeError/{:?}: {}\", self.kind(), description)\n    }\n}"],"geomspace::Geomspace":["impl<F> DoubleEndedIterator for Geomspace<F>\nwhere\n    F: Float,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<F> {\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            self.len -= 1;\n            let i = self.len;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * exponent.exp())\n        }\n    }\n}","impl<F> ExactSizeIterator for Geomspace<F> where Geomspace<F>: Iterator {}","impl<F> Iterator for Geomspace<F>\nwhere\n    F: Float,\n{\n    type Item = F;\n\n    #[inline]\n    fn next(&mut self) -> Option<F> {\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            let i = self.index;\n            self.index += 1;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * exponent.exp())\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len - self.index;\n        (n, Some(n))\n    }\n}","unsafe impl<F> TrustedIterator for Geomspace<F> {}"],"indexes::IndexPtr":["Clone","Copy","Debug","impl<D> Offset for IndexPtr<D>\nwhere\n    D: Dimension + Copy,\n{\n    // stride: The axis to increment\n    type Stride = usize;\n\n    unsafe fn stride_offset(mut self, stride: Self::Stride, index: usize) -> Self {\n        self.index[stride] += index;\n        self\n    }\n    private_impl! {}\n}"],"indexes::Indices":["Clone","Copy","Debug","impl<D: Dimension + Copy> NdProducer for Indices<D> {\n    type Item = D::Pattern;\n    type Dim = D;\n    type Ptr = IndexPtr<D>;\n    type Stride = usize;\n\n    private_impl! {}\n\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        self.dim\n    }\n\n    #[doc(hidden)]\n    fn equal_dim(&self, dim: &Self::Dim) -> bool {\n        self.dim.equal(dim)\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> Self::Ptr {\n        IndexPtr { index: self.start }\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        if self.dim.ndim() <= 1 {\n            Layout::one_dimensional()\n        } else {\n            Layout::none()\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item {\n        ptr.index.into_pattern()\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr {\n        let mut index = *i;\n        index += &self.start;\n        IndexPtr { index }\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> Self::Stride {\n        axis.index()\n    }\n\n    #[inline(always)]\n    fn contiguous_stride(&self) -> Self::Stride {\n        0\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        let start_a = self.start;\n        let mut start_b = start_a;\n        let (a, b) = self.dim.split_at(axis, index);\n        start_b[axis.index()] += index;\n        (\n            Indices {\n                start: start_a,\n                dim: a,\n            },\n            Indices {\n                start: start_b,\n                dim: b,\n            },\n        )\n    }\n}","impl<D> IntoIterator for Indices<D>\nwhere\n    D: Dimension,\n{\n    type Item = D::Pattern;\n    type IntoIter = IndicesIter<D>;\n    fn into_iter(self) -> Self::IntoIter {\n        let sz = self.dim.size();\n        let index = if sz != 0 { Some(self.start) } else { None };\n        IndicesIter {\n            index,\n            dim: self.dim,\n        }\n    }\n}"],"indexes::IndicesIter":["Clone","impl<D> ExactSizeIterator for IndicesIter<D> where D: Dimension {}","impl<D> Iterator for IndicesIter<D>\nwhere\n    D: Dimension,\n{\n    type Item = D::Pattern;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = match self.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        self.index = self.dim.next_for(index.clone());\n        Some(index.into_pattern())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let l = match self.index {\n            None => 0,\n            Some(ref ix) => {\n                let gone = self\n                    .dim\n                    .default_strides()\n                    .slice()\n                    .iter()\n                    .zip(ix.slice().iter())\n                    .fold(0, |s, (&a, &b)| s + a as usize * b as usize);\n                self.dim.size() - gone\n            }\n        };\n        (l, Some(l))\n    }\n\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        F: FnMut(B, D::Pattern) -> B,\n    {\n        let IndicesIter { mut index, dim } = self;\n        let ndim = dim.ndim();\n        if ndim == 0 {\n            return match index {\n                Some(ix) => f(init, ix.into_pattern()),\n                None => init,\n            };\n        }\n        let inner_axis = ndim - 1;\n        let inner_len = dim[inner_axis];\n        let mut acc = init;\n        while let Some(mut ix) = index {\n            // unroll innermost axis\n            for i in ix[inner_axis]..inner_len {\n                ix[inner_axis] = i;\n                acc = f(acc, ix.clone().into_pattern());\n            }\n            index = dim.next_for(ix);\n        }\n        acc\n    }\n}","unsafe impl<D> TrustedIterator for IndicesIter<D> where D: Dimension {}"],"indexes::IndicesIterF":["Clone","impl<D> ExactSizeIterator for IndicesIterF<D> where D: Dimension {}","impl<D> Iterator for IndicesIterF<D>\nwhere\n    D: Dimension,\n{\n    type Item = D::Pattern;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if !self.has_remaining {\n            None\n        } else {\n            let elt = self.index.clone().into_pattern();\n            self.has_remaining = self.dim.next_for_f(&mut self.index);\n            Some(elt)\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if !self.has_remaining {\n            return (0, Some(0));\n        }\n        let gone = self\n            .dim\n            .fortran_strides()\n            .slice()\n            .iter()\n            .zip(self.index.slice().iter())\n            .fold(0, |s, (&a, &b)| s + a as usize * b as usize);\n        let l = self.dim.size() - gone;\n        (l, Some(l))\n    }\n}","unsafe impl<D> TrustedIterator for IndicesIterF<D> where D: Dimension {}"],"iterators::AxisChunksIter":["impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<'a, A, D: Dimension> AxisChunksIter<'a, A, D> {\n    pub(crate) fn new(v: ArrayView<'a, A, D>, axis: Axis, size: usize) -> Self {\n        let (iter, partial_chunk_index, partial_chunk_dim) = chunk_iter_parts(v, axis, size);\n        AxisChunksIter {\n            iter,\n            partial_chunk_index,\n            partial_chunk_dim,\n            life: PhantomData,\n        }\n    }\n}","impl<'a, A, D> $iter<'a, A, D>\n        where\n            D: Dimension,\n        {\n            fn get_subview(&self, index: usize, ptr: *mut A) -> $array<'a, A, D> {\n                if index != self.partial_chunk_index {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.iter.inner_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                } else {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.partial_chunk_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                }\n            }\n\n            /// Splits the iterator at index, yielding two disjoint iterators.\n            ///\n            /// `index` is relative to the current state of the iterator (which is not\n            /// necessarily the start of the axis).\n            ///\n            /// **Panics** if `index` is strictly greater than the iterator's remaining\n            /// length.\n            pub fn split_at(self, index: usize) -> (Self, Self) {\n                let (left, right) = self.iter.split_at(index);\n                (\n                    Self {\n                        iter: left,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim.clone(),\n                        life: self.life,\n                    },\n                    Self {\n                        iter: right,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim,\n                        life: self.life,\n                    },\n                )\n            }\n        }","impl<'a, A, D> DoubleEndedIterator for $iter<'a, A, D>\n        where\n            D: Dimension,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter\n                    .next_back_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }\n        }","impl<'a, A, D> ExactSizeIterator for $iter<'a, A, D> where D: Dimension {}","impl<'a, A, D> Iterator for $iter<'a, A, D>\n        where\n            D: Dimension,\n        {\n            type Item = $array<'a, A, D>;\n\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter\n                    .next_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::AxisChunksIterMut":["impl<'a, A, D: Dimension> AxisChunksIterMut<'a, A, D> {\n    pub(crate) fn new(v: ArrayViewMut<'a, A, D>, axis: Axis, size: usize) -> Self {\n        let (iter, partial_chunk_index, partial_chunk_dim) =\n            chunk_iter_parts(v.into_view(), axis, size);\n        AxisChunksIterMut {\n            iter,\n            partial_chunk_index,\n            partial_chunk_dim,\n            life: PhantomData,\n        }\n    }\n}","impl<'a, A, D> $iter<'a, A, D>\n        where\n            D: Dimension,\n        {\n            fn get_subview(&self, index: usize, ptr: *mut A) -> $array<'a, A, D> {\n                if index != self.partial_chunk_index {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.iter.inner_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                } else {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.partial_chunk_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                }\n            }\n\n            /// Splits the iterator at index, yielding two disjoint iterators.\n            ///\n            /// `index` is relative to the current state of the iterator (which is not\n            /// necessarily the start of the axis).\n            ///\n            /// **Panics** if `index` is strictly greater than the iterator's remaining\n            /// length.\n            pub fn split_at(self, index: usize) -> (Self, Self) {\n                let (left, right) = self.iter.split_at(index);\n                (\n                    Self {\n                        iter: left,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim.clone(),\n                        life: self.life,\n                    },\n                    Self {\n                        iter: right,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim,\n                        life: self.life,\n                    },\n                )\n            }\n        }","impl<'a, A, D> DoubleEndedIterator for $iter<'a, A, D>\n        where\n            D: Dimension,\n        {\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter\n                    .next_back_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }\n        }","impl<'a, A, D> ExactSizeIterator for $iter<'a, A, D> where D: Dimension {}","impl<'a, A, D> Iterator for $iter<'a, A, D>\n        where\n            D: Dimension,\n        {\n            type Item = $array<'a, A, D>;\n\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter\n                    .next_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Send,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::AxisIter":["Debug","impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<'a, A, D: Dimension> AxisIter<'a, A, D> {\n    /// Creates a new iterator over the specified axis.\n    pub(crate) fn new<Di>(v: ArrayView<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: RemoveAxis<Smaller = D>,\n    {\n        AxisIter {\n            iter: AxisIterCore::new(v, axis),\n            life: PhantomData,\n        }\n    }\n\n    /// Splits the iterator at `index`, yielding two disjoint iterators.\n    ///\n    /// `index` is relative to the current state of the iterator (which is not\n    /// necessarily the start of the axis).\n    ///\n    /// **Panics** if `index` is strictly greater than the iterator's remaining\n    /// length.\n    pub fn split_at(self, index: usize) -> (Self, Self) {\n        let (left, right) = self.iter.split_at(index);\n        (\n            AxisIter {\n                iter: left,\n                life: self.life,\n            },\n            AxisIter {\n                iter: right,\n                life: self.life,\n            },\n        )\n    }\n}","impl<'a, A, D: Dimension> NdProducer for AxisIter<'a, A, D> {\n    type Item = <Self as Iterator>::Item;\n    type Dim = Ix1;\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn layout(&self) -> crate::Layout {\n        crate::Layout::one_dimensional()\n    }\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        Ix1(self.len())\n    }\n    #[doc(hidden)]\n    fn as_ptr(&self) -> Self::Ptr {\n        if self.len() > 0 {\n            // `self.iter.index` is guaranteed to be in-bounds if any of the\n            // iterator remains (i.e. if `self.len() > 0`).\n            unsafe { self.iter.offset(self.iter.index) }\n        } else {\n            // In this case, `self.iter.index` may be past the end, so we must\n            // not call `.offset()`. It's okay to return a dangling pointer\n            // because it will never be used in the length 0 case.\n            std::ptr::NonNull::dangling().as_ptr()\n        }\n    }\n\n    fn contiguous_stride(&self) -> isize {\n        self.iter.stride\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item {\n        ArrayView::new_(\n            ptr,\n            self.iter.inner_dim.clone(),\n            self.iter.inner_strides.clone(),\n        )\n    }\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr {\n        self.iter.offset(self.iter.index + i[0])\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, _axis: Axis) -> isize {\n        self.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, _axis: Axis, index: usize) -> (Self, Self) {\n        self.split_at(index)\n    }\n    private_impl! {}\n}","impl<'a, A, D> DoubleEndedIterator for AxisIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|ptr| unsafe { self.as_ref(ptr) })\n    }\n}","impl<'a, A, D> ExactSizeIterator for AxisIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}","impl<'a, A, D> Iterator for AxisIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = ArrayView<'a, A, D>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|ptr| unsafe { self.as_ref(ptr) })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::AxisIterCore":["Debug","impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<A, D: Dimension> AxisIterCore<A, D> {\n    /// Constructs a new iterator over the specified axis.\n    fn new<S, Di>(v: ArrayBase<S, Di>, axis: Axis) -> Self\n    where\n        Di: RemoveAxis<Smaller = D>,\n        S: Data<Elem = A>,\n    {\n        AxisIterCore {\n            index: 0,\n            end: v.len_of(axis),\n            stride: v.stride_of(axis),\n            inner_dim: v.dim.remove_axis(axis),\n            inner_strides: v.strides.remove_axis(axis),\n            ptr: v.ptr.as_ptr(),\n        }\n    }\n\n    #[inline]\n    unsafe fn offset(&self, index: usize) -> *mut A {\n        debug_assert!(\n            index < self.end,\n            \"index={}, end={}, stride={}\",\n            index,\n            self.end,\n            self.stride\n        );\n        self.ptr.offset(index as isize * self.stride)\n    }\n\n    /// Splits the iterator at `index`, yielding two disjoint iterators.\n    ///\n    /// `index` is relative to the current state of the iterator (which is not\n    /// necessarily the start of the axis).\n    ///\n    /// **Panics** if `index` is strictly greater than the iterator's remaining\n    /// length.\n    fn split_at(self, index: usize) -> (Self, Self) {\n        assert!(index <= self.len());\n        let mid = self.index + index;\n        let left = AxisIterCore {\n            index: self.index,\n            end: mid,\n            stride: self.stride,\n            inner_dim: self.inner_dim.clone(),\n            inner_strides: self.inner_strides.clone(),\n            ptr: self.ptr,\n        };\n        let right = AxisIterCore {\n            index: mid,\n            end: self.end,\n            stride: self.stride,\n            inner_dim: self.inner_dim,\n            inner_strides: self.inner_strides,\n            ptr: self.ptr,\n        };\n        (left, right)\n    }\n\n    /// Does the same thing as `.next()` but also returns the index of the item\n    /// relative to the start of the axis.\n    fn next_with_index(&mut self) -> Option<(usize, *mut A)> {\n        let index = self.index;\n        self.next().map(|ptr| (index, ptr))\n    }\n\n    /// Does the same thing as `.next_back()` but also returns the index of the\n    /// item relative to the start of the axis.\n    fn next_back_with_index(&mut self) -> Option<(usize, *mut A)> {\n        self.next_back().map(|ptr| (self.end, ptr))\n    }\n}","impl<A, D> DoubleEndedIterator for AxisIterCore<A, D>\nwhere\n    D: Dimension,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.index >= self.end {\n            None\n        } else {\n            let ptr = unsafe { self.offset(self.end - 1) };\n            self.end -= 1;\n            Some(ptr)\n        }\n    }\n}","impl<A, D> ExactSizeIterator for AxisIterCore<A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.end - self.index\n    }\n}","impl<A, D> Iterator for AxisIterCore<A, D>\nwhere\n    D: Dimension,\n{\n    type Item = *mut A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.index >= self.end {\n            None\n        } else {\n            let ptr = unsafe { self.offset(self.index) };\n            self.index += 1;\n            Some(ptr)\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len();\n        (len, Some(len))\n    }\n}"],"iterators::AxisIterMut":["impl<'a, A, D: Dimension> AxisIterMut<'a, A, D> {\n    /// Creates a new iterator over the specified axis.\n    pub(crate) fn new<Di>(v: ArrayViewMut<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: RemoveAxis<Smaller = D>,\n    {\n        AxisIterMut {\n            iter: AxisIterCore::new(v, axis),\n            life: PhantomData,\n        }\n    }\n\n    /// Splits the iterator at `index`, yielding two disjoint iterators.\n    ///\n    /// `index` is relative to the current state of the iterator (which is not\n    /// necessarily the start of the axis).\n    ///\n    /// **Panics** if `index` is strictly greater than the iterator's remaining\n    /// length.\n    pub fn split_at(self, index: usize) -> (Self, Self) {\n        let (left, right) = self.iter.split_at(index);\n        (\n            AxisIterMut {\n                iter: left,\n                life: self.life,\n            },\n            AxisIterMut {\n                iter: right,\n                life: self.life,\n            },\n        )\n    }\n}","impl<'a, A, D: Dimension> NdProducer for AxisIterMut<'a, A, D> {\n    type Item = <Self as Iterator>::Item;\n    type Dim = Ix1;\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn layout(&self) -> crate::Layout {\n        crate::Layout::one_dimensional()\n    }\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim {\n        Ix1(self.len())\n    }\n    #[doc(hidden)]\n    fn as_ptr(&self) -> Self::Ptr {\n        if self.len() > 0 {\n            // `self.iter.index` is guaranteed to be in-bounds if any of the\n            // iterator remains (i.e. if `self.len() > 0`).\n            unsafe { self.iter.offset(self.iter.index) }\n        } else {\n            // In this case, `self.iter.index` may be past the end, so we must\n            // not call `.offset()`. It's okay to return a dangling pointer\n            // because it will never be used in the length 0 case.\n            std::ptr::NonNull::dangling().as_ptr()\n        }\n    }\n\n    fn contiguous_stride(&self) -> isize {\n        self.iter.stride\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item {\n        ArrayViewMut::new_(\n            ptr,\n            self.iter.inner_dim.clone(),\n            self.iter.inner_strides.clone(),\n        )\n    }\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr {\n        self.iter.offset(self.iter.index + i[0])\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, _axis: Axis) -> isize {\n        self.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, _axis: Axis, index: usize) -> (Self, Self) {\n        self.split_at(index)\n    }\n    private_impl! {}\n}","impl<'a, A, D> DoubleEndedIterator for AxisIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|ptr| unsafe { self.as_ref(ptr) })\n    }\n}","impl<'a, A, D> ExactSizeIterator for AxisIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}","impl<'a, A, D> Iterator for AxisIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = ArrayViewMut<'a, A, D>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|ptr| unsafe { self.as_ref(ptr) })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Send,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::Baseiter":["impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<'a, A, D: Dimension> ExactSizeIterator for Baseiter<A, D> {\n    fn len(&self) -> usize {\n        match self.index {\n            None => 0,\n            Some(ref ix) => {\n                let gone = self\n                    .dim\n                    .default_strides()\n                    .slice()\n                    .iter()\n                    .zip(ix.slice().iter())\n                    .fold(0, |s, (&a, &b)| s + a as usize * b as usize);\n                self.dim.size() - gone\n            }\n        }\n    }\n}","impl<A, D: Dimension> Baseiter<A, D> {\n    /// Creating a Baseiter is unsafe because shape and stride parameters need\n    /// to be correct to avoid performing an unsafe pointer offset while\n    /// iterating.\n    #[inline]\n    pub unsafe fn new(ptr: *mut A, len: D, stride: D) -> Baseiter<A, D> {\n        Baseiter {\n            ptr,\n            index: len.first_index(),\n            dim: len,\n            strides: stride,\n        }\n    }\n}","impl<A, D: Dimension> Iterator for Baseiter<A, D> {\n    type Item = *mut A;\n\n    #[inline]\n    fn next(&mut self) -> Option<*mut A> {\n        let index = match self.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        let offset = D::stride_offset(&index, &self.strides);\n        self.index = self.dim.next_for(index);\n        unsafe { Some(self.ptr.offset(offset)) }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len();\n        (len, Some(len))\n    }\n\n    fn fold<Acc, G>(mut self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, *mut A) -> Acc,\n    {\n        let ndim = self.dim.ndim();\n        debug_assert_ne!(ndim, 0);\n        let mut accum = init;\n        while let Some(mut index) = self.index.clone() {\n            let stride = self.strides.last_elem() as isize;\n            let elem_index = index.last_elem();\n            let len = self.dim.last_elem();\n            let offset = D::stride_offset(&index, &self.strides);\n            unsafe {\n                let row_ptr = self.ptr.offset(offset);\n                for i in 0..(len - elem_index) {\n                    accum = g(accum, row_ptr.offset(i as isize * stride));\n                }\n            }\n            index.set_last_elem(len - 1);\n            self.index = self.dim.next_for(index);\n        }\n        accum\n    }\n}","impl<A> DoubleEndedIterator for Baseiter<A, Ix1> {\n    #[inline]\n    fn next_back(&mut self) -> Option<*mut A> {\n        let index = match self.index {\n            None => return None,\n            Some(ix) => ix,\n        };\n        self.dim[0] -= 1;\n        let offset = <_>::stride_offset(&self.dim, &self.strides);\n        if index == self.dim {\n            self.index = None;\n        }\n\n        unsafe { Some(self.ptr.offset(offset)) }\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<*mut A> {\n        let index = self.index?;\n        let len = self.dim[0] - index[0];\n        if n < len {\n            self.dim[0] -= n + 1;\n            let offset = <_>::stride_offset(&self.dim, &self.strides);\n            if index == self.dim {\n                self.index = None;\n            }\n            unsafe { Some(self.ptr.offset(offset)) }\n        } else {\n            self.index = None;\n            None\n        }\n    }\n\n    fn rfold<Acc, G>(mut self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, *mut A) -> Acc,\n    {\n        let mut accum = init;\n        if let Some(index) = self.index {\n            let elem_index = index[0];\n            unsafe {\n                // self.dim[0] is the current length\n                while self.dim[0] > elem_index {\n                    self.dim[0] -= 1;\n                    accum = g(\n                        accum,\n                        self.ptr\n                            .offset(Ix1::stride_offset(&self.dim, &self.strides)),\n                    );\n                }\n            }\n        }\n        accum\n    }\n}"],"iterators::ElementsBase":["impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<'a, A, D: Dimension> ElementsBase<'a, A, D> {\n    pub fn new(v: ArrayView<'a, A, D>) -> Self {\n        ElementsBase {\n            inner: v.into_base_iter(),\n            life: PhantomData,\n        }\n    }\n}","impl<'a, A, D: Dimension> Iterator for ElementsBase<'a, A, D> {\n    type Item = &'a A;\n    #[inline]\n    fn next(&mut self) -> Option<&'a A> {\n        self.inner.next().map(|p| unsafe { &*p })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        unsafe { self.inner.fold(init, move |acc, ptr| g(acc, &*ptr)) }\n    }\n}","impl<'a, A, D> ExactSizeIterator for ElementsBase<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}","impl<'a, A> DoubleEndedIterator for ElementsBase<'a, A, Ix1> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a A> {\n        self.inner.next_back().map(|p| unsafe { &*p })\n    }\n\n    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        unsafe { self.inner.rfold(init, move |acc, ptr| g(acc, &*ptr)) }\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::ElementsBaseMut":["impl<'a, A, D: Dimension> ElementsBaseMut<'a, A, D> {\n    pub fn new(v: ArrayViewMut<'a, A, D>) -> Self {\n        ElementsBaseMut {\n            inner: v.into_base_iter(),\n            life: PhantomData,\n        }\n    }\n}","impl<'a, A, D: Dimension> Iterator for ElementsBaseMut<'a, A, D> {\n    type Item = &'a mut A;\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut A> {\n        self.inner.next().map(|p| unsafe { &mut *p })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        unsafe { self.inner.fold(init, move |acc, ptr| g(acc, &mut *ptr)) }\n    }\n}","impl<'a, A, D> ExactSizeIterator for ElementsBaseMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}","impl<'a, A> DoubleEndedIterator for ElementsBaseMut<'a, A, Ix1> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut A> {\n        self.inner.next_back().map(|p| unsafe { &mut *p })\n    }\n\n    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        unsafe { self.inner.rfold(init, move |acc, ptr| g(acc, &mut *ptr)) }\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Send,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::ElementsRepr":["Clone"],"iterators::IndexedIter":["Clone","impl<'a, A, D: Dimension> Iterator for IndexedIter<'a, A, D> {\n    type Item = (D::Pattern, &'a A);\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = match self.0.inner.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        match self.0.next() {\n            None => None,\n            Some(elem) => Some((index.into_pattern(), elem)),\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl<'a, A, D> ExactSizeIterator for IndexedIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.0.inner.len()\n    }\n}","impl<'a, A, D> IndexedIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    pub(crate) fn new(x: ElementsBase<'a, A, D>) -> Self {\n        IndexedIter(x)\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::IndexedIterMut":["impl<'a, A, D: Dimension> Iterator for IndexedIterMut<'a, A, D> {\n    type Item = (D::Pattern, &'a mut A);\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let index = match self.0.inner.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        match self.0.next() {\n            None => None,\n            Some(elem) => Some((index.into_pattern(), elem)),\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl<'a, A, D> ExactSizeIterator for IndexedIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.0.inner.len()\n    }\n}","impl<'a, A, D> IndexedIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    pub(crate) fn new(x: ElementsBaseMut<'a, A, D>) -> Self {\n        IndexedIterMut(x)\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Send,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::Iter":["impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<'a, A, D: Dimension> Iterator for Iter<'a, A, D> {\n    type Item = &'a A;\n    #[inline]\n    fn next(&mut self) -> Option<&'a A> {\n        either_mut!(self.inner, iter => iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        either!(self.inner, ref iter => iter.size_hint())\n    }\n\n    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        either!(self.inner, iter => iter.fold(init, g))\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        either_mut!(self.inner, iter => iter.nth(n))\n    }\n\n    fn collect<B>(self) -> B\n    where\n        B: FromIterator<Self::Item>,\n    {\n        either!(self.inner, iter => iter.collect())\n    }\n\n    fn all<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.all(f))\n    }\n\n    fn any<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.any(f))\n    }\n\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.find(predicate))\n    }\n\n    fn find_map<B, F>(&mut self, f: F) -> Option<B>\n    where\n        F: FnMut(Self::Item) -> Option<B>,\n    {\n        either_mut!(self.inner, iter => iter.find_map(f))\n    }\n\n    fn count(self) -> usize {\n        either!(self.inner, iter => iter.count())\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        either!(self.inner, iter => iter.last())\n    }\n\n    fn position<P>(&mut self, predicate: P) -> Option<usize>\n    where\n        P: FnMut(Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.position(predicate))\n    }\n}","impl<'a, A, D> ExactSizeIterator for Iter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        either!(self.inner, ref iter => iter.len())\n    }\n}","impl<'a, A, D> Iter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    pub(crate) fn new(self_: ArrayView<'a, A, D>) -> Self {\n        Iter {\n            inner: if let Some(slc) = self_.to_slice() {\n                ElementsRepr::Slice(slc.iter())\n            } else {\n                ElementsRepr::Counted(self_.into_elements_base())\n            },\n        }\n    }\n}","impl<'a, A> DoubleEndedIterator for Iter<'a, A, Ix1> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a A> {\n        either_mut!(self.inner, iter => iter.next_back())\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<&'a A> {\n        either_mut!(self.inner, iter => iter.nth_back(n))\n    }\n\n    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        either!(self.inner, iter => iter.rfold(init, g))\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }","unsafe impl<'a, A, D> TrustedIterator for Iter<'a, A, D> {}"],"iterators::IterMut":["impl<'a, A, D: Dimension> Iterator for IterMut<'a, A, D> {\n    type Item = &'a mut A;\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut A> {\n        either_mut!(self.inner, iter => iter.next())\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        either!(self.inner, ref iter => iter.size_hint())\n    }\n\n    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        either!(self.inner, iter => iter.fold(init, g))\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        either_mut!(self.inner, iter => iter.nth(n))\n    }\n\n    fn collect<B>(self) -> B\n    where\n        B: FromIterator<Self::Item>,\n    {\n        either!(self.inner, iter => iter.collect())\n    }\n\n    fn all<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.all(f))\n    }\n\n    fn any<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.any(f))\n    }\n\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.find(predicate))\n    }\n\n    fn find_map<B, F>(&mut self, f: F) -> Option<B>\n    where\n        F: FnMut(Self::Item) -> Option<B>,\n    {\n        either_mut!(self.inner, iter => iter.find_map(f))\n    }\n\n    fn count(self) -> usize {\n        either!(self.inner, iter => iter.count())\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        either!(self.inner, iter => iter.last())\n    }\n\n    fn position<P>(&mut self, predicate: P) -> Option<usize>\n    where\n        P: FnMut(Self::Item) -> bool,\n    {\n        either_mut!(self.inner, iter => iter.position(predicate))\n    }\n}","impl<'a, A, D> ExactSizeIterator for IterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        either!(self.inner, ref iter => iter.len())\n    }\n}","impl<'a, A, D> IterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    pub(crate) fn new(self_: ArrayViewMut<'a, A, D>) -> Self {\n        IterMut {\n            inner: match self_.into_slice_() {\n                Ok(x) => ElementsRepr::Slice(x.iter_mut()),\n                Err(self_) => ElementsRepr::Counted(self_.into_elements_base()),\n            },\n        }\n    }\n}","impl<'a, A> DoubleEndedIterator for IterMut<'a, A, Ix1> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut A> {\n        either_mut!(self.inner, iter => iter.next_back())\n    }\n\n    fn nth_back(&mut self, n: usize) -> Option<&'a mut A> {\n        either_mut!(self.inner, iter => iter.nth_back(n))\n    }\n\n    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        either!(self.inner, iter => iter.rfold(init, g))\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Send,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }","unsafe impl<'a, A, D> TrustedIterator for IterMut<'a, A, D> {}"],"iterators::LanesIter":["impl<$($parmbounds)*> Clone for $typename<$($parm)*> {\n            fn clone(&self) -> Self {\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }\n        }","impl<'a, A, D> ExactSizeIterator for LanesIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}","impl<'a, A, D> Iterator for LanesIter<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = ArrayView<'a, A, Ix1>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|ptr| unsafe {\n            ArrayView::new_(ptr, Ix1(self.inner_len), Ix1(self.inner_stride as Ix))\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::LanesIterMut":["impl<'a, A, D> ExactSizeIterator for LanesIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}","impl<'a, A, D> Iterator for LanesIterMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = ArrayViewMut<'a, A, Ix1>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|ptr| unsafe {\n            ArrayViewMut::new_(ptr, Ix1(self.inner_len), Ix1(self.inner_stride as Ix))\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","unsafe impl<'a, A, D> Send for $name<'a, A, D>\n        where\n            A: Send,\n            D: Send,\n        {\n        }","unsafe impl<'a, A, D> Sync for $name<'a, A, D>\n        where\n            A: Sync,\n            D: Sync,\n        {\n        }"],"iterators::chunks::ExactChunks":["impl<$($cloneparm)*> Clone for $fulltype {\n        fn clone(&self) -> Self {\n            $typename {\n                $base: self.base.clone(),\n                $(\n                $fieldname: self.$fieldname.clone(),\n                )*\n            }\n        }\n    }","impl<$($typarm)*> NdProducer for $fulltype {\n    $(\n        type $atyn = $atyv;\n    )*\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn raw_dim(&self) -> D {\n        self.$base.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.$base.layout()\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.$base.as_ptr() as *mut _\n    }\n\n    #[doc(hidden)]\n    fn contiguous_stride(&self) -> isize {\n        self.$base.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item {\n        $refexpr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.$base.uget_ptr(i)\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.$base.stride_of(axis)\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }\n    private_impl!{}\n}","impl<'a, A, D: Dimension> ExactChunks<'a, A, D> {\n    /// Creates a new exact chunks producer.\n    ///\n    /// **Panics** if any chunk dimension is zero\n    pub(crate) fn new<E>(mut a: ArrayView<'a, A, D>, chunk: E) -> Self\n    where\n        E: IntoDimension<Dim = D>,\n    {\n        let chunk = chunk.into_dimension();\n        ndassert!(\n            a.ndim() == chunk.ndim(),\n            concat!(\n                \"Chunk dimension {} does not match array dimension {} \",\n                \"(with array of shape {:?})\"\n            ),\n            chunk.ndim(),\n            a.ndim(),\n            a.shape()\n        );\n        for i in 0..a.ndim() {\n            a.dim[i] /= chunk[i];\n        }\n        let inner_strides = a.raw_strides();\n        a.strides *= &chunk;\n\n        ExactChunks {\n            base: a,\n            chunk,\n            inner_strides,\n        }\n    }\n}","impl<'a, A, D> IntoIterator for ExactChunks<'a, A, D>\nwhere\n    D: Dimension,\n    A: 'a,\n{\n    type Item = <Self::IntoIter as Iterator>::Item;\n    type IntoIter = ExactChunksIter<'a, A, D>;\n    fn into_iter(self) -> Self::IntoIter {\n        ExactChunksIter {\n            iter: self.base.into_elements_base(),\n            chunk: self.chunk,\n            inner_strides: self.inner_strides,\n        }\n    }\n}"],"iterators::chunks::ExactChunksIter":["impl<$($cloneparm)*> Clone for $fulltype {\n                fn clone(&self) -> Self {\n                    $typename {\n                        $base: self.$base.clone(),\n                        $(\n                            $fieldname: self.$fieldname.clone(),\n                        )*\n                    }\n                }\n            }","impl<$($typarm)*> Iterator for $fulltype {\n            type Item = $ity;\n\n            fn next(&mut $self_) -> Option<Self::Item> {\n                $self_.$base.next().map(|$elt| {\n                    $refexpr\n                })\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.$base.size_hint()\n            }\n        }"],"iterators::chunks::ExactChunksIterMut":["impl<$($typarm)*> Iterator for $fulltype {\n            type Item = $ity;\n\n            fn next(&mut $self_) -> Option<Self::Item> {\n                $self_.$base.next().map(|$elt| {\n                    $refexpr\n                })\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.$base.size_hint()\n            }\n        }"],"iterators::chunks::ExactChunksMut":["impl<$($typarm)*> NdProducer for $fulltype {\n    $(\n        type $atyn = $atyv;\n    )*\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn raw_dim(&self) -> D {\n        self.$base.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.$base.layout()\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.$base.as_ptr() as *mut _\n    }\n\n    #[doc(hidden)]\n    fn contiguous_stride(&self) -> isize {\n        self.$base.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item {\n        $refexpr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.$base.uget_ptr(i)\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.$base.stride_of(axis)\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }\n    private_impl!{}\n}","impl<'a, A, D: Dimension> ExactChunksMut<'a, A, D> {\n    /// Creates a new exact chunks producer.\n    ///\n    /// **Panics** if any chunk dimension is zero\n    pub(crate) fn new<E>(mut a: ArrayViewMut<'a, A, D>, chunk: E) -> Self\n    where\n        E: IntoDimension<Dim = D>,\n    {\n        let chunk = chunk.into_dimension();\n        ndassert!(\n            a.ndim() == chunk.ndim(),\n            concat!(\n                \"Chunk dimension {} does not match array dimension {} \",\n                \"(with array of shape {:?})\"\n            ),\n            chunk.ndim(),\n            a.ndim(),\n            a.shape()\n        );\n        for i in 0..a.ndim() {\n            a.dim[i] /= chunk[i];\n        }\n        let inner_strides = a.raw_strides();\n        a.strides *= &chunk;\n\n        ExactChunksMut {\n            base: a,\n            chunk,\n            inner_strides,\n        }\n    }\n}","impl<'a, A, D> IntoIterator for ExactChunksMut<'a, A, D>\nwhere\n    D: Dimension,\n    A: 'a,\n{\n    type Item = <Self::IntoIter as Iterator>::Item;\n    type IntoIter = ExactChunksIterMut<'a, A, D>;\n    fn into_iter(self) -> Self::IntoIter {\n        ExactChunksIterMut {\n            iter: self.base.into_elements_base(),\n            chunk: self.chunk,\n            inner_strides: self.inner_strides,\n        }\n    }\n}"],"iterators::lanes::Lanes":["impl<$($cloneparm)*> Clone for $fulltype {\n        fn clone(&self) -> Self {\n            $typename {\n                $base: self.base.clone(),\n                $(\n                $fieldname: self.$fieldname.clone(),\n                )*\n            }\n        }\n    }","impl<$($typarm)*> NdProducer for $fulltype {\n    $(\n        type $atyn = $atyv;\n    )*\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn raw_dim(&self) -> D {\n        self.$base.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.$base.layout()\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.$base.as_ptr() as *mut _\n    }\n\n    #[doc(hidden)]\n    fn contiguous_stride(&self) -> isize {\n        self.$base.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item {\n        $refexpr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.$base.uget_ptr(i)\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.$base.stride_of(axis)\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }\n    private_impl!{}\n}","impl<'a, A, D: Dimension> Lanes<'a, A, D> {\n    pub(crate) fn new<Di>(v: ArrayView<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: Dimension<Smaller = D>,\n    {\n        let ndim = v.ndim();\n        let len;\n        let stride;\n        let iter_v;\n        if ndim == 0 {\n            len = 1;\n            stride = 1;\n            iter_v = v.try_remove_axis(Axis(0))\n        } else {\n            let i = axis.index();\n            len = v.dim[i];\n            stride = v.strides[i] as isize;\n            iter_v = v.try_remove_axis(axis)\n        }\n        Lanes {\n            inner_len: len,\n            inner_stride: stride,\n            base: iter_v,\n        }\n    }\n}","impl<'a, A, D> IntoIterator for Lanes<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = <Self::IntoIter as Iterator>::Item;\n    type IntoIter = LanesIter<'a, A, D>;\n    fn into_iter(self) -> Self::IntoIter {\n        LanesIter {\n            iter: self.base.into_base_iter(),\n            inner_len: self.inner_len,\n            inner_stride: self.inner_stride,\n            life: PhantomData,\n        }\n    }\n}"],"iterators::lanes::LanesMut":["impl<$($typarm)*> NdProducer for $fulltype {\n    $(\n        type $atyn = $atyv;\n    )*\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn raw_dim(&self) -> D {\n        self.$base.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.$base.layout()\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.$base.as_ptr() as *mut _\n    }\n\n    #[doc(hidden)]\n    fn contiguous_stride(&self) -> isize {\n        self.$base.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item {\n        $refexpr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.$base.uget_ptr(i)\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.$base.stride_of(axis)\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }\n    private_impl!{}\n}","impl<'a, A, D: Dimension> LanesMut<'a, A, D> {\n    pub(crate) fn new<Di>(v: ArrayViewMut<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: Dimension<Smaller = D>,\n    {\n        let ndim = v.ndim();\n        let len;\n        let stride;\n        let iter_v;\n        if ndim == 0 {\n            len = 1;\n            stride = 1;\n            iter_v = v.try_remove_axis(Axis(0))\n        } else {\n            let i = axis.index();\n            len = v.dim[i];\n            stride = v.strides[i] as isize;\n            iter_v = v.try_remove_axis(axis)\n        }\n        LanesMut {\n            inner_len: len,\n            inner_stride: stride,\n            base: iter_v,\n        }\n    }\n}","impl<'a, A, D> IntoIterator for LanesMut<'a, A, D>\nwhere\n    D: Dimension,\n{\n    type Item = <Self::IntoIter as Iterator>::Item;\n    type IntoIter = LanesIterMut<'a, A, D>;\n    fn into_iter(self) -> Self::IntoIter {\n        LanesIterMut {\n            iter: self.base.into_base_iter(),\n            inner_len: self.inner_len,\n            inner_stride: self.inner_stride,\n            life: PhantomData,\n        }\n    }\n}"],"iterators::windows::Windows":["impl<$($cloneparm)*> Clone for $fulltype {\n        fn clone(&self) -> Self {\n            $typename {\n                $base: self.base.clone(),\n                $(\n                $fieldname: self.$fieldname.clone(),\n                )*\n            }\n        }\n    }","impl<$($typarm)*> NdProducer for $fulltype {\n    $(\n        type $atyn = $atyv;\n    )*\n    type Ptr = *mut A;\n    type Stride = isize;\n\n    #[doc(hidden)]\n    fn raw_dim(&self) -> D {\n        self.$base.raw_dim()\n    }\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout {\n        self.$base.layout()\n    }\n\n    #[doc(hidden)]\n    fn as_ptr(&self) -> *mut A {\n        self.$base.as_ptr() as *mut _\n    }\n\n    #[doc(hidden)]\n    fn contiguous_stride(&self) -> isize {\n        self.$base.contiguous_stride()\n    }\n\n    #[doc(hidden)]\n    unsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item {\n        $refexpr\n    }\n\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A {\n        self.$base.uget_ptr(i)\n    }\n\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> isize {\n        self.$base.stride_of(axis)\n    }\n\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self) {\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }\n    private_impl!{}\n}","impl<'a, A, D: Dimension> Windows<'a, A, D> {\n    pub(crate) fn new<E>(a: ArrayView<'a, A, D>, window_size: E) -> Self\n    where\n        E: IntoDimension<Dim = D>,\n    {\n        let window = window_size.into_dimension();\n        ndassert!(\n            a.ndim() == window.ndim(),\n            concat!(\n                \"Window dimension {} does not match array dimension {} \",\n                \"(with array of shape {:?})\"\n            ),\n            window.ndim(),\n            a.ndim(),\n            a.shape()\n        );\n        let mut size = a.dim;\n        for (sz, &ws) in size.slice_mut().iter_mut().zip(window.slice()) {\n            assert_ne!(ws, 0, \"window-size must not be zero!\");\n            // cannot use std::cmp::max(0, ..) since arithmetic underflow panics\n            *sz = if *sz < ws { 0 } else { *sz - ws + 1 };\n        }\n\n        let window_strides = a.strides.clone();\n\n        unsafe {\n            Windows {\n                base: ArrayView::from_shape_ptr(size.strides(a.strides), a.ptr.as_ptr()),\n                window,\n                strides: window_strides,\n            }\n        }\n    }\n}","impl<'a, A, D> IntoIterator for Windows<'a, A, D>\nwhere\n    D: Dimension,\n    A: 'a,\n{\n    type Item = <Self::IntoIter as Iterator>::Item;\n    type IntoIter = WindowsIter<'a, A, D>;\n    fn into_iter(self) -> Self::IntoIter {\n        WindowsIter {\n            iter: self.base.into_elements_base(),\n            window: self.window,\n            strides: self.strides,\n        }\n    }\n}"],"iterators::windows::WindowsIter":["impl<$($cloneparm)*> Clone for $fulltype {\n                fn clone(&self) -> Self {\n                    $typename {\n                        $base: self.$base.clone(),\n                        $(\n                            $fieldname: self.$fieldname.clone(),\n                        )*\n                    }\n                }\n            }","impl<$($typarm)*> Iterator for $fulltype {\n            type Item = $ity;\n\n            fn next(&mut $self_) -> Option<Self::Item> {\n                $self_.$base.next().map(|$elt| {\n                    $refexpr\n                })\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.$base.size_hint()\n            }\n        }"],"layout::Layout":["Clone","Copy","impl Layout {\n    #[doc(hidden)]\n    #[inline(always)]\n    pub fn one_dimensional() -> Layout {\n        Layout(CORDER | FORDER)\n    }\n    #[doc(hidden)]\n    #[inline(always)]\n    pub fn c() -> Layout {\n        Layout(CORDER)\n    }\n    #[doc(hidden)]\n    #[inline(always)]\n    pub fn f() -> Layout {\n        Layout(FORDER)\n    }\n    #[inline(always)]\n    #[doc(hidden)]\n    pub fn none() -> Layout {\n        Layout(0)\n    }\n}","impl Layout {\n    #[inline(always)]\n    pub(crate) fn new(x: u32) -> Self {\n        Layout(x)\n    }\n\n    #[inline(always)]\n    pub(crate) fn is(self, flag: u32) -> bool {\n        self.0 & flag != 0\n    }\n    #[inline(always)]\n    pub(crate) fn and(self, flag: Layout) -> Layout {\n        Layout(self.0 & flag.0)\n    }\n\n    #[inline(always)]\n    pub(crate) fn flag(self) -> u32 {\n        self.0\n    }\n}","impl fmt::Debug for Layout {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.0 == 0 {\n            write!(f, \"Custom\")?\n        } else {\n            (0..32).filter(|&i| self.is(1 << i)).try_fold((), |_, i| {\n                if let Some(name) = LAYOUT_NAMES.get(i) {\n                    write!(f, \"{}\", name)\n                } else {\n                    write!(f, \"{:#x}\", i)\n                }\n            })?;\n        };\n        write!(f, \" ({:#x})\", self.0)\n    }\n}"],"linspace::Linspace":["impl<F> DoubleEndedIterator for Linspace<F>\nwhere\n    F: Float,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<F> {\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            self.len -= 1;\n            let i = self.len;\n            Some(self.start + self.step * F::from(i).unwrap())\n        }\n    }\n}","impl<F> ExactSizeIterator for Linspace<F> where Linspace<F>: Iterator {}","impl<F> Iterator for Linspace<F>\nwhere\n    F: Float,\n{\n    type Item = F;\n\n    #[inline]\n    fn next(&mut self) -> Option<F> {\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            let i = self.index;\n            self.index += 1;\n            Some(self.start + self.step * F::from(i).unwrap())\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len - self.index;\n        (n, Some(n))\n    }\n}","unsafe impl<F> TrustedIterator for Linspace<F> {}"],"logspace::Logspace":["impl<F> DoubleEndedIterator for Logspace<F>\nwhere\n    F: Float,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<F> {\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            self.len -= 1;\n            let i = self.len;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * self.base.powf(exponent))\n        }\n    }\n}","impl<F> ExactSizeIterator for Logspace<F> where Logspace<F>: Iterator {}","impl<F> Iterator for Logspace<F>\nwhere\n    F: Float,\n{\n    type Item = F;\n\n    #[inline]\n    fn next(&mut self) -> Option<F> {\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            let i = self.index;\n            self.index += 1;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * self.base.powf(exponent))\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len - self.index;\n        (n, Some(n))\n    }\n}","unsafe impl<F> TrustedIterator for Logspace<F> {}"],"num_complex::Complex":["impl ScalarOperand for Complex<f32> {}","impl ScalarOperand for Complex<f64> {}","impl<'a, S, D> $trt<&'a ArrayBase<S, D>> for $scalar\n    where S: Data<Elem=$scalar>,\n          D: Dimension,\n{\n    type Output = Array<$scalar, D>;\n    fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D> {\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }\n}","impl<S, D> $trt<ArrayBase<S, D>> for $scalar\n    where S: DataOwned<Elem=$scalar> + DataMut,\n          D: Dimension,\n{\n    type Output = ArrayBase<S, D>;\n    fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D> {\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }\n}"],"slice::Slice":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl From<Range<$index>> for $self {\n            #[inline]\n            fn from(r: Range<$index>) -> $self {\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }\n        }","impl From<RangeFrom<$index>> for $self {\n            #[inline]\n            fn from(r: RangeFrom<$index>) -> $self {\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }\n        }","impl From<RangeFull> for Slice {\n    #[inline]\n    fn from(_: RangeFull) -> Slice {\n        Slice {\n            start: 0,\n            end: None,\n            step: 1,\n        }\n    }\n}","impl From<RangeInclusive<$index>> for $self {\n            #[inline]\n            fn from(r: RangeInclusive<$index>) -> $self {\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }\n        }","impl From<RangeTo<$index>> for $self {\n            #[inline]\n            fn from(r: RangeTo<$index>) -> $self {\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }\n        }","impl From<RangeToInclusive<$index>> for $self {\n            #[inline]\n            fn from(r: RangeToInclusive<$index>) -> $self {\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }\n        }","impl Slice {\n    /// Create a new `Slice` with the given extents.\n    ///\n    /// See also the `From` impls, converting from ranges; for example\n    /// `Slice::from(i..)` or `Slice::from(j..k)`.\n    ///\n    /// `step` must be nonzero.\n    /// (This method checks with a debug assertion that `step` is not zero.)\n    pub fn new(start: isize, end: Option<isize>, step: isize) -> Slice {\n        debug_assert_ne!(step, 0, \"Slice::new: step must be nonzero\");\n        Slice { start, end, step }\n    }\n\n    /// Create a new `Slice` with the given step size (multiplied with the\n    /// previous step size).\n    ///\n    /// `step` must be nonzero.\n    /// (This method checks with a debug assertion that `step` is not zero.)\n    #[inline]\n    pub fn step_by(self, step: isize) -> Self {\n        debug_assert_ne!(step, 0, \"Slice::step_by: step must be nonzero\");\n        Slice {\n            step: self.step * step,\n            ..self\n        }\n    }\n}","impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }"],"slice::SliceInfo":["Debug","impl<T, D> AsRef<SliceInfo<[SliceOrIndex], D>> for SliceInfo<T, D>\nwhere\n    T: AsRef<[SliceOrIndex]>,\n    D: Dimension,\n{\n    fn as_ref(&self) -> &SliceInfo<[SliceOrIndex], D> {\n        unsafe {\n            // This is okay because the only non-zero-sized member of\n            // `SliceInfo` is `indices`, so `&SliceInfo<[SliceOrIndex], D>`\n            // should have the same bitwise representation as\n            // `&[SliceOrIndex]`.\n            &*(self.indices.as_ref() as *const [SliceOrIndex]\n                as *const SliceInfo<[SliceOrIndex], D>)\n        }\n    }\n}","impl<T, D> AsRef<[SliceOrIndex]> for SliceInfo<T, D>\nwhere\n    T: AsRef<[SliceOrIndex]>,\n    D: Dimension,\n{\n    fn as_ref(&self) -> &[SliceOrIndex] {\n        self.indices.as_ref()\n    }\n}","impl<T, D> Clone for SliceInfo<T, D>\nwhere\n    T: Clone,\n    D: Dimension,\n{\n    fn clone(&self) -> Self {\n        SliceInfo {\n            out_dim: PhantomData,\n            indices: self.indices.clone(),\n        }\n    }\n}","impl<T, D> Copy for SliceInfo<T, D>\nwhere\n    T: Copy,\n    D: Dimension,\n{\n}","impl<T, D> SliceInfo<T, D>\nwhere\n    D: Dimension,\n{\n    /// Returns a new `SliceInfo` instance.\n    ///\n    /// If you call this method, you are guaranteeing that `out_dim` is\n    /// consistent with `indices`.\n    #[doc(hidden)]\n    pub unsafe fn new_unchecked(indices: T, out_dim: PhantomData<D>) -> SliceInfo<T, D> {\n        SliceInfo { out_dim, indices }\n    }\n}","impl<T, D> SliceInfo<T, D>\nwhere\n    T: AsRef<[SliceOrIndex]>,\n    D: Dimension,\n{\n    /// Returns a new `SliceInfo` instance.\n    ///\n    /// Errors if `D` is not consistent with `indices`.\n    pub fn new(indices: T) -> Result<SliceInfo<T, D>, ShapeError> {\n        if let Some(ndim) = D::NDIM {\n            if ndim != indices.as_ref().iter().filter(|s| s.is_slice()).count() {\n                return Err(ShapeError::from_kind(ErrorKind::IncompatibleShape));\n            }\n        }\n        Ok(SliceInfo {\n            out_dim: PhantomData,\n            indices,\n        })\n    }\n}","impl<T: ?Sized, D> Deref for SliceInfo<T, D>\nwhere\n    D: Dimension,\n{\n    type Target = T;\n    fn deref(&self) -> &Self::Target {\n        &self.indices\n    }\n}","impl<T: ?Sized, D> SliceInfo<T, D>\nwhere\n    T: AsRef<[SliceOrIndex]>,\n    D: Dimension,\n{\n    /// Returns the number of dimensions after calling\n    /// [`.slice()`](struct.ArrayBase.html#method.slice) (including taking\n    /// subviews).\n    ///\n    /// If `D` is a fixed-size dimension type, then this is equivalent to\n    /// `D::NDIM.unwrap()`. Otherwise, the value is calculated by iterating\n    /// over the ranges/indices.\n    pub fn out_ndim(&self) -> usize {\n        D::NDIM.unwrap_or_else(|| {\n            self.indices\n                .as_ref()\n                .iter()\n                .filter(|s| s.is_slice())\n                .count()\n        })\n    }\n}"],"slice::SliceOrIndex":["Debug","Eq","Hash","PartialEq","impl From<$index> for SliceOrIndex {\n            #[inline]\n            fn from(r: $index) -> SliceOrIndex {\n                SliceOrIndex::Index(r as isize)\n            }\n        }","impl From<Range<$index>> for $self {\n            #[inline]\n            fn from(r: Range<$index>) -> $self {\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }\n        }","impl From<RangeFrom<$index>> for $self {\n            #[inline]\n            fn from(r: RangeFrom<$index>) -> $self {\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }\n        }","impl From<RangeFull> for SliceOrIndex {\n    #[inline]\n    fn from(_: RangeFull) -> SliceOrIndex {\n        SliceOrIndex::Slice {\n            start: 0,\n            end: None,\n            step: 1,\n        }\n    }\n}","impl From<RangeInclusive<$index>> for $self {\n            #[inline]\n            fn from(r: RangeInclusive<$index>) -> $self {\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }\n        }","impl From<RangeTo<$index>> for $self {\n            #[inline]\n            fn from(r: RangeTo<$index>) -> $self {\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }\n        }","impl From<RangeToInclusive<$index>> for $self {\n            #[inline]\n            fn from(r: RangeToInclusive<$index>) -> $self {\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }\n        }","impl From<Slice> for SliceOrIndex {\n    #[inline]\n    fn from(s: Slice) -> SliceOrIndex {\n        SliceOrIndex::Slice {\n            start: s.start,\n            end: s.end,\n            step: s.step,\n        }\n    }\n}","impl SliceOrIndex {\n    /// Returns `true` if `self` is a `Slice` value.\n    pub fn is_slice(&self) -> bool {\n        match self {\n            SliceOrIndex::Slice { .. } => true,\n            _ => false,\n        }\n    }\n\n    /// Returns `true` if `self` is an `Index` value.\n    pub fn is_index(&self) -> bool {\n        match self {\n            SliceOrIndex::Index(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns a new `SliceOrIndex` with the given step size (multiplied with\n    /// the previous step size).\n    ///\n    /// `step` must be nonzero.\n    /// (This method checks with a debug assertion that `step` is not zero.)\n    #[inline]\n    pub fn step_by(self, step: isize) -> Self {\n        debug_assert_ne!(step, 0, \"SliceOrIndex::step_by: step must be nonzero\");\n        match self {\n            SliceOrIndex::Slice {\n                start,\n                end,\n                step: orig_step,\n            } => SliceOrIndex::Slice {\n                start,\n                end,\n                step: orig_step * step,\n            },\n            SliceOrIndex::Index(s) => SliceOrIndex::Index(s),\n        }\n    }\n}","impl fmt::Display for SliceOrIndex {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            SliceOrIndex::Index(index) => write!(f, \"{}\", index)?,\n            SliceOrIndex::Slice { start, end, step } => {\n                if start != 0 {\n                    write!(f, \"{}\", start)?;\n                }\n                write!(f, \"..\")?;\n                if let Some(i) = end {\n                    write!(f, \"{}\", i)?;\n                }\n                if step != 1 {\n                    write!(f, \";{}\", step)?;\n                }\n            }\n        }\n        Ok(())\n    }\n}","impl<$($parm)*> Clone for $type_ {\n            #[inline(always)]\n            fn clone(&self) -> Self { *self }\n        }","impl<$($parm)*> Copy for $type_ { }"],"std::iter::Cloned":["unsafe impl<I> TrustedIterator for std::iter::Cloned<I> where I: TrustedIterator {}"],"std::iter::Map":["unsafe impl<I, F> TrustedIterator for std::iter::Map<I, F> where I: TrustedIterator {}"],"std::ops::Range":["impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }","unsafe impl TrustedIterator for ::std::ops::Range<usize> {}"],"std::ops::RangeFrom":["impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }"],"std::ops::RangeFull":["impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }"],"std::ops::RangeInclusive":["impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }"],"std::ops::RangeTo":["impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }"],"std::ops::RangeToInclusive":["impl<D1: Dimension, $($generics)*> SliceNextDim<D1, D1::Larger> for $self {\n            fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger> {\n                PhantomData\n            }\n        }"],"std::slice::Iter":["unsafe impl<'a, A> TrustedIterator for slice::Iter<'a, A> {}"],"std::slice::IterMut":["unsafe impl<'a, A> TrustedIterator for slice::IterMut<'a, A> {}"],"std::vec::Vec":["impl IntoDimension for Vec<Ix> {\n    type Dim = IxDyn;\n    #[inline(always)]\n    fn into_dimension(self) -> Self::Dim {\n        Dim::new(IxDynImpl::from(self))\n    }\n}"],"zip::FoldWhile":["Clone","Copy","Debug","impl<T> FoldWhile<T> {\n    /// Return the inner value\n    pub fn into_inner(self) -> T {\n        match self {\n            FoldWhile::Continue(x) | FoldWhile::Done(x) => x,\n        }\n    }\n\n    /// Return true if it is `Done`, false if `Continue`\n    pub fn is_done(&self) -> bool {\n        match *self {\n            FoldWhile::Continue(_) => false,\n            FoldWhile::Done(_) => true,\n        }\n    }\n}"],"zip::Zip":["Clone","Debug","impl<D, $($p),*> Zip<($($p,)*), D>\n            where D: Dimension,\n                  $($p: NdProducer<Dim=D> ,)*\n        {\n            /// Apply a function to all elements of the input arrays,\n            /// visiting elements in lock step.\n            pub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*)\n            {\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }\n\n            /// Apply a fold function to all elements of the input arrays,\n            /// visiting elements in lock step.\n            ///\n            /// # Example\n            ///\n            /// The expression `tr(AB)` can be more efficiently computed as\n            /// the equivalent expression `(AB)` (i.e. the sum of the\n            /// elements of the entry-wise product). It would be possible to\n            /// evaluate this expression by first computing the entry-wise\n            /// product, `AB`, and then computing the elementwise sum of that\n            /// product, but it's possible to do this in a single loop (and\n            /// avoid an extra heap allocation if `A` and `B` can't be\n            /// consumed) by using `Zip`:\n            ///\n            /// ```\n            /// use ndarray::{array, Zip};\n            ///\n            /// let a = array![[1, 5], [3, 7]];\n            /// let b = array![[2, 4], [8, 6]];\n            ///\n            /// // Without using `Zip`. This involves two loops and an extra\n            /// // heap allocation for the result of `&a * &b`.\n            /// let sum_prod_nonzip = (&a * &b).sum();\n            /// // Using `Zip`. This is a single loop without any heap allocations.\n            /// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n            ///\n            /// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n            /// ```\n            pub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,\n            {\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }\n\n            /// Apply a fold function to the input arrays while the return\n            /// value is `FoldWhile::Continue`, visiting elements in lock step.\n            ///\n            pub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>\n            {\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }\n\n            /// Tests if every element of the iterator matches a predicate.\n            ///\n            /// Returns `true` if `predicate` evaluates to `true` for all elements.\n            /// Returns `true` if the input arrays are empty.\n            ///\n            /// Example:\n            ///\n            /// ```\n            /// use ndarray::{array, Zip};\n            /// let a = array![1, 2, 3];\n            /// let b = array![1, 4, 9];\n            /// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n            /// ```\n            pub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool\n            {\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }\n\n            expand_if!(@bool [$notlast]\n\n            /// Include the producer `p` in the Zip.\n            ///\n            /// ***Panics*** if `p`s shape doesnt match the Zips exactly.\n            pub fn and<P>(self, p: P) -> Zip<($($p,)* P::Output, ), D>\n                where P: IntoNdProducer<Dim=D>,\n            {\n                let array = p.into_producer();\n                self.check(&array);\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }\n\n            /// Include the producer `p` in the Zip, broadcasting if needed.\n            ///\n            /// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n            ///\n            /// ***Panics*** if broadcasting isnt possible.\n            pub fn and_broadcast<'a, P, D2, Elem>(self, p: P)\n                -> Zip<($($p,)* ArrayView<'a, Elem, D>, ), D>\n                where P: IntoNdProducer<Dim=D2, Output=ArrayView<'a, Elem, D2>, Item=&'a Elem>,\n                      D2: Dimension,\n            {\n                let array = p.into_producer().broadcast_unwrap(self.dimension.clone());\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }\n\n            /// Apply and collect the results into a new array, which has the same size as the\n            /// inputs.\n            ///\n            /// If all inputs are c- or f-order respectively, that is preserved in the output.\n            ///\n            /// Restricted to functions that produce copyable results for technical reasons; other\n            /// cases are not yet implemented.\n            pub fn apply_collect<R>(self, f: impl FnMut($($p::Item,)* ) -> R) -> Array<R, D>\n                where R: Copy,\n            {\n                // To support non-Copy elements, implementation of dropping partial array (on\n                // panic) is needed\n                let mut output = self.uninitalized_for_current_layout::<R>();\n                self.apply_assign_into(&mut output, f);\n                unsafe {\n                    output.assume_init()\n                }\n            }\n\n            /// Apply and assign the results into the producer `into`, which should have the same\n            /// size as the other inputs.\n            ///\n            /// The producer should have assignable items as dictated by the `AssignElem` trait,\n            /// for example `&mut R`.\n            pub fn apply_assign_into<R, Q>(self, into: Q, mut f: impl FnMut($($p::Item,)* ) -> R)\n                where Q: IntoNdProducer<Dim=D>,\n                      Q::Item: AssignElem<R>\n            {\n                self.and(into)\n                    .apply(move |$($p, )* output_| {\n                        output_.assign_elem(f($($p ),*));\n                    });\n            }\n\n\n            );\n\n            /// Split the `Zip` evenly in two.\n            ///\n            /// It will be split in the way that best preserves element locality.\n            pub fn split(self) -> (Self, Self) {\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }\n        }","impl<P, D> Zip<(Indices<D>, P), D>\nwhere\n    D: Dimension + Copy,\n    P: NdProducer<Dim = D>,\n{\n    /// Create a new `Zip` with an index producer and the producer `p`.\n    ///\n    /// The Zip will take the exact dimension of `p` and all inputs\n    /// must have the same dimensions (or be broadcast to them).\n    ///\n    /// *Note:* Indexed zip has overhead.\n    pub fn indexed<IP>(p: IP) -> Self\n    where\n        IP: IntoNdProducer<Dim = D, Output = P, Item = P::Item>,\n    {\n        let array = p.into_producer();\n        let dim = array.raw_dim();\n        Zip::from(indices(dim)).and(array)\n    }\n}","impl<P, D> Zip<(P,), D>\nwhere\n    D: Dimension,\n    P: NdProducer<Dim = D>,\n{\n    /// Create a new `Zip` from the input array or other producer `p`.\n    ///\n    /// The Zip will take the exact dimension of `p` and all inputs\n    /// must have the same dimensions (or be broadcast to them).\n    pub fn from<IP>(p: IP) -> Self\n    where\n        IP: IntoNdProducer<Dim = D, Output = P, Item = P::Item>,\n    {\n        let array = p.into_producer();\n        let dim = array.raw_dim();\n        Zip {\n            dimension: dim,\n            layout: array.layout(),\n            parts: (array,),\n        }\n    }\n}","impl<P, D> Zip<P, D>\nwhere\n    D: Dimension,\n{\n    fn apply_core<F, Acc>(&mut self, acc: Acc, function: F) -> FoldWhile<Acc>\n    where\n        F: FnMut(Acc, P::Item) -> FoldWhile<Acc>,\n        P: ZippableTuple<Dim = D>,\n    {\n        if self.layout.is(CORDER | FORDER) {\n            self.apply_core_contiguous(acc, function)\n        } else {\n            self.apply_core_strided(acc, function)\n        }\n    }\n    fn apply_core_contiguous<F, Acc>(&mut self, mut acc: Acc, mut function: F) -> FoldWhile<Acc>\n    where\n        F: FnMut(Acc, P::Item) -> FoldWhile<Acc>,\n        P: ZippableTuple<Dim = D>,\n    {\n        debug_assert!(self.layout.is(CORDER | FORDER));\n        let size = self.dimension.size();\n        let ptrs = self.parts.as_ptr();\n        let inner_strides = self.parts.contiguous_stride();\n        for i in 0..size {\n            unsafe {\n                let ptr_i = ptrs.stride_offset(inner_strides, i);\n                acc = fold_while![function(acc, self.parts.as_ref(ptr_i))];\n            }\n        }\n        FoldWhile::Continue(acc)\n    }\n\n    fn apply_core_strided<F, Acc>(&mut self, mut acc: Acc, mut function: F) -> FoldWhile<Acc>\n    where\n        F: FnMut(Acc, P::Item) -> FoldWhile<Acc>,\n        P: ZippableTuple<Dim = D>,\n    {\n        let n = self.dimension.ndim();\n        if n == 0 {\n            panic!(\"Unreachable: ndim == 0 is contiguous\")\n        }\n        let unroll_axis = n - 1;\n        let inner_len = self.dimension[unroll_axis];\n        self.dimension[unroll_axis] = 1;\n        let mut index_ = self.dimension.first_index();\n        let inner_strides = self.parts.stride_of(unroll_axis);\n        while let Some(index) = index_ {\n            // Let's unroll the loop over the innermost axis\n            unsafe {\n                let ptr = self.parts.uget_ptr(&index);\n                for i in 0..inner_len {\n                    let p = ptr.stride_offset(inner_strides, i);\n                    acc = fold_while!(function(acc, self.parts.as_ref(p)));\n                }\n            }\n\n            index_ = self.dimension.next_for(index);\n        }\n        self.dimension[unroll_axis] = inner_len;\n        FoldWhile::Continue(acc)\n    }\n\n    pub(crate) fn uninitalized_for_current_layout<T>(&self) -> Array<MaybeUninit<T>, D>\n    {\n        let is_f = !self.layout.is(CORDER) && self.layout.is(FORDER);\n        Array::maybe_uninit(self.dimension.clone().set_f(is_f))\n    }\n}","impl<Parts, D> Zip<Parts, D>\nwhere\n    D: Dimension,\n{\n    fn check<P>(&self, part: &P)\n    where\n        P: NdProducer<Dim = D>,\n    {\n        ndassert!(\n            part.equal_dim(&self.dimension),\n            \"Zip: Producer dimension mismatch, expected: {:?}, got: {:?}\",\n            self.dimension,\n            part.raw_dim()\n        );\n    }\n\n    /// Return a the number of element tuples in the Zip\n    pub fn size(&self) -> usize {\n        self.dimension.size()\n    }\n\n    /// Return the length of `axis`\n    ///\n    /// ***Panics*** if `axis` is out of bounds.\n    fn len_of(&self, axis: Axis) -> usize {\n        self.dimension[axis.index()]\n    }\n\n    /// Return an *approximation* to the max stride axis; if\n    /// component arrays disagree, there may be no choice better than the\n    /// others.\n    fn max_stride_axis(&self) -> Axis {\n        let i = match self.layout.flag() {\n            FORDER => self\n                .dimension\n                .slice()\n                .iter()\n                .rposition(|&len| len > 1)\n                .unwrap_or(self.dimension.ndim() - 1),\n            /* corder or default */\n            _ => self\n                .dimension\n                .slice()\n                .iter()\n                .position(|&len| len > 1)\n                .unwrap_or(0),\n        };\n        Axis(i)\n    }\n}"]},"single_path_import":{"ArcArray":"prelude::ArcArray","Array":"prelude::Array","ArrayBase":"prelude::ArrayBase","ArrayView":"prelude::ArrayView","ArrayViewMut":"prelude::ArrayViewMut","CowArray":"prelude::CowArray","CowRepr":"imp_prelude::CowRepr","Ix":"imp_prelude::Ix","Ixs":"imp_prelude::Ixs","OwnedArcRepr":"OwnedArcRepr","RawArrayView":"prelude::RawArrayView","RawArrayViewMut":"prelude::RawArrayViewMut","RawViewRepr":"imp_prelude::RawViewRepr","RcArray":"prelude::RcArray","ViewRepr":"imp_prelude::ViewRepr","aliases::Array0":"prelude::Array0","aliases::Array1":"prelude::Array1","aliases::Array2":"prelude::Array2","aliases::Array3":"prelude::Array3","aliases::Array4":"prelude::Array4","aliases::Array5":"prelude::Array5","aliases::Array6":"prelude::Array6","aliases::ArrayD":"prelude::ArrayD","aliases::ArrayView0":"prelude::ArrayView0","aliases::ArrayView1":"prelude::ArrayView1","aliases::ArrayView2":"prelude::ArrayView2","aliases::ArrayView3":"prelude::ArrayView3","aliases::ArrayView4":"prelude::ArrayView4","aliases::ArrayView5":"prelude::ArrayView5","aliases::ArrayView6":"prelude::ArrayView6","aliases::ArrayViewD":"prelude::ArrayViewD","aliases::ArrayViewMut0":"prelude::ArrayViewMut0","aliases::ArrayViewMut1":"prelude::ArrayViewMut1","aliases::ArrayViewMut2":"prelude::ArrayViewMut2","aliases::ArrayViewMut3":"prelude::ArrayViewMut3","aliases::ArrayViewMut4":"prelude::ArrayViewMut4","aliases::ArrayViewMut5":"prelude::ArrayViewMut5","aliases::ArrayViewMut6":"prelude::ArrayViewMut6","aliases::ArrayViewMutD":"prelude::ArrayViewMutD","aliases::Ix0":"prelude::Ix0","aliases::Ix1":"prelude::Ix1","aliases::Ix2":"prelude::Ix2","aliases::Ix3":"prelude::Ix3","aliases::Ix4":"prelude::Ix4","aliases::Ix5":"prelude::Ix5","aliases::Ix6":"prelude::Ix6","aliases::IxDyn":"prelude::IxDyn","argument_traits::AssignElem":"AssignElem","arraytraits::AsArray":"prelude::AsArray","data_repr::OwnedRepr":"OwnedRepr","data_traits::Data":"imp_prelude::Data","data_traits::DataClone":"DataClone","data_traits::DataMut":"imp_prelude::DataMut","data_traits::DataOwned":"imp_prelude::DataOwned","data_traits::DataShared":"imp_prelude::DataShared","data_traits::RawData":"imp_prelude::RawData","data_traits::RawDataClone":"RawDataClone","data_traits::RawDataMut":"imp_prelude::RawDataMut","data_traits::RawDataSubst":"RawDataSubst","dimension::DimensionExt":"imp_prelude::DimensionExt","dimension::axes::Axes":"dimension::Axes","dimension::axes::AxisDescription":"dimension::AxisDescription","dimension::axes::axes_of":"dimension::axes_of","dimension::axis::Axis":"prelude::Axis","dimension::conversion::IntoDimension":"dimension::IntoDimension","dimension::dim::Dim":"prelude::Dim","dimension::dimension_trait::Dimension":"prelude::Dimension","dimension::dynindeximpl::IxDynImpl":"dimension::IxDynImpl","dimension::ndindex::NdIndex":"dimension::NdIndex","dimension::remove_axis::RemoveAxis":"imp_prelude::RemoveAxis","error::ErrorKind":"ErrorKind","error::ShapeError":"ShapeError","free_functions::arr0":"prelude::arr0","free_functions::arr1":"prelude::arr1","free_functions::arr2":"prelude::arr2","free_functions::array":"prelude::array","free_functions::aview0":"prelude::aview0","free_functions::aview1":"prelude::aview1","free_functions::aview2":"prelude::aview2","free_functions::aview_mut1":"prelude::aview_mut1","impl_ops::ScalarOperand":"ScalarOperand","impl_views::indexing::IndexLonger":"IndexLonger","indexes::Indices":"iterators::iter::Indices","indexes::IndicesIter":"iterators::iter::IndicesIter","indexes::indices":"indices","indexes::indices_of":"indices_of","iterators::AxisChunksIter":"iterators::iter::AxisChunksIter","iterators::AxisChunksIterMut":"iterators::iter::AxisChunksIterMut","iterators::AxisIter":"iterators::iter::AxisIter","iterators::AxisIterMut":"iterators::iter::AxisIterMut","iterators::IndexedIter":"iterators::iter::IndexedIter","iterators::IndexedIterMut":"iterators::iter::IndexedIterMut","iterators::Iter":"iterators::iter::Iter","iterators::IterMut":"iterators::iter::IterMut","iterators::LanesIter":"iterators::iter::LanesIter","iterators::LanesIterMut":"iterators::iter::LanesIterMut","iterators::chunks::ExactChunks":"iterators::ExactChunks","iterators::chunks::ExactChunksIter":"iterators::ExactChunksIter","iterators::chunks::ExactChunksIterMut":"iterators::ExactChunksIterMut","iterators::chunks::ExactChunksMut":"iterators::ExactChunksMut","iterators::iter":"iter","iterators::lanes::Lanes":"iterators::Lanes","iterators::lanes::LanesMut":"iterators::LanesMut","iterators::windows::Windows":"iterators::Windows","layout::Layout":"Layout","linalg::impl_linalg::Dot":"linalg::Dot","linalg::impl_linalg::general_mat_mul":"linalg::general_mat_mul","linalg::impl_linalg::general_mat_vec_mul":"linalg::general_mat_vec_mul","linalg_traits::LinalgScalar":"LinalgScalar","linalg_traits::NdFloat":"prelude::NdFloat","shape_builder::ShapeBuilder":"prelude::ShapeBuilder","slice::Slice":"Slice","slice::SliceInfo":"SliceInfo","slice::SliceNextDim":"SliceNextDim","slice::SliceOrIndex":"SliceOrIndex","slice::s":"prelude::s","stacking::stack":"stack","zip::FoldWhile":"FoldWhile","zip::IntoNdProducer":"IntoNdProducer","zip::NdProducer":"NdProducer","zip::Zip":"Zip","zip::zipmacro::azip":"prelude::azip"},"srcs":{"<&'a ArrayBase<S, D> as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        self.view()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<&'a [A] as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        <_>::from(self)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<&'a [usize] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["fn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n        stride_offset_checked(dim.ix(), strides.ix(), *self)\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<&'a [usize] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["fn index_unchecked(&self, strides: &IxDyn) -> isize{\n        zip(strides.ix(), *self)\n            .map(|(&s, &i)| stride_offset(i, s))\n            .sum()\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<&'a dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["fn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n        (**self).index_checked(dim, strides)\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<&'a dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["fn index_unchecked(&self, strides: &IxDyn) -> isize{\n        (**self).index_unchecked(strides)\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<&'a dimension::dynindeximpl::IxDynImpl as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        self[..].iter()\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<&'a mut ArrayBase<S, D> as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        self.view_mut()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<&'a mut T as argument_traits::AssignElem<T>>::assign_elem":["fn assign_elem(self, input: T){\n        *self = input;\n    }","Real(LocalPath(\"src/argument_traits.rs\"))"],"<&'a mut [A] as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        <_>::from(self)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<&'a mut std::mem::MaybeUninit<T> as argument_traits::AssignElem<T>>::assign_elem":["fn assign_elem(self, input: T){\n        *self = MaybeUninit::new(input);\n    }","Real(LocalPath(\"src/argument_traits.rs\"))"],"<&'a mut std::vec::Vec<A> as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        <_>::from(self)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<&'a std::cell::Cell<T> as argument_traits::AssignElem<T>>::assign_elem":["fn assign_elem(self, input: T){\n        self.set(input);\n    }","Real(LocalPath(\"src/argument_traits.rs\"))"],"<&'a std::vec::Vec<A> as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        <_>::from(self)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::get":["fn get(self, index: I) -> Option<&'a A>{\n        unsafe { self.get_ptr(index).map(|ptr| &*ptr) }\n    }","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::index":["/// Get a reference of a element through the view.\n///\n/// This method is like `Index::index` but with a longer lifetime (matching\n/// the array view); which we can only do for the array view and not in the\n/// `Index` trait.\n///\n/// See also [the `get` method][1] which works for all arrays and array\n/// views.\n///\n/// [1]: struct.ArrayBase.html#method.get\n///\n/// **Panics** if index is out of bounds.\nfn index(self, index: I) -> &'a A{\n        debug_bounds_check!(self, index);\n        unsafe { &*self.get_ptr(index).unwrap_or_else(|| array_out_of_bounds()) }\n    }","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::uget":["/// Get a reference of a element through the view without boundary check\n///\n/// This method is like `elem` with a longer lifetime (matching the array\n/// view); which we can't do for general arrays.\n///\n/// See also [the `uget` method][1] which works for all arrays and array\n/// views.\n///\n/// [1]: struct.ArrayBase.html#method.uget\n///\n/// **Note:** only unchecked for non-debug builds of ndarray.\nunsafe fn uget(self, index: I) -> &'a A{\n        debug_bounds_check!(self, index);\n        &*self.as_ptr().offset(index.index_unchecked(&self.strides))\n    }","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"<&T as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n        T::multi_slice_move(self, view)\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n                #[allow(non_snake_case)]\n                let ($($all,)*) = self;\n\n                let shape = view.raw_dim();\n                assert!(!impl_multislice_tuple!(@intersects_self &shape, ($($all,)*)));\n\n                let raw_view = view.into_raw_view_mut();\n                unsafe {\n                    (\n                        $(raw_view.clone().slice_move($but_last).deref_into_view_mut(),)*\n                        raw_view.slice_move($last).deref_into_view_mut(),\n                    )\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n                #[allow(non_snake_case)]\n                let ($($all,)*) = self;\n\n                let shape = view.raw_dim();\n                assert!(!impl_multislice_tuple!(@intersects_self &shape, ($($all,)*)));\n\n                let raw_view = view.into_raw_view_mut();\n                unsafe {\n                    (\n                        $(raw_view.clone().slice_move($but_last).deref_into_view_mut(),)*\n                        raw_view.slice_move($last).deref_into_view_mut(),\n                    )\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n                #[allow(non_snake_case)]\n                let ($($all,)*) = self;\n\n                let shape = view.raw_dim();\n                assert!(!impl_multislice_tuple!(@intersects_self &shape, ($($all,)*)));\n\n                let raw_view = view.into_raw_view_mut();\n                unsafe {\n                    (\n                        $(raw_view.clone().slice_move($but_last).deref_into_view_mut(),)*\n                        raw_view.slice_move($last).deref_into_view_mut(),\n                    )\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n                #[allow(non_snake_case)]\n                let ($($all,)*) = self;\n\n                let shape = view.raw_dim();\n                assert!(!impl_multislice_tuple!(@intersects_self &shape, ($($all,)*)));\n\n                let raw_view = view.into_raw_view_mut();\n                unsafe {\n                    (\n                        $(raw_view.clone().slice_move($but_last).deref_into_view_mut(),)*\n                        raw_view.slice_move($last).deref_into_view_mut(),\n                    )\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do5>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n                #[allow(non_snake_case)]\n                let ($($all,)*) = self;\n\n                let shape = view.raw_dim();\n                assert!(!impl_multislice_tuple!(@intersects_self &shape, ($($all,)*)));\n\n                let raw_view = view.into_raw_view_mut();\n                unsafe {\n                    (\n                        $(raw_view.clone().slice_move($but_last).deref_into_view_mut(),)*\n                        raw_view.slice_move($last).deref_into_view_mut(),\n                    )\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>,) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output{\n        (view.slice_move(self.0),)\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<() as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<() as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &Ix0, strides: &Ix0) -> Option<isize>{\n        dim.stride_offset_checked(strides, &Ix0())\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<() as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_unchecked":["#[inline(always)]\nfn index_unchecked(&self, _strides: &Ix0) -> isize{\n        0\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<() as slice::MultiSlice<'a, A, D>>::multi_slice_move":["fn multi_slice_move(&self, _view: ArrayViewMut<'a, A, D>) -> Self::Output{}","Real(LocalPath(\"src/slice.rs\"))"],"<(A, B) as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n                let ($($param, )*) = self;\n                let ($($q, )*) = stride;\n                ($(Offset::stride_offset($param, $q, index),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B) as zip::ZippableTuple>::as_ptr":["fn as_ptr(&self) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.as_ptr(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B) as zip::ZippableTuple>::as_ref":["unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n                let ($(ref $q ,)*) = *self;\n                let ($($p,)*) = ptr;\n                ($($q.as_ref($p),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B) as zip::ZippableTuple>::contiguous_stride":["fn contiguous_stride(&self) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.contiguous_stride(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B) as zip::ZippableTuple>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n                let ($($p,)*) = self;\n                let ($($p,)*) = (\n                    $($p.split_at(axis, index), )*\n                );\n                (\n                    ($($p.0,)*),\n                    ($($p.1,)*)\n                )\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B) as zip::ZippableTuple>::stride_of":["fn stride_of(&self, index: usize) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.stride_of(Axis(index)), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B) as zip::ZippableTuple>::uget_ptr":["unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.uget_ptr(i), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n                let ($($param, )*) = self;\n                let ($($q, )*) = stride;\n                ($(Offset::stride_offset($param, $q, index),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::ZippableTuple>::as_ptr":["fn as_ptr(&self) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.as_ptr(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::ZippableTuple>::as_ref":["unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n                let ($(ref $q ,)*) = *self;\n                let ($($p,)*) = ptr;\n                ($($q.as_ref($p),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::ZippableTuple>::contiguous_stride":["fn contiguous_stride(&self) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.contiguous_stride(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::ZippableTuple>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n                let ($($p,)*) = self;\n                let ($($p,)*) = (\n                    $($p.split_at(axis, index), )*\n                );\n                (\n                    ($($p.0,)*),\n                    ($($p.1,)*)\n                )\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::ZippableTuple>::stride_of":["fn stride_of(&self, index: usize) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.stride_of(Axis(index)), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C) as zip::ZippableTuple>::uget_ptr":["unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.uget_ptr(i), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n                let ($($param, )*) = self;\n                let ($($q, )*) = stride;\n                ($(Offset::stride_offset($param, $q, index),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::ZippableTuple>::as_ptr":["fn as_ptr(&self) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.as_ptr(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::ZippableTuple>::as_ref":["unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n                let ($(ref $q ,)*) = *self;\n                let ($($p,)*) = ptr;\n                ($($q.as_ref($p),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::ZippableTuple>::contiguous_stride":["fn contiguous_stride(&self) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.contiguous_stride(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::ZippableTuple>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n                let ($($p,)*) = self;\n                let ($($p,)*) = (\n                    $($p.split_at(axis, index), )*\n                );\n                (\n                    ($($p.0,)*),\n                    ($($p.1,)*)\n                )\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::ZippableTuple>::stride_of":["fn stride_of(&self, index: usize) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.stride_of(Axis(index)), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D) as zip::ZippableTuple>::uget_ptr":["unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.uget_ptr(i), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n                let ($($param, )*) = self;\n                let ($($q, )*) = stride;\n                ($(Offset::stride_offset($param, $q, index),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::ZippableTuple>::as_ptr":["fn as_ptr(&self) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.as_ptr(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::ZippableTuple>::as_ref":["unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n                let ($(ref $q ,)*) = *self;\n                let ($($p,)*) = ptr;\n                ($($q.as_ref($p),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::ZippableTuple>::contiguous_stride":["fn contiguous_stride(&self) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.contiguous_stride(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::ZippableTuple>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n                let ($($p,)*) = self;\n                let ($($p,)*) = (\n                    $($p.split_at(axis, index), )*\n                );\n                (\n                    ($($p.0,)*),\n                    ($($p.1,)*)\n                )\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::ZippableTuple>::stride_of":["fn stride_of(&self, index: usize) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.stride_of(Axis(index)), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E) as zip::ZippableTuple>::uget_ptr":["unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.uget_ptr(i), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n                let ($($param, )*) = self;\n                let ($($q, )*) = stride;\n                ($(Offset::stride_offset($param, $q, index),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::as_ptr":["fn as_ptr(&self) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.as_ptr(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::as_ref":["unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n                let ($(ref $q ,)*) = *self;\n                let ($($p,)*) = ptr;\n                ($($q.as_ref($p),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::contiguous_stride":["fn contiguous_stride(&self) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.contiguous_stride(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n                let ($($p,)*) = self;\n                let ($($p,)*) = (\n                    $($p.split_at(axis, index), )*\n                );\n                (\n                    ($($p.0,)*),\n                    ($($p.1,)*)\n                )\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::stride_of":["fn stride_of(&self, index: usize) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.stride_of(Axis(index)), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::uget_ptr":["unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.uget_ptr(i), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n                let ($($param, )*) = self;\n                let ($($q, )*) = stride;\n                ($(Offset::stride_offset($param, $q, index),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::ZippableTuple>::as_ptr":["fn as_ptr(&self) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.as_ptr(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::ZippableTuple>::as_ref":["unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n                let ($(ref $q ,)*) = *self;\n                let ($($p,)*) = ptr;\n                ($($q.as_ref($p),)*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::ZippableTuple>::contiguous_stride":["fn contiguous_stride(&self) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.contiguous_stride(), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::ZippableTuple>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n                let ($($p,)*) = self;\n                let ($($p,)*) = (\n                    $($p.split_at(axis, index), )*\n                );\n                (\n                    ($($p.0,)*),\n                    ($($p.1,)*)\n                )\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::ZippableTuple>::stride_of":["fn stride_of(&self, index: usize) -> Self::Stride{\n                let ($(ref $p,)*) = *self;\n                ($($p.stride_of(Axis(index)), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(A,) as zip::ZippableTuple>::uget_ptr":["unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n                let ($(ref $p,)*) = *self;\n                ($($p.uget_ptr(i), )*)\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<(usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<(usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &Ix2, strides: &Ix2) -> Option<isize>{\n        dim.stride_offset_checked(strides, &Ix2(self.0, self.1))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &Ix2) -> isize{\n        stride_offset(self.0, get!(strides, 0)) + stride_offset(self.1, get!(strides, 1))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<(usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &Ix3, strides: &Ix3) -> Option<isize>{\n        dim.stride_offset_checked(strides, &self.into_dimension())\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &Ix3) -> isize{\n        stride_offset(self.0, get!(strides, 0))\n            + stride_offset(self.1, get!(strides, 1))\n            + stride_offset(self.2, get!(strides, 2))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<(usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &Ix4, strides: &Ix4) -> Option<isize>{\n        dim.stride_offset_checked(strides, &self.into_dimension())\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &Ix4) -> isize{\n        zip(strides.ix(), self.into_dimension().ix())\n            .map(|(&s, &i)| stride_offset(i, s))\n            .sum()\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<(usize, usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &Ix5, strides: &Ix5) -> Option<isize>{\n        dim.stride_offset_checked(strides, &self.into_dimension())\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &Ix5) -> isize{\n        zip(strides.ix(), self.into_dimension().ix())\n            .map(|(&s, &i)| stride_offset(i, s))\n            .sum()\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<(usize, usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<(usize,) as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(index!(array_expr [self] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<*const T as zip::Offset>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<*const T as zip::Offset>::stride_offset":["unsafe fn stride_offset(self, s: Self::Stride, index: usize) -> Self{\n        self.offset(s * (index as isize))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<*mut T as zip::Offset>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<*mut T as zip::Offset>::stride_offset":["unsafe fn stride_offset(self, s: Self::Stride, index: usize) -> Self{\n        self.offset(s * (index as isize))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<*mut T as zip::OffsetTuple>::stride_offset":["unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self{\n        self.offset(index as isize * stride)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *const A{\n        self.as_ptr()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: *const A) -> *const A{\n        ptr\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::contiguous_stride":["#[inline(always)]\nfn contiguous_stride(&self) -> Self::Stride{\n        1\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::equal_dim":["#[doc(hidden)]\nfn equal_dim(&self, dim: &Self::Dim) -> bool{\n        self.dim.equal(dim)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.layout_impl()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        self.raw_dim()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        self.split_at(axis, index)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.stride_of(axis)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *const A{\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.as_ptr() as _\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: *mut A) -> *mut A{\n        ptr\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::contiguous_stride":["#[inline(always)]\nfn contiguous_stride(&self) -> Self::Stride{\n        1\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::equal_dim":["#[doc(hidden)]\nfn equal_dim(&self, dim: &Self::Dim) -> bool{\n        self.dim.equal(dim)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.layout_impl()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        self.raw_dim()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        self.split_at(axis, index)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.stride_of(axis)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 1]>>>>::dot":["/// Compute the dot product of one-dimensional arrays.\n///\n/// The dot product is a sum of the elementwise products (no conjugation\n/// of complex operands, and thus not their inner product).\n///\n/// **Panics** if the arrays are not of the same length.<br>\n/// *Note:* If enabled, uses blas `dot` for elements of `f32, f64` when memory\n/// layout allows.\nfn dot(&self, rhs: &ArrayBase<S2, Ix1>) -> A{\n        self.dot_impl(rhs)\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 2]>>>>::dot":["/// Perform the matrix multiplication of the row vector `self` and\n/// rectangular matrix `rhs`.\n///\n/// The array shapes must agree in the way that\n/// if `self` is *M*, then `rhs` is *M*  *N*.\n///\n/// Return a result array with shape *N*.\n///\n/// **Panics** if shapes are incompatible.\nfn dot(&self, rhs: &ArrayBase<S2, Ix2>) -> Array<A, Ix1>{\n        rhs.t().dot(self)\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 1]>>>>::dot":["fn dot(&self, rhs: &ArrayBase<S2, Ix1>) -> Array<A, Ix1>{\n        let ((m, a), n) = (self.dim(), rhs.dim());\n        if a != n {\n            dot_shape_error(m, a, n, 1);\n        }\n\n        // Avoid initializing the memory in vec -- set it during iteration\n        unsafe {\n            let mut c = Array::uninitialized(m);\n            general_mat_vec_mul(A::one(), self, rhs, A::zero(), &mut c);\n            c\n        }\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 2]>>>>::dot":["fn dot(&self, b: &ArrayBase<S2, Ix2>) -> Array2<A>{\n        let a = self.view();\n        let b = b.view();\n        let ((m, k), (k2, n)) = (a.dim(), b.dim());\n        if k != k2 || m.checked_mul(n).is_none() {\n            dot_shape_error(m, k, k2, n);\n        }\n\n        let lhs_s0 = a.strides()[0];\n        let rhs_s0 = b.strides()[0];\n        let column_major = lhs_s0 == 1 && rhs_s0 == 1;\n        // A is Copy so this is safe\n        let mut v = Vec::with_capacity(m * n);\n        let mut c;\n        unsafe {\n            v.set_len(m * n);\n            c = Array::from_shape_vec_unchecked((m, n).set_f(column_major), v);\n        }\n        mat_mul_impl(A::one(), &a, &b, A::zero(), &mut c.view_mut());\n        c\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::broadcast_unwrap":["fn broadcast_unwrap(self, shape: E) -> Self::Output{\n        let res: ArrayView<'_, A, E::Dim> = (&self).broadcast_unwrap(shape.into_dimension());\n        unsafe { ArrayView::new(res.ptr, res.dim, res.strides) }\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.as_ptr() as _\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: *mut A) -> Self::Item{\n        &*ptr\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::contiguous_stride":["#[inline(always)]\nfn contiguous_stride(&self) -> Self::Stride{\n        1\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::equal_dim":["#[doc(hidden)]\nfn equal_dim(&self, dim: &Self::Dim) -> bool{\n        self.dim.equal(dim)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.layout_impl()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        self.raw_dim()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        self.split_at(axis, index)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.stride_of(axis)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::get":["/// Convert a mutable array view to a mutable reference of a element, with\n/// checked access.\n///\n/// See also [the `get_mut` method][1] which works for all arrays and array\n/// views.\n///\n/// [1]: struct.ArrayBase.html#method.get_mut\n///\nfn get(mut self, index: I) -> Option<&'a mut A>{\n        debug_bounds_check!(self, index);\n        unsafe {\n            match self.get_ptr_mut(index) {\n                Some(ptr) => Some(&mut *ptr),\n                None => None,\n            }\n        }\n    }","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::index":["/// Convert a mutable array view to a mutable reference of a element.\n///\n/// This method is like `IndexMut::index_mut` but with a longer lifetime\n/// (matching the array view); which we can only do for the array view and\n/// not in the `Index` trait.\n///\n/// See also [the `get_mut` method][1] which works for all arrays and array\n/// views.\n///\n/// [1]: struct.ArrayBase.html#method.get_mut\n///\n/// **Panics** if index is out of bounds.\nfn index(mut self, index: I) -> &'a mut A{\n        debug_bounds_check!(self, index);\n        unsafe {\n            match self.get_ptr_mut(index) {\n                Some(ptr) => &mut *ptr,\n                None => array_out_of_bounds(),\n            }\n        }\n    }","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::uget":["/// Convert a mutable array view to a mutable reference of a element without\n/// boundary check.\n///\n/// See also [the `uget_mut` method][1] which works for all arrays and array\n/// views.\n///\n/// [1]: struct.ArrayBase.html#method.uget_mut\n///\n/// **Note:** only unchecked for non-debug builds of ndarray.\nunsafe fn uget(mut self, index: I) -> &'a mut A{\n        debug_bounds_check!(self, index);\n        &mut *self\n            .as_mut_ptr()\n            .offset(index.index_unchecked(&self.strides))\n    }","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.as_ptr() as _\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: *mut A) -> Self::Item{\n        &mut *ptr\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::contiguous_stride":["#[inline(always)]\nfn contiguous_stride(&self) -> Self::Stride{\n        1\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::equal_dim":["#[doc(hidden)]\nfn equal_dim(&self, dim: &Self::Dim) -> bool{\n        self.dim.equal(dim)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.layout_impl()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        self.raw_dim()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        self.split_at(axis, index)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.stride_of(axis)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.ptr.as_ptr().offset(i.index_unchecked(&self.strides))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<CowRepr<'a, A> as data_traits::Data>::into_owned":["#[inline]\nfn into_owned<D>(self_: ArrayBase<CowRepr<'a, A>, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        A: Clone,\n        D: Dimension,{\n        match self_.data {\n            CowRepr::View(_) => self_.to_owned(),\n            CowRepr::Owned(data) => ArrayBase {\n                data,\n                ptr: self_.ptr,\n                dim: self_.dim,\n                strides: self_.strides,\n            },\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<CowRepr<'a, A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<CowRepr<'a, A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        match self {\n            CowRepr::View(view) => view._data_slice(),\n            CowRepr::Owned(data) => data._data_slice(),\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<CowRepr<'a, A> as data_traits::RawDataClone>::clone_from_with_ptr":["#[doc(hidden)]\nunsafe fn clone_from_with_ptr(\n        &mut self,\n        other: &Self,\n        ptr: NonNull<Self::Elem>,\n    ) -> NonNull<Self::Elem>{\n        match (&mut *self, other) {\n            (CowRepr::View(self_), CowRepr::View(other)) => self_.clone_from_with_ptr(other, ptr),\n            (CowRepr::Owned(self_), CowRepr::Owned(other)) => self_.clone_from_with_ptr(other, ptr),\n            (_, CowRepr::Owned(other)) => {\n                let (cloned, ptr) = other.clone_with_ptr(ptr);\n                *self = CowRepr::Owned(cloned);\n                ptr\n            }\n            (_, CowRepr::View(other)) => {\n                let (cloned, ptr) = other.clone_with_ptr(ptr);\n                *self = CowRepr::View(cloned);\n                ptr\n            }\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<CowRepr<'a, A> as data_traits::RawDataClone>::clone_with_ptr":["unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>){\n        match self {\n            CowRepr::View(view) => {\n                let (new_view, ptr) = view.clone_with_ptr(ptr);\n                (CowRepr::View(new_view), ptr)\n            }\n            CowRepr::Owned(data) => {\n                let (new_data, ptr) = data.clone_with_ptr(ptr);\n                (CowRepr::Owned(new_data), ptr)\n            }\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<CowRepr<'a, A> as data_traits::RawDataMut>::try_ensure_unique":["#[inline]\nfn try_ensure_unique<D>(array: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,{\n        match array.data {\n            CowRepr::View(_) => {\n                let owned = array.to_owned();\n                array.data = CowRepr::Owned(owned.data);\n                array.ptr = owned.ptr;\n                array.dim = owned.dim;\n                array.strides = owned.strides;\n            }\n            CowRepr::Owned(_) => {}\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<CowRepr<'a, A> as data_traits::RawDataMut>::try_is_unique":["#[inline]\nfn try_is_unique(&mut self) -> Option<bool>{\n        Some(self.is_owned())\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<D as dimension::DimensionExt>::axis":["#[inline]\nfn axis(&self, axis: Axis) -> Ix{\n        self[axis.index()]\n    }","Real(LocalPath(\"src/dimension/mod.rs\"))"],"<D as dimension::DimensionExt>::set_axis":["#[inline]\nfn set_axis(&mut self, axis: Axis, value: Ix){\n        self[axis.index()] = value;\n    }","Real(LocalPath(\"src/dimension/mod.rs\"))"],"<D as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self{\n        self\n    }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<D as dimension::ndindex::NdIndex<D>>::index_checked":["fn index_checked(&self, dim: &D, strides: &D) -> Option<isize>{\n        dim.stride_offset_checked(strides, self)\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<D as dimension::ndindex::NdIndex<D>>::index_unchecked":["fn index_unchecked(&self, strides: &D) -> isize{\n        D::stride_offset(self, strides)\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<D as zip::Splittable>::split_at":["fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n        let mut d1 = self;\n        let mut d2 = d1.clone();\n        let i = axis.index();\n        let len = d1[i];\n        d1[i] = index;\n        d2[i] = len - index;\n        (d1, d2)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<OwnedArcRepr<A> as data_traits::Data>::into_owned":["fn into_owned<D>(mut self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        A: Clone,\n        D: Dimension,{\n        Self::ensure_unique(&mut self_);\n        let data = Arc::try_unwrap(self_.data.0).ok().unwrap();\n        ArrayBase {\n            data,\n            ptr: self_.ptr,\n            dim: self_.dim,\n            strides: self_.strides,\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as data_traits::DataOwned>::into_shared":["fn into_shared(self) -> OwnedRcRepr<A>{\n        self\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as data_traits::DataOwned>::new":["fn new(elements: Vec<A>) -> Self{\n        OwnedArcRepr(Arc::new(OwnedRepr::from(elements)))\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<OwnedArcRepr<A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        Some(self.0.as_slice())\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as data_traits::RawDataClone>::clone_with_ptr":["unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>){\n        // pointer is preserved\n        (self.clone(), ptr)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as data_traits::RawDataMut>::try_ensure_unique":["fn try_ensure_unique<D>(self_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,{\n        if Arc::get_mut(&mut self_.data.0).is_some() {\n            return;\n        }\n        if self_.dim.size() <= self_.data.0.len() / 2 {\n            // Create a new vec if the current view is less than half of\n            // backing data.\n            unsafe {\n                *self_ = ArrayBase::from_shape_vec_unchecked(\n                    self_.dim.clone(),\n                    self_.iter().cloned().collect(),\n                );\n            }\n            return;\n        }\n        let rcvec = &mut self_.data.0;\n        let a_size = mem::size_of::<A>() as isize;\n        let our_off = if a_size != 0 {\n            (self_.ptr.as_ptr() as isize - rcvec.as_ptr() as isize) / a_size\n        } else {\n            0\n        };\n        let rvec = Arc::make_mut(rcvec);\n        unsafe {\n            self_.ptr = rvec.as_nonnull_mut().offset(our_off);\n        }\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as data_traits::RawDataMut>::try_is_unique":["fn try_is_unique(&mut self) -> Option<bool>{\n        Some(Arc::get_mut(&mut self.0).is_some())\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<OwnedArcRepr<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        OwnedArcRepr(self.0.clone())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<P as zip::IntoNdProducer>::into_producer":["fn into_producer(self) -> Self::Output{\n        self\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"<RawViewRepr<*const A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<RawViewRepr<*const A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        None\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<RawViewRepr<*const A> as data_traits::RawDataClone>::clone_with_ptr":["unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>){\n        (*self, ptr)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<RawViewRepr<*mut A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<RawViewRepr<*mut A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        None\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<RawViewRepr<*mut A> as data_traits::RawDataClone>::clone_with_ptr":["unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>){\n        (*self, ptr)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<RawViewRepr<*mut A> as data_traits::RawDataMut>::try_ensure_unique":["#[inline]\nfn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,{\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<RawViewRepr<*mut A> as data_traits::RawDataMut>::try_is_unique":["#[inline]\nfn try_is_unique(&mut self) -> Option<bool>{\n        None\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<Shape<D> as shape_builder::ShapeBuilder>::f":["fn f(self) -> Self{\n        self.set_f(true)\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<Shape<D> as shape_builder::ShapeBuilder>::into_shape":["fn into_shape(self) -> Shape<D>{\n        self\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<Shape<D> as shape_builder::ShapeBuilder>::set_f":["fn set_f(mut self, is_f: bool) -> Self{\n        self.is_c = !is_f;\n        self\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<Shape<D> as shape_builder::ShapeBuilder>::strides":["fn strides(self, st: D) -> StrideShape<D>{\n        StrideShape {\n            dim: self.dim,\n            strides: st,\n            custom: true,\n        }\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<T as shape_builder::ShapeBuilder>::f":["fn f(self) -> Shape<Self::Dim>{\n        self.set_f(true)\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<T as shape_builder::ShapeBuilder>::into_shape":["fn into_shape(self) -> Shape<Self::Dim>{\n        Shape {\n            dim: self.into_dimension(),\n            is_c: true,\n        }\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<T as shape_builder::ShapeBuilder>::set_f":["fn set_f(self, is_f: bool) -> Shape<Self::Dim>{\n        self.into_shape().set_f(is_f)\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<T as shape_builder::ShapeBuilder>::strides":["fn strides(self, st: T) -> StrideShape<Self::Dim>{\n        self.into_shape().strides(st.into_dimension())\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"<ViewRepr<&'a A> as data_traits::Data>::into_owned":["fn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        Self::Elem: Clone,\n        D: Dimension,{\n        self_.to_owned()\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<ViewRepr<&'a A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ViewRepr<&'a A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        None\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<ViewRepr<&'a A> as data_traits::RawDataClone>::clone_with_ptr":["unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>){\n        (*self, ptr)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<ViewRepr<&'a mut A> as data_traits::Data>::into_owned":["fn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        Self::Elem: Clone,\n        D: Dimension,{\n        self_.to_owned()\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<ViewRepr<&'a mut A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<ViewRepr<&'a mut A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        None\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<ViewRepr<&'a mut A> as data_traits::RawDataMut>::try_ensure_unique":["#[inline]\nfn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,{\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<ViewRepr<&'a mut A> as data_traits::RawDataMut>::try_is_unique":["#[inline]\nfn try_is_unique(&mut self) -> Option<bool>{\n        Some(true)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<[T; 0] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 0] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 10] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 10] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 11] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 11] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 12] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 12] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 13] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 13] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 14] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 14] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 15] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 15] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 16] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 16] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 1] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 1] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 2] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 2] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 3] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 3] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 4] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 4] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 5] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 5] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 6] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 6] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 7] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 7] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 8] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 8] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 9] as free_functions::FixedInitializer>::as_init_slice":["fn as_init_slice(&self) -> &[T]{ self }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[T; 9] as free_functions::FixedInitializer>::len":["fn len() -> usize{ $n }","Real(LocalPath(\"src/free_functions.rs\"))"],"<[usize; 0] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 0] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 1] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 1] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 2] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 2] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 3] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 3] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 4] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 4] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 5] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 5] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 6] as dimension::conversion::Convert>::convert":["#[inline]\nfn convert(self) -> Self::To{\n                index!(tuple_expr [self] $n)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 6] as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n                Dim::new(self)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 6]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &$ix_n, strides: &$ix_n) -> Option<isize>{\n                dim.stride_offset_checked(strides, &self.into_dimension())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 6]>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, _strides: &$ix_n) -> isize{\n                $(\n                stride_offset(self[$index], get!(_strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self)\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(self[$index], get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<[usize] as dimension::DimensionExt>::axis":["#[inline]\nfn axis(&self, axis: Axis) -> Ix{\n        self[axis.index()]\n    }","Real(LocalPath(\"src/dimension/mod.rs\"))"],"<[usize] as dimension::DimensionExt>::set_axis":["#[inline]\nfn set_axis(&mut self, axis: Axis, value: Ix){\n        self[axis.index()] = value;\n    }","Real(LocalPath(\"src/dimension/mod.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::Data>::into_owned":["#[inline]\nfn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        A: Clone,\n        D: Dimension,{\n        self_\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::DataOwned>::into_shared":["fn into_shared(self) -> OwnedRcRepr<A>{\n        OwnedArcRepr(Arc::new(self))\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::DataOwned>::new":["fn new(elements: Vec<A>) -> Self{\n        OwnedRepr::from(elements)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::RawData>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::RawData>::_data_slice":["fn _data_slice(&self) -> Option<&[A]>{\n        Some(self.as_slice())\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::RawDataClone>::clone_from_with_ptr":["unsafe fn clone_from_with_ptr(\n        &mut self,\n        other: &Self,\n        ptr: NonNull<Self::Elem>,\n    ) -> NonNull<Self::Elem>{\n        let our_off = if size_of::<A>() != 0 {\n            (ptr.as_ptr() as isize - other.as_ptr() as isize) / mem::size_of::<A>() as isize\n        } else {\n            0\n        };\n        self.clone_from(&other);\n        self.as_nonnull_mut().offset(our_off)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::RawDataClone>::clone_with_ptr":["unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>){\n        let mut u = self.clone();\n        let mut new_ptr = u.as_nonnull_mut();\n        if size_of::<A>() != 0 {\n            let our_off =\n                (ptr.as_ptr() as isize - self.as_ptr() as isize) / mem::size_of::<A>() as isize;\n            new_ptr = new_ptr.offset(our_off);\n        }\n        (u, new_ptr)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::RawDataMut>::try_ensure_unique":["#[inline]\nfn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,{\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as data_traits::RawDataMut>::try_is_unique":["#[inline]\nfn try_is_unique(&mut self) -> Option<bool>{\n        Some(true)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"<data_repr::OwnedRepr<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Self::from(self.as_slice().to_owned())\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"<data_repr::OwnedRepr<A> as std::clone::Clone>::clone_from":["fn clone_from(&mut self, other: &Self){\n        let mut v = self.take_as_vec();\n        let other = other.as_slice();\n\n        if v.len() > other.len() {\n            v.truncate(other.len());\n        }\n        let (front, back) = other.split_at(v.len());\n        v.clone_from_slice(front);\n        v.extend_from_slice(back);\n        *self = Self::from(v);\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"<data_repr::OwnedRepr<A> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if self.capacity > 0 {\n            // correct because: If the elements don't need dropping, an\n            // empty Vec is ok. Only the Vec's allocation needs dropping.\n            //\n            // implemented because: in some places in ndarray\n            // where A: Copy (hence does not need drop) we use uninitialized elements in\n            // vectors. Setting the length to 0 avoids that the vector tries to\n            // drop, slice or otherwise produce values of these elements.\n            // (The details of the validity letting this happen with nonzero len, are\n            // under discussion as of this writing.)\n            if !mem::needs_drop::<A>() {\n                self.len = 0;\n            }\n            // drop as a Vec.\n            self.take_as_vec();\n        }\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"<dimension::axes::Axes<'a, D> as std::clone::Clone>::clone":["#[inline(always)]\nfn clone(&self) -> Self{ *self }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<dimension::axes::Axes<'a, D> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        if self.start < self.end {\n            let i = self.end.pre_dec();\n            Some(AxisDescription(\n                Axis(i),\n                self.dim[i],\n                self.strides[i] as Ixs,\n            ))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::fold":["fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, AxisDescription) -> B,{\n        (self.start..self.end)\n            .map(move |i| AxisDescription(Axis(i), self.dim[i], self.strides[i] as isize))\n            .fold(init, f)\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.start < self.end {\n            let i = self.start.post_inc();\n            Some(AxisDescription(\n                Axis(i),\n                self.dim[i],\n                self.strides[i] as Ixs,\n            ))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.end - self.start;\n        (len, Some(len))\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<dimension::axes::AxisDescription as std::clone::Clone>::clone":["#[inline(always)]\nfn clone(&self) -> Self{ *self }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<dimension::dim::Dim<I> as std::cmp::PartialEq<I>>::eq":["fn eq(&self, rhs: &I) -> bool{\n        self.index == *rhs\n    }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{:?}\", self.index)\n    }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::Add>::add":["fn $op_m(mut self, rhs: Self) -> Self{\n                $expr!(self, &rhs);\n                self\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::AddAssign<&'a dimension::dim::Dim<I>>>::add_assign":["fn $opassign_m(&mut self, rhs: &Self){\n                for (x, &y) in zip(self.slice_mut(), rhs.slice()) {\n                    $expr!(*x, y);\n                }\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::AddAssign>::add_assign":["fn $opassign_m(&mut self, rhs: Self){\n                $expr!(*self, &rhs);\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::Mul<usize>>::mul":["fn $op_m(mut self, rhs: Ix) -> Self{\n                $expr!(self, rhs);\n                self\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::Mul>::mul":["fn $op_m(mut self, rhs: Self) -> Self{\n                $expr!(self, &rhs);\n                self\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::MulAssign<&'a dimension::dim::Dim<I>>>::mul_assign":["fn $opassign_m(&mut self, rhs: &Self){\n                for (x, &y) in zip(self.slice_mut(), rhs.slice()) {\n                    $expr!(*x, y);\n                }\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::MulAssign<usize>>::mul_assign":["fn $opassign_m(&mut self, rhs: Ix){\n                for x in self.slice_mut() {\n                    $expr!(*x, rhs);\n                }\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::MulAssign>::mul_assign":["fn $opassign_m(&mut self, rhs: Self){\n                $expr!(*self, &rhs);\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::Sub>::sub":["fn $op_m(mut self, rhs: Self) -> Self{\n                $expr!(self, &rhs);\n                self\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::SubAssign<&'a dimension::dim::Dim<I>>>::sub_assign":["fn $opassign_m(&mut self, rhs: &Self){\n                for (x, &y) in zip(self.slice_mut(), rhs.slice()) {\n                    $expr!(*x, y);\n                }\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<I> as std::ops::SubAssign>::sub_assign":["fn $opassign_m(&mut self, rhs: Self){\n                $expr!(*self, &rhs);\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["#[inline]\nfn _fastest_varying_stride_order(&self) -> Self{\n        Ix0()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::insert_axis":["fn insert_axis(&self, axis: Axis) -> Self::Larger{\n            debug_assert!(axis.index() <= $n);\n            let mut out = [1; $n + 1];\n            out[0..axis.index()].copy_from_slice(&self.slice()[0..axis.index()]);\n            out[axis.index()+1..=$n].copy_from_slice(&self.slice()[axis.index()..$n]);\n            Dim(out)\n        }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{}","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{\n        0\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::next_for":["#[inline]\nfn next_for(&self, _index: Self) -> Option<Self>{\n        None\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{\n        &[]\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{\n        &mut []\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, _ignore: Axis) -> Self::Smaller{\n        *self\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n        assert_eq!(ndim, 0);\n        Self::default()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 0]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["#[inline]\nfn _fastest_varying_stride_order(&self) -> Self{\n        Ix1(0)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::default_strides":["#[inline]\nfn default_strides(&self) -> Self{\n        if get!(self, 0) == 0 {\n            Ix1(0)\n        } else {\n            Ix1(1)\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::equal":["#[inline]\nfn equal(&self, rhs: &Self) -> bool{\n        get!(self, 0) == get!(rhs, 0)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::first_index":["#[inline]\nfn first_index(&self) -> Option<Self>{\n        if get!(self, 0) != 0 {\n            Some(Ix1(0))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::insert_axis":["fn insert_axis(&self, axis: Axis) -> Self::Larger{\n            debug_assert!(axis.index() <= $n);\n            let mut out = [1; $n + 1];\n            out[0..axis.index()].copy_from_slice(&self.slice()[0..axis.index()]);\n            out[axis.index()+1..=$n].copy_from_slice(&self.slice()[axis.index()..$n]);\n            Dim(out)\n        }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n        get!(&self, 0)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::max_stride_axis":["#[inline(always)]\nfn max_stride_axis(&self, _: &Self) -> Axis{\n        Axis(0)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::min_stride_axis":["#[inline(always)]\nfn min_stride_axis(&self, _: &Self) -> Axis{\n        Axis(0)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{\n        1\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::next_for":["#[inline]\nfn next_for(&self, mut index: Self) -> Option<Self>{\n        getm!(index, 0) += 1;\n        if get!(&index, 0) < get!(self, 0) {\n            Some(index)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::size":["#[inline]\nfn size(&self) -> usize{\n        get!(self, 0)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::size_checked":["#[inline]\nfn size_checked(&self) -> Option<usize>{\n        Some(get!(self, 0))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{\n        self.ix()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{\n        self.ixm()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::stride_offset":["/// Self is an index, return the stride offset\n#[inline(always)]\nfn stride_offset(index: &Self, stride: &Self) -> isize{\n        stride_offset(get!(index, 0), get!(stride, 0))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["/// Return stride offset for this dimension and index.\n#[inline]\nfn stride_offset_checked(&self, stride: &Self, index: &Self) -> Option<isize>{\n        if get!(index, 0) < get!(self, 0) {\n            Some(stride_offset(get!(index, 0), get!(stride, 0)))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n        self.remove_axis(axis)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n        assert_eq!(ndim, 1);\n        Self::default()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as dimension::remove_axis::RemoveAxis>::remove_axis":["#[inline]\nfn remove_axis(&self, axis: Axis) -> Ix0{\n        debug_assert!(axis.index() < self.ndim());\n        Ix0()\n    }","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as std::ops::Add<usize>>::add":["#[inline]\nfn $op_m(mut self, rhs: Ix) -> Self{\n                $expr!(self, rhs);\n                self\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as std::ops::AddAssign<usize>>::add_assign":["#[inline]\nfn $opassign_m(&mut self, rhs: Ix){\n                $expr!((*self)[0], rhs);\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as std::ops::Sub<usize>>::sub":["#[inline]\nfn $op_m(mut self, rhs: Ix) -> Self{\n                $expr!(self, rhs);\n                self\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<[usize; 1]> as std::ops::SubAssign<usize>>::sub_assign":["#[inline]\nfn $opassign_m(&mut self, rhs: Ix){\n                $expr!((*self)[0], rhs);\n            }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["#[inline]\nfn _fastest_varying_stride_order(&self) -> Self{\n        if get!(self, 0) as Ixs <= get!(self, 1) as Ixs {\n            Ix2(0, 1)\n        } else {\n            Ix2(1, 0)\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::default_strides":["#[inline]\nfn default_strides(&self) -> Self{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        if m == 0 || n == 0 {\n            Ix2(0, 0)\n        } else {\n            Ix2(n, 1)\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::equal":["#[inline]\nfn equal(&self, rhs: &Self) -> bool{\n        get!(self, 0) == get!(rhs, 0) && get!(self, 1) == get!(rhs, 1)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::first_index":["#[inline]\nfn first_index(&self) -> Option<Self>{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        if m != 0 && n != 0 {\n            Some(Ix2(0, 0))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::fortran_strides":["#[inline]\nfn fortran_strides(&self) -> Self{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        if m == 0 || n == 0 {\n            Ix2(0, 0)\n        } else {\n            Ix2(1, m)\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::insert_axis":["fn insert_axis(&self, axis: Axis) -> Self::Larger{\n            debug_assert!(axis.index() <= $n);\n            let mut out = [1; $n + 1];\n            out[0..axis.index()].copy_from_slice(&self.slice()[0..axis.index()]);\n            out[axis.index()+1..=$n].copy_from_slice(&self.slice()[axis.index()..$n]);\n            Dim(out)\n        }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n        self.ix().convert()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::last_elem":["#[inline]\nfn last_elem(&self) -> usize{\n        get!(self, 1)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::min_stride_axis":["#[inline]\nfn min_stride_axis(&self, strides: &Self) -> Axis{\n        let s = get!(strides, 0) as Ixs;\n        let t = get!(strides, 1) as Ixs;\n        if s.abs() < t.abs() {\n            Axis(0)\n        } else {\n            Axis(1)\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{\n        2\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::next_for":["#[inline]\nfn next_for(&self, index: Self) -> Option<Self>{\n        let mut i = get!(&index, 0);\n        let mut j = get!(&index, 1);\n        let imax = get!(self, 0);\n        let jmax = get!(self, 1);\n        j += 1;\n        if j >= jmax {\n            j = 0;\n            i += 1;\n            if i >= imax {\n                return None;\n            }\n        }\n        Some(Ix2(i, j))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::set_last_elem":["#[inline]\nfn set_last_elem(&mut self, i: usize){\n        getm!(self, 1) = i;\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::size":["#[inline]\nfn size(&self) -> usize{\n        get!(self, 0) * get!(self, 1)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::size_checked":["#[inline]\nfn size_checked(&self) -> Option<usize>{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        (m as usize).checked_mul(n as usize)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{\n        self.ix()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{\n        self.ixm()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::stride_offset":["/// Self is an index, return the stride offset\n#[inline(always)]\nfn stride_offset(index: &Self, strides: &Self) -> isize{\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        stride_offset(i, s) + stride_offset(j, t)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["/// Return stride offset for this dimension and index.\n#[inline]\nfn stride_offset_checked(&self, strides: &Self, index: &Self) -> Option<isize>{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        if i < m && j < n {\n            Some(stride_offset(i, s) + stride_offset(j, t))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n        self.remove_axis(axis)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n        assert_eq!(ndim, 2);\n        Self::default()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 2]> as dimension::remove_axis::RemoveAxis>::remove_axis":["#[inline]\nfn remove_axis(&self, axis: Axis) -> Ix1{\n        let axis = axis.index();\n        debug_assert!(axis < self.ndim());\n        if axis == 0 {\n            Ix1(get!(self, 1))\n        } else {\n            Ix1(get!(self, 0))\n        }\n    }","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["#[inline]\nfn _fastest_varying_stride_order(&self) -> Self{\n        let mut stride = *self;\n        let mut order = Ix3(0, 1, 2);\n        macro_rules! swap {\n            ($stride:expr, $order:expr, $x:expr, $y:expr) => {\n                if $stride[$x] > $stride[$y] {\n                    $stride.swap($x, $y);\n                    $order.ixm().swap($x, $y);\n                }\n            };\n        }\n        {\n            // stable sorting network for 3 elements\n            let strides = stride.slice_mut();\n            swap![strides, order, 1, 2];\n            swap![strides, order, 0, 1];\n            swap![strides, order, 1, 2];\n        }\n        order\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::insert_axis":["fn insert_axis(&self, axis: Axis) -> Self::Larger{\n            debug_assert!(axis.index() <= $n);\n            let mut out = [1; $n + 1];\n            out[0..axis.index()].copy_from_slice(&self.slice()[0..axis.index()]);\n            out[axis.index()+1..=$n].copy_from_slice(&self.slice()[axis.index()..$n]);\n            Dim(out)\n        }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n        self.ix().convert()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{\n        3\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::next_for":["#[inline]\nfn next_for(&self, index: Self) -> Option<Self>{\n        let mut i = get!(&index, 0);\n        let mut j = get!(&index, 1);\n        let mut k = get!(&index, 2);\n        let imax = get!(self, 0);\n        let jmax = get!(self, 1);\n        let kmax = get!(self, 2);\n        k += 1;\n        if k == kmax {\n            k = 0;\n            j += 1;\n            if j == jmax {\n                j = 0;\n                i += 1;\n                if i == imax {\n                    return None;\n                }\n            }\n        }\n        Some(Ix3(i, j, k))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::size":["#[inline]\nfn size(&self) -> usize{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        let o = get!(self, 2);\n        m as usize * n as usize * o as usize\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{\n        self.ix()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{\n        self.ixm()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::stride_offset":["/// Self is an index, return the stride offset\n#[inline]\nfn stride_offset(index: &Self, strides: &Self) -> isize{\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let k = get!(index, 2);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        let u = get!(strides, 2);\n        stride_offset(i, s) + stride_offset(j, t) + stride_offset(k, u)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["/// Return stride offset for this dimension and index.\n#[inline]\nfn stride_offset_checked(&self, strides: &Self, index: &Self) -> Option<isize>{\n        let m = get!(self, 0);\n        let n = get!(self, 1);\n        let l = get!(self, 2);\n        let i = get!(index, 0);\n        let j = get!(index, 1);\n        let k = get!(index, 2);\n        let s = get!(strides, 0);\n        let t = get!(strides, 1);\n        let u = get!(strides, 2);\n        if i < m && j < n && k < l {\n            Some(stride_offset(i, s) + stride_offset(j, t) + stride_offset(k, u))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n        self.remove_axis(axis)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n        assert_eq!(ndim, 3);\n        Self::default()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 3]> as dimension::remove_axis::RemoveAxis>::remove_axis":["#[inline]\nfn remove_axis(&self, axis: Axis) -> Self::Smaller{\n                debug_assert!(axis.index() < self.ndim());\n                let mut result = Dim([0; $n - 1]);\n                {\n                    let src = self.slice();\n                    let dst = result.slice_mut();\n                    dst[..axis.index()].copy_from_slice(&src[..axis.index()]);\n                    dst[axis.index()..].copy_from_slice(&src[axis.index() + 1..]);\n                }\n                result\n            }","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::insert_axis":["fn insert_axis(&self, axis: Axis) -> Self::Larger{\n            debug_assert!(axis.index() <= $n);\n            let mut out = [1; $n + 1];\n            out[0..axis.index()].copy_from_slice(&self.slice()[0..axis.index()]);\n            out[axis.index()+1..=$n].copy_from_slice(&self.slice()[axis.index()..$n]);\n            Dim(out)\n        }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n                self.ix().convert()\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{ $n }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{ self.ix() }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{ self.ixm() }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n                self.remove_axis(axis)\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n                assert_eq!(ndim, $n);\n                Self::default()\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 4]> as dimension::remove_axis::RemoveAxis>::remove_axis":["#[inline]\nfn remove_axis(&self, axis: Axis) -> Self::Smaller{\n                debug_assert!(axis.index() < self.ndim());\n                let mut result = Dim([0; $n - 1]);\n                {\n                    let src = self.slice();\n                    let dst = result.slice_mut();\n                    dst[..axis.index()].copy_from_slice(&src[..axis.index()]);\n                    dst[axis.index()..].copy_from_slice(&src[axis.index() + 1..]);\n                }\n                result\n            }","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::insert_axis":["fn insert_axis(&self, axis: Axis) -> Self::Larger{\n            debug_assert!(axis.index() <= $n);\n            let mut out = [1; $n + 1];\n            out[0..axis.index()].copy_from_slice(&self.slice()[0..axis.index()]);\n            out[axis.index()+1..=$n].copy_from_slice(&self.slice()[axis.index()..$n]);\n            Dim(out)\n        }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n                self.ix().convert()\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{ $n }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{ self.ix() }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{ self.ixm() }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n                self.remove_axis(axis)\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n                assert_eq!(ndim, $n);\n                Self::default()\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 5]> as dimension::remove_axis::RemoveAxis>::remove_axis":["#[inline]\nfn remove_axis(&self, axis: Axis) -> Self::Smaller{\n                debug_assert!(axis.index() < self.ndim());\n                let mut result = Dim([0; $n - 1]);\n                {\n                    let src = self.slice();\n                    let dst = result.slice_mut();\n                    dst[..axis.index()].copy_from_slice(&src[..axis.index()]);\n                    dst[axis.index()..].copy_from_slice(&src[axis.index() + 1..]);\n                }\n                result\n            }","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::insert_axis":["#[inline]\nfn insert_axis(&self, axis: Axis) -> Self::Larger{\n        debug_assert!(axis.index() <= self.ndim());\n        let mut out = Vec::with_capacity(self.ndim() + 1);\n        out.extend_from_slice(&self.slice()[0..axis.index()]);\n        out.push(1);\n        out.extend_from_slice(&self.slice()[axis.index()..self.ndim()]);\n        Dim(out)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n                self.ix().convert()\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{ $n }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{ self.ix() }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{ self.ixm() }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n                self.remove_axis(axis)\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n                assert_eq!(ndim, $n);\n                Self::default()\n            }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                stride_offset_checked(dim.ix(), strides.ix(), self.ix())\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n                debug_assert_eq!(strides.ndim(), $n,\n                              \"Attempted to index with {:?} in array with {} axes\",\n                              self, strides.ndim());\n                $(\n                stride_offset(get!(self, $index), get!(strides, $index)) +\n                )*\n                0\n            }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<dimension::dim::Dim<[usize; 6]> as dimension::remove_axis::RemoveAxis>::remove_axis":["#[inline]\nfn remove_axis(&self, axis: Axis) -> Self::Smaller{\n                debug_assert!(axis.index() < self.ndim());\n                let mut result = Dim([0; $n - 1]);\n                {\n                    let src = self.slice();\n                    let dst = result.slice_mut();\n                    dst[..axis.index()].copy_from_slice(&src[..axis.index()]);\n                    dst[axis.index()..].copy_from_slice(&src[axis.index() + 1..]);\n                }\n                result\n            }","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::from_dimension":["fn from_dimension<D2: Dimension>(d: &D2) -> Option<Self>{\n        Some(IxDyn(d.slice()))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::insert_axis":["#[inline]\nfn insert_axis(&self, axis: Axis) -> Self::Larger{\n        debug_assert!(axis.index() <= self.ndim());\n        Dim::new(self.ix().insert(axis.index()))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::into_pattern":["#[inline]\nfn into_pattern(self) -> Self::Pattern{\n        self\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::ndim":["#[inline]\nfn ndim(&self) -> usize{\n        self.ix().len()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::slice":["#[inline]\nfn slice(&self) -> &[Ix]{\n        self.ix()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::slice_mut":["#[inline]\nfn slice_mut(&mut self) -> &mut [Ix]{\n        self.ixm()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::try_remove_axis":["#[inline]\nfn try_remove_axis(&self, axis: Axis) -> Self::Smaller{\n        if self.ndim() > 0 {\n            self.remove_axis(axis)\n        } else {\n            self.clone()\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::zeros":["#[inline]\nfn zeros(ndim: usize) -> Self{\n        IxDyn::zeros(ndim)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n        Dim::new(self)\n    }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as std::convert::From<&'a [usize]>>::from":["#[inline]\nfn from(ix: &'a [Ix]) -> Self{\n        IxDynImpl(IxDynRepr::copy_from(ix))\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as std::convert::From<std::vec::Vec<usize>>>::from":["#[inline]\nfn from(ix: Vec<Ix>) -> Self{\n        IxDynImpl(IxDynRepr::from_vec_auto(ix))\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &[Ix]{\n        &self.0\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as std::ops::DerefMut>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut [Ix]{\n        &mut self.0\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as std::ops::Index<J>>::index":["fn index(&self, index: J) -> &Self::Output{\n        &self.0[index]\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynImpl as std::ops::IndexMut<J>>::index_mut":["fn index_mut(&mut self, index: J) -> &mut Self::Output{\n        &mut self.0[index]\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynRepr<T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        match *self {\n            IxDynRepr::Inline(len, arr) => IxDynRepr::Inline(len, arr),\n            _ => Self::from(&self[..]),\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynRepr<T> as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n        match (self, rhs) {\n            (&IxDynRepr::Inline(slen, ref sarr), &IxDynRepr::Inline(rlen, ref rarr)) => {\n                slen == rlen\n                    && (0..CAP as usize)\n                        .filter(|&i| i < slen as usize)\n                        .all(|i| sarr[i] == rarr[i])\n            }\n            _ => self[..] == rhs[..],\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynRepr<T> as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        Hash::hash(&self[..], state)\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynRepr<T> as std::ops::Deref>::deref":["fn deref(&self) -> &[T]{\n        match *self {\n            IxDynRepr::Inline(len, ref ar) => {\n                debug_assert!(len as usize <= ar.len());\n                unsafe { ar.get_unchecked(..len as usize) }\n            }\n            IxDynRepr::Alloc(ref ar) => &*ar,\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynRepr<T> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut [T]{\n        match *self {\n            IxDynRepr::Inline(len, ref mut ar) => {\n                debug_assert!(len as usize <= ar.len());\n                unsafe { ar.get_unchecked_mut(..len as usize) }\n            }\n            IxDynRepr::Alloc(ref mut ar) => &mut *ar,\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<dimension::dynindeximpl::IxDynRepr<usize> as std::default::Default>::default":["fn default() -> Self{\n        Self::copy_from(&[0])\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"<error::ErrorKind as std::cmp::PartialEq>::eq":["#[inline(always)]\nfn eq(&self, rhs: &Self) -> bool{\n        *self as u8 == *rhs as u8\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ShapeError as std::cmp::PartialEq>::eq":["#[inline(always)]\nfn eq(&self, rhs: &Self) -> bool{\n        self.repr == rhs.repr\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ShapeError as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{}\", self)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ShapeError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let description = match self.kind() {\n            ErrorKind::IncompatibleShape => \"incompatible shapes\",\n            ErrorKind::IncompatibleLayout => \"incompatible memory layout\",\n            ErrorKind::RangeLimited => \"the shape does not fit in type limits\",\n            ErrorKind::OutOfBounds => \"out of bounds indexing\",\n            ErrorKind::Unsupported => \"unsupported operation\",\n            ErrorKind::Overflow => \"arithmetic overflow\",\n            ErrorKind::__Incomplete => \"this error variant is not in use\",\n        };\n        write!(f, \"ShapeError/{:?}: {}\", self.kind(), description)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<geomspace::Geomspace<F> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<F>{\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            self.len -= 1;\n            let i = self.len;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * exponent.exp())\n        }\n    }","Real(LocalPath(\"src/geomspace.rs\"))"],"<geomspace::Geomspace<F> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<F>{\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            let i = self.index;\n            self.index += 1;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * exponent.exp())\n        }\n    }","Real(LocalPath(\"src/geomspace.rs\"))"],"<geomspace::Geomspace<F> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let n = self.len - self.index;\n        (n, Some(n))\n    }","Real(LocalPath(\"src/geomspace.rs\"))"],"<i32 as slice::SliceNextDim<D1, D1>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<indexes::IndexPtr<D> as zip::Offset>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<indexes::IndexPtr<D> as zip::Offset>::stride_offset":["unsafe fn stride_offset(mut self, stride: Self::Stride, index: usize) -> Self{\n        self.index[stride] += index;\n        self\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        let sz = self.dim.size();\n        let index = if sz != 0 { Some(self.start) } else { None };\n        IndicesIter {\n            index,\n            dim: self.dim,\n        }\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> Self::Ptr{\n        IndexPtr { index: self.start }\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n        ptr.index.into_pattern()\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::contiguous_stride":["#[inline(always)]\nfn contiguous_stride(&self) -> Self::Stride{\n        0\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::equal_dim":["#[doc(hidden)]\nfn equal_dim(&self, dim: &Self::Dim) -> bool{\n        self.dim.equal(dim)\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        if self.dim.ndim() <= 1 {\n            Layout::one_dimensional()\n        } else {\n            Layout::none()\n        }\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        self.dim\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        let start_a = self.start;\n        let mut start_b = start_a;\n        let (a, b) = self.dim.split_at(axis, index);\n        start_b[axis.index()] += index;\n        (\n            Indices {\n                start: start_a,\n                dim: a,\n            },\n            Indices {\n                start: start_b,\n                dim: b,\n            },\n        )\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> Self::Stride{\n        axis.index()\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::Indices<D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n        let mut index = *i;\n        index += &self.start;\n        IndexPtr { index }\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::IndicesIter<D> as std::iter::Iterator>::fold":["fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        F: FnMut(B, D::Pattern) -> B,{\n        let IndicesIter { mut index, dim } = self;\n        let ndim = dim.ndim();\n        if ndim == 0 {\n            return match index {\n                Some(ix) => f(init, ix.into_pattern()),\n                None => init,\n            };\n        }\n        let inner_axis = ndim - 1;\n        let inner_len = dim[inner_axis];\n        let mut acc = init;\n        while let Some(mut ix) = index {\n            // unroll innermost axis\n            for i in ix[inner_axis]..inner_len {\n                ix[inner_axis] = i;\n                acc = f(acc, ix.clone().into_pattern());\n            }\n            index = dim.next_for(ix);\n        }\n        acc\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::IndicesIter<D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        let index = match self.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        self.index = self.dim.next_for(index.clone());\n        Some(index.into_pattern())\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::IndicesIter<D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let l = match self.index {\n            None => 0,\n            Some(ref ix) => {\n                let gone = self\n                    .dim\n                    .default_strides()\n                    .slice()\n                    .iter()\n                    .zip(ix.slice().iter())\n                    .fold(0, |s, (&a, &b)| s + a as usize * b as usize);\n                self.dim.size() - gone\n            }\n        };\n        (l, Some(l))\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        if !self.has_remaining {\n            None\n        } else {\n            let elt = self.index.clone().into_pattern();\n            self.has_remaining = self.dim.next_for_f(&mut self.index);\n            Some(elt)\n        }\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        if !self.has_remaining {\n            return (0, Some(0));\n        }\n        let gone = self\n            .dim\n            .fortran_strides()\n            .slice()\n            .iter()\n            .zip(self.index.slice().iter())\n            .fold(0, |s, (&a, &b)| s + a as usize * b as usize);\n        let l = self.dim.size() - gone;\n        (l, Some(l))\n    }","Real(LocalPath(\"src/indexes.rs\"))"],"<isize as slice::SliceNextDim<D1, D1>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<iterators::AxisChunksIter<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n                self.iter\n                    .next_back_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n                self.iter\n                    .next_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n                self.iter\n                    .next_back_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n                self.iter\n                    .next_with_index()\n                    .map(|(index, ptr)| self.get_subview(index, ptr))\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::AxisIter<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.next_back().map(|ptr| unsafe { self.as_ref(ptr) })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.iter.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|ptr| unsafe { self.as_ref(ptr) })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> Self::Ptr{\n        if self.len() > 0 {\n            // `self.iter.index` is guaranteed to be in-bounds if any of the\n            // iterator remains (i.e. if `self.len() > 0`).\n            unsafe { self.iter.offset(self.iter.index) }\n        } else {\n            // In this case, `self.iter.index` may be past the end, so we must\n            // not call `.offset()`. It's okay to return a dangling pointer\n            // because it will never be used in the length 0 case.\n            std::ptr::NonNull::dangling().as_ptr()\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n        ArrayView::new_(\n            ptr,\n            self.iter.inner_dim.clone(),\n            self.iter.inner_strides.clone(),\n        )\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::contiguous_stride":["fn contiguous_stride(&self) -> isize{\n        self.iter.stride\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> crate::Layout{\n        crate::Layout::one_dimensional()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        Ix1(self.len())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, _axis: Axis, index: usize) -> (Self, Self){\n        self.split_at(index)\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, _axis: Axis) -> isize{\n        self.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n        self.iter.offset(self.iter.index + i[0])\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterCore<A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::AxisIterCore<A, D> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        if self.index >= self.end {\n            None\n        } else {\n            let ptr = unsafe { self.offset(self.end - 1) };\n            self.end -= 1;\n            Some(ptr)\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterCore<A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.end - self.index\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.index >= self.end {\n            None\n        } else {\n            let ptr = unsafe { self.offset(self.index) };\n            self.index += 1;\n            Some(ptr)\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.len();\n        (len, Some(len))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.next_back().map(|ptr| unsafe { self.as_ref(ptr) })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.iter.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|ptr| unsafe { self.as_ref(ptr) })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> Self::Ptr{\n        if self.len() > 0 {\n            // `self.iter.index` is guaranteed to be in-bounds if any of the\n            // iterator remains (i.e. if `self.len() > 0`).\n            unsafe { self.iter.offset(self.iter.index) }\n        } else {\n            // In this case, `self.iter.index` may be past the end, so we must\n            // not call `.offset()`. It's okay to return a dangling pointer\n            // because it will never be used in the length 0 case.\n            std::ptr::NonNull::dangling().as_ptr()\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item{\n        ArrayViewMut::new_(\n            ptr,\n            self.iter.inner_dim.clone(),\n            self.iter.inner_strides.clone(),\n        )\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["fn contiguous_stride(&self) -> isize{\n        self.iter.stride\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> crate::Layout{\n        crate::Layout::one_dimensional()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> Self::Dim{\n        Ix1(self.len())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, _axis: Axis, index: usize) -> (Self, Self){\n        self.split_at(index)\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, _axis: Axis) -> isize{\n        self.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr{\n        self.iter.offset(self.iter.index + i[0])\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::Baseiter<A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        match self.index {\n            None => 0,\n            Some(ref ix) => {\n                let gone = self\n                    .dim\n                    .default_strides()\n                    .slice()\n                    .iter()\n                    .zip(ix.slice().iter())\n                    .fold(0, |s, (&a, &b)| s + a as usize * b as usize);\n                self.dim.size() - gone\n            }\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::fold":["fn fold<Acc, G>(mut self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, *mut A) -> Acc,{\n        let ndim = self.dim.ndim();\n        debug_assert_ne!(ndim, 0);\n        let mut accum = init;\n        while let Some(mut index) = self.index.clone() {\n            let stride = self.strides.last_elem() as isize;\n            let elem_index = index.last_elem();\n            let len = self.dim.last_elem();\n            let offset = D::stride_offset(&index, &self.strides);\n            unsafe {\n                let row_ptr = self.ptr.offset(offset);\n                for i in 0..(len - elem_index) {\n                    accum = g(accum, row_ptr.offset(i as isize * stride));\n                }\n            }\n            index.set_last_elem(len - 1);\n            self.index = self.dim.next_for(index);\n        }\n        accum\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<*mut A>{\n        let index = match self.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        let offset = D::stride_offset(&index, &self.strides);\n        self.index = self.dim.next_for(index);\n        unsafe { Some(self.ptr.offset(offset)) }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.len();\n        (len, Some(len))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<*mut A>{\n        let index = match self.index {\n            None => return None,\n            Some(ix) => ix,\n        };\n        self.dim[0] -= 1;\n        let offset = <_>::stride_offset(&self.dim, &self.strides);\n        if index == self.dim {\n            self.index = None;\n        }\n\n        unsafe { Some(self.ptr.offset(offset)) }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["fn nth_back(&mut self, n: usize) -> Option<*mut A>{\n        let index = self.index?;\n        let len = self.dim[0] - index[0];\n        if n < len {\n            self.dim[0] -= n + 1;\n            let offset = <_>::stride_offset(&self.dim, &self.strides);\n            if index == self.dim {\n                self.index = None;\n            }\n            unsafe { Some(self.ptr.offset(offset)) }\n        } else {\n            self.index = None;\n            None\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["fn rfold<Acc, G>(mut self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, *mut A) -> Acc,{\n        let mut accum = init;\n        if let Some(index) = self.index {\n            let elem_index = index[0];\n            unsafe {\n                // self.dim[0] is the current length\n                while self.dim[0] > elem_index {\n                    self.dim[0] -= 1;\n                    accum = g(\n                        accum,\n                        self.ptr\n                            .offset(Ix1::stride_offset(&self.dim, &self.strides)),\n                    );\n                }\n            }\n        }\n        accum\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBase<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::ElementsBase<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::fold":["fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        unsafe { self.inner.fold(init, move |acc, ptr| g(acc, &*ptr)) }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a A>{\n        self.inner.next().map(|p| unsafe { &*p })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBase<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'a A>{\n        self.inner.next_back().map(|p| unsafe { &*p })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBase<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        unsafe { self.inner.rfold(init, move |acc, ptr| g(acc, &*ptr)) }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::fold":["fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        unsafe { self.inner.fold(init, move |acc, ptr| g(acc, &mut *ptr)) }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a mut A>{\n        self.inner.next().map(|p| unsafe { &mut *p })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBaseMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'a mut A>{\n        self.inner.next_back().map(|p| unsafe { &mut *p })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::ElementsBaseMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        unsafe { self.inner.rfold(init, move |acc, ptr| g(acc, &mut *ptr)) }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IndexedIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.0.inner.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        let index = match self.0.inner.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        match self.0.next() {\n            None => None,\n            Some(elem) => Some((index.into_pattern(), elem)),\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.0.inner.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        let index = match self.0.inner.index {\n            None => return None,\n            Some(ref ix) => ix.clone(),\n        };\n        match self.0.next() {\n            None => None,\n            Some(elem) => Some((index.into_pattern(), elem)),\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        either!(self.inner, ref iter => iter.len())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::all":["fn all<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.all(f))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::any":["fn any<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.any(f))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::collect":["fn collect<B>(self) -> B\n    where\n        B: FromIterator<Self::Item>,{\n        either!(self.inner, iter => iter.collect())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        either!(self.inner, iter => iter.count())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::find":["fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.find(predicate))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::find_map":["fn find_map<B, F>(&mut self, f: F) -> Option<B>\n    where\n        F: FnMut(Self::Item) -> Option<B>,{\n        either_mut!(self.inner, iter => iter.find_map(f))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::fold":["fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        either!(self.inner, iter => iter.fold(init, g))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::last":["fn last(self) -> Option<Self::Item>{\n        either!(self.inner, iter => iter.last())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a A>{\n        either_mut!(self.inner, iter => iter.next())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::nth":["fn nth(&mut self, n: usize) -> Option<Self::Item>{\n        either_mut!(self.inner, iter => iter.nth(n))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::position":["fn position<P>(&mut self, predicate: P) -> Option<usize>\n    where\n        P: FnMut(Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.position(predicate))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        either!(self.inner, ref iter => iter.size_hint())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'a A>{\n        either_mut!(self.inner, iter => iter.next_back())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["fn nth_back(&mut self, n: usize) -> Option<&'a A>{\n        either_mut!(self.inner, iter => iter.nth_back(n))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        either!(self.inner, iter => iter.rfold(init, g))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        either!(self.inner, ref iter => iter.len())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::all":["fn all<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.all(f))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::any":["fn any<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.any(f))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::collect":["fn collect<B>(self) -> B\n    where\n        B: FromIterator<Self::Item>,{\n        either!(self.inner, iter => iter.collect())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        either!(self.inner, iter => iter.count())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::find":["fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.find(predicate))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::find_map":["fn find_map<B, F>(&mut self, f: F) -> Option<B>\n    where\n        F: FnMut(Self::Item) -> Option<B>,{\n        either_mut!(self.inner, iter => iter.find_map(f))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::fold":["fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        either!(self.inner, iter => iter.fold(init, g))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::last":["fn last(self) -> Option<Self::Item>{\n        either!(self.inner, iter => iter.last())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a mut A>{\n        either_mut!(self.inner, iter => iter.next())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::nth":["fn nth(&mut self, n: usize) -> Option<Self::Item>{\n        either_mut!(self.inner, iter => iter.nth(n))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::position":["fn position<P>(&mut self, predicate: P) -> Option<usize>\n    where\n        P: FnMut(Self::Item) -> bool,{\n        either_mut!(self.inner, iter => iter.position(predicate))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        either!(self.inner, ref iter => iter.size_hint())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'a mut A>{\n        either_mut!(self.inner, iter => iter.next_back())\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["fn nth_back(&mut self, n: usize) -> Option<&'a mut A>{\n        either_mut!(self.inner, iter => iter.nth_back(n))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,{\n        either!(self.inner, iter => iter.rfold(init, g))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::LanesIter<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                $typename {\n                $(\n                    $copyfield: self.$copyfield,\n                )*\n                $(\n                    $field: self.$field.clone(),\n                )*\n                }\n            }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<iterators::LanesIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.iter.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|ptr| unsafe {\n            ArrayView::new_(ptr, Ix1(self.inner_len), Ix1(self.inner_stride as Ix))\n        })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::LanesIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.iter.len()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|ptr| unsafe {\n            ArrayViewMut::new_(ptr, Ix1(self.inner_len), Ix1(self.inner_stride as Ix))\n        })\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $typename {\n                $base: self.base.clone(),\n                $(\n                $fieldname: self.$fieldname.clone(),\n                )*\n            }\n        }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        ExactChunksIter {\n            iter: self.base.into_elements_base(),\n            chunk: self.chunk,\n            inner_strides: self.inner_strides,\n        }\n    }","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.$base.as_ptr() as *mut _\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item{\n        $refexpr\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::contiguous_stride":["#[doc(hidden)]\nfn contiguous_stride(&self) -> isize{\n        self.$base.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.$base.layout()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> D{\n        self.$base.raw_dim()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.$base.stride_of(axis)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.$base.uget_ptr(i)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                    $typename {\n                        $base: self.$base.clone(),\n                        $(\n                            $fieldname: self.$fieldname.clone(),\n                        )*\n                    }\n                }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut $self_) -> Option<Self::Item>{\n                $self_.$base.next().map(|$elt| {\n                    $refexpr\n                })\n            }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n                self.$base.size_hint()\n            }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut $self_) -> Option<Self::Item>{\n                $self_.$base.next().map(|$elt| {\n                    $refexpr\n                })\n            }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n                self.$base.size_hint()\n            }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        ExactChunksIterMut {\n            iter: self.base.into_elements_base(),\n            chunk: self.chunk,\n            inner_strides: self.inner_strides,\n        }\n    }","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.$base.as_ptr() as *mut _\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item{\n        $refexpr\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["#[doc(hidden)]\nfn contiguous_stride(&self) -> isize{\n        self.$base.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.$base.layout()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> D{\n        self.$base.raw_dim()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.$base.stride_of(axis)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.$base.uget_ptr(i)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $typename {\n                $base: self.base.clone(),\n                $(\n                $fieldname: self.$fieldname.clone(),\n                )*\n            }\n        }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        LanesIter {\n            iter: self.base.into_base_iter(),\n            inner_len: self.inner_len,\n            inner_stride: self.inner_stride,\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/lanes.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.$base.as_ptr() as *mut _\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item{\n        $refexpr\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::contiguous_stride":["#[doc(hidden)]\nfn contiguous_stride(&self) -> isize{\n        self.$base.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.$base.layout()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> D{\n        self.$base.raw_dim()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.$base.stride_of(axis)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.$base.uget_ptr(i)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        LanesIterMut {\n            iter: self.base.into_base_iter(),\n            inner_len: self.inner_len,\n            inner_stride: self.inner_stride,\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/lanes.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.$base.as_ptr() as *mut _\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item{\n        $refexpr\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["#[doc(hidden)]\nfn contiguous_stride(&self) -> isize{\n        self.$base.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.$base.layout()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> D{\n        self.$base.raw_dim()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.$base.stride_of(axis)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.$base.uget_ptr(i)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $typename {\n                $base: self.base.clone(),\n                $(\n                $fieldname: self.$fieldname.clone(),\n                )*\n            }\n        }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        WindowsIter {\n            iter: self.base.into_elements_base(),\n            window: self.window,\n            strides: self.strides,\n        }\n    }","Real(LocalPath(\"src/iterators/windows.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::__private__":["#[doc(hidden)]\nfn __private__(&self) -> crate::private::PrivateMarker{\n            crate::private::PrivateMarker\n        }","Real(LocalPath(\"src/private.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::as_ptr":["#[doc(hidden)]\nfn as_ptr(&self) -> *mut A{\n        self.$base.as_ptr() as *mut _\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::as_ref":["#[doc(hidden)]\nunsafe fn as_ref(&$self_, $ptr: *mut A) -> Self::Item{\n        $refexpr\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::contiguous_stride":["#[doc(hidden)]\nfn contiguous_stride(&self) -> isize{\n        self.$base.contiguous_stride()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::layout":["#[doc(hidden)]\nfn layout(&self) -> Layout{\n        self.$base.layout()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::raw_dim":["#[doc(hidden)]\nfn raw_dim(&self) -> D{\n        self.$base.raw_dim()\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::split_at":["#[doc(hidden)]\nfn split_at(self, axis: Axis, index: usize) -> (Self, Self){\n        let (a, b) = self.$base.split_at(axis, index);\n        ($typename {\n            $base: a,\n            $(\n            $fieldname: self.$fieldname.clone(),\n            )*\n        },\n        $typename {\n            $base: b,\n            $(\n            $fieldname: self.$fieldname,\n            )*\n        })\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::stride_of":["#[doc(hidden)]\nfn stride_of(&self, axis: Axis) -> isize{\n        self.$base.stride_of(axis)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::uget_ptr":["#[doc(hidden)]\nunsafe fn uget_ptr(&self, i: &Self::Dim) -> *mut A{\n        self.$base.uget_ptr(i)\n    }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::WindowsIter<'a, A, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                    $typename {\n                        $base: self.$base.clone(),\n                        $(\n                            $fieldname: self.$fieldname.clone(),\n                        )*\n                    }\n                }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::next":["fn next(&mut $self_) -> Option<Self::Item>{\n                $self_.$base.next().map(|$elt| {\n                    $refexpr\n                })\n            }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n                self.$base.size_hint()\n            }","Real(LocalPath(\"src/iterators/macros.rs\"))"],"<linspace::Linspace<F> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<F>{\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            self.len -= 1;\n            let i = self.len;\n            Some(self.start + self.step * F::from(i).unwrap())\n        }\n    }","Real(LocalPath(\"src/linspace.rs\"))"],"<linspace::Linspace<F> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<F>{\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            let i = self.index;\n            self.index += 1;\n            Some(self.start + self.step * F::from(i).unwrap())\n        }\n    }","Real(LocalPath(\"src/linspace.rs\"))"],"<linspace::Linspace<F> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let n = self.len - self.index;\n        (n, Some(n))\n    }","Real(LocalPath(\"src/linspace.rs\"))"],"<logspace::Logspace<F> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<F>{\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            self.len -= 1;\n            let i = self.len;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * self.base.powf(exponent))\n        }\n    }","Real(LocalPath(\"src/logspace.rs\"))"],"<logspace::Logspace<F> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<F>{\n        if self.index >= self.len {\n            None\n        } else {\n            // Calculate the value just like numpy.linspace does\n            let i = self.index;\n            self.index += 1;\n            let exponent = self.start + self.step * F::from(i).unwrap();\n            Some(self.sign * self.base.powf(exponent))\n        }\n    }","Real(LocalPath(\"src/logspace.rs\"))"],"<logspace::Logspace<F> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let n = self.len - self.index;\n        (n, Some(n))\n    }","Real(LocalPath(\"src/logspace.rs\"))"],"<slice::Slice as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::Range<i32>>>::from":["#[inline]\nfn from(r: Range<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::Range<isize>>>::from":["#[inline]\nfn from(r: Range<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::Range<usize>>>::from":["#[inline]\nfn from(r: Range<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<i32>>>::from":["#[inline]\nfn from(r: RangeFrom<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<isize>>>::from":["#[inline]\nfn from(r: RangeFrom<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<usize>>>::from":["#[inline]\nfn from(r: RangeFrom<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeFull>>::from":["#[inline]\nfn from(_: RangeFull) -> Slice{\n        Slice {\n            start: 0,\n            end: None,\n            step: 1,\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<i32>>>::from":["#[inline]\nfn from(r: RangeInclusive<$index>) -> $self{\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<isize>>>::from":["#[inline]\nfn from(r: RangeInclusive<$index>) -> $self{\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["#[inline]\nfn from(r: RangeInclusive<$index>) -> $self{\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeTo<i32>>>::from":["#[inline]\nfn from(r: RangeTo<$index>) -> $self{\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeTo<isize>>>::from":["#[inline]\nfn from(r: RangeTo<$index>) -> $self{\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeTo<usize>>>::from":["#[inline]\nfn from(r: RangeTo<$index>) -> $self{\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<i32>>>::from":["#[inline]\nfn from(r: RangeToInclusive<$index>) -> $self{\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<isize>>>::from":["#[inline]\nfn from(r: RangeToInclusive<$index>) -> $self{\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["#[inline]\nfn from(r: RangeToInclusive<$index>) -> $self{\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceInfo<T, D> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        SliceInfo {\n            out_dim: PhantomData,\n            indices: self.indices.clone(),\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceInfo<T, D> as std::convert::AsRef<[slice::SliceOrIndex]>>::as_ref":["fn as_ref(&self) -> &[SliceOrIndex]{\n        self.indices.as_ref()\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceInfo<T, D> as std::convert::AsRef<slice::SliceInfo<[slice::SliceOrIndex], D>>>::as_ref":["fn as_ref(&self) -> &SliceInfo<[SliceOrIndex], D>{\n        unsafe {\n            // This is okay because the only non-zero-sized member of\n            // `SliceInfo` is `indices`, so `&SliceInfo<[SliceOrIndex], D>`\n            // should have the same bitwise representation as\n            // `&[SliceOrIndex]`.\n            &*(self.indices.as_ref() as *const [SliceOrIndex]\n                as *const SliceInfo<[SliceOrIndex], D>)\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceInfo<T, D> as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        &self.indices\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::clone::Clone>::clone":["#[inline(always)]\nfn clone(&self) -> Self{ *self }","Real(LocalPath(\"src/macro_utils.rs\"))"],"<slice::SliceOrIndex as std::convert::From<i32>>::from":["#[inline]\nfn from(r: $index) -> SliceOrIndex{\n                SliceOrIndex::Index(r as isize)\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<isize>>::from":["#[inline]\nfn from(r: $index) -> SliceOrIndex{\n                SliceOrIndex::Index(r as isize)\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<slice::Slice>>::from":["#[inline]\nfn from(s: Slice) -> SliceOrIndex{\n        SliceOrIndex::Slice {\n            start: s.start,\n            end: s.end,\n            step: s.step,\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<i32>>>::from":["#[inline]\nfn from(r: Range<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<isize>>>::from":["#[inline]\nfn from(r: Range<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<usize>>>::from":["#[inline]\nfn from(r: Range<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<i32>>>::from":["#[inline]\nfn from(r: RangeFrom<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<isize>>>::from":["#[inline]\nfn from(r: RangeFrom<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<usize>>>::from":["#[inline]\nfn from(r: RangeFrom<$index>) -> $self{\n                $constructor {\n                    start: r.start as isize,\n                    end: None,\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFull>>::from":["#[inline]\nfn from(_: RangeFull) -> SliceOrIndex{\n        SliceOrIndex::Slice {\n            start: 0,\n            end: None,\n            step: 1,\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<i32>>>::from":["#[inline]\nfn from(r: RangeInclusive<$index>) -> $self{\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<isize>>>::from":["#[inline]\nfn from(r: RangeInclusive<$index>) -> $self{\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["#[inline]\nfn from(r: RangeInclusive<$index>) -> $self{\n                let end = *r.end() as isize;\n                $constructor {\n                    start: *r.start() as isize,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<i32>>>::from":["#[inline]\nfn from(r: RangeTo<$index>) -> $self{\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<isize>>>::from":["#[inline]\nfn from(r: RangeTo<$index>) -> $self{\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<usize>>>::from":["#[inline]\nfn from(r: RangeTo<$index>) -> $self{\n                $constructor {\n                    start: 0,\n                    end: Some(r.end as isize),\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<i32>>>::from":["#[inline]\nfn from(r: RangeToInclusive<$index>) -> $self{\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<isize>>>::from":["#[inline]\nfn from(r: RangeToInclusive<$index>) -> $self{\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["#[inline]\nfn from(r: RangeToInclusive<$index>) -> $self{\n                let end = r.end as isize;\n                $constructor {\n                    start: 0,\n                    end: if end == -1 { None } else { Some(end + 1) },\n                    step: 1,\n                }\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::convert::From<usize>>::from":["#[inline]\nfn from(r: $index) -> SliceOrIndex{\n                SliceOrIndex::Index(r as isize)\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::SliceOrIndex as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            SliceOrIndex::Index(index) => write!(f, \"{}\", index)?,\n            SliceOrIndex::Slice { start, end, step } => {\n                if start != 0 {\n                    write!(f, \"{}\", start)?;\n                }\n                write!(f, \"..\")?;\n                if let Some(i) = end {\n                    write!(f, \"{}\", i)?;\n                }\n                if step != 1 {\n                    write!(f, \";{}\", step)?;\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<std::ops::Range<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<std::ops::RangeFrom<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<std::ops::RangeFull as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<std::ops::RangeInclusive<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<std::ops::RangeTo<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<std::ops::RangeToInclusive<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1::Larger>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"<std::vec::Vec<usize> as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Self::Dim{\n        Dim::new(IxDynImpl::from(self))\n    }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<usize as dimension::axes::IncOps>::post_dec":["#[inline(always)]\nfn post_dec(&mut self) -> Self{\n        let x = *self;\n        *self -= 1;\n        x\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<usize as dimension::axes::IncOps>::post_inc":["#[inline(always)]\nfn post_inc(&mut self) -> Self{\n        let x = *self;\n        *self += 1;\n        x\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<usize as dimension::axes::IncOps>::pre_dec":["#[inline(always)]\nfn pre_dec(&mut self) -> Self{\n        *self -= 1;\n        *self\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"<usize as dimension::conversion::IntoDimension>::into_dimension":["#[inline(always)]\nfn into_dimension(self) -> Ix1{\n        Ix1(self)\n    }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &Ix1, strides: &Ix1) -> Option<isize>{\n        dim.stride_offset_checked(strides, &Ix1(*self))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_unchecked":["#[inline(always)]\nfn index_unchecked(&self, strides: &Ix1) -> isize{\n        stride_offset(*self, get!(strides, 0))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["#[inline]\nfn index_checked(&self, dim: &IxDyn, strides: &IxDyn) -> Option<isize>{\n        debug_assert_eq!(dim.ndim(), 1);\n        stride_offset_checked(dim.ix(), strides.ix(), &[*self])\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["#[inline(always)]\nfn index_unchecked(&self, strides: &IxDyn) -> isize{\n        debug_assert_eq!(strides.ndim(), 1);\n        stride_offset(*self, get!(strides, 0))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"<usize as slice::SliceNextDim<D1, D1>>::next_dim":["fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D1>{\n                PhantomData\n            }","Real(LocalPath(\"src/slice.rs\"))"],"ArrayBase":["/// An *n*-dimensional array.\n///\n/// The array is a general container of elements. It cannot grow or shrink, but\n/// can be sliced into subsets of its data.\n/// The array supports arithmetic operations by applying them elementwise.\n///\n/// In *n*-dimensional we include for example 1-dimensional rows or columns,\n/// 2-dimensional matrices, and higher dimensional arrays. If the array has *n*\n/// dimensions, then an element is accessed by using that many indices.\n///\n/// The `ArrayBase<S, D>` is parameterized by `S` for the data container and\n/// `D` for the dimensionality.\n///\n/// Type aliases [`Array`], [`ArcArray`], [`CowArray`], [`ArrayView`], and\n/// [`ArrayViewMut`] refer to `ArrayBase` with different types for the data\n/// container.\n///\n/// [`Array`]: type.Array.html\n/// [`ArcArray`]: type.ArcArray.html\n/// [`ArrayView`]: type.ArrayView.html\n/// [`ArrayViewMut`]: type.ArrayViewMut.html\n/// [`CowArray`]: type.CowArray.html\n///\n/// ## Contents\n///\n/// + [Array](#array)\n/// + [ArcArray](#arcarray)\n/// + [CowArray](#cowarray)\n/// + [Array Views](#array-views)\n/// + [Indexing and Dimension](#indexing-and-dimension)\n/// + [Loops, Producers and Iterators](#loops-producers-and-iterators)\n/// + [Slicing](#slicing)\n/// + [Subviews](#subviews)\n/// + [Arithmetic Operations](#arithmetic-operations)\n/// + [Broadcasting](#broadcasting)\n/// + [Conversions](#conversions)\n/// + [Constructor Methods for Owned Arrays](#constructor-methods-for-owned-arrays)\n/// + [Methods For All Array Types](#methods-for-all-array-types)\n/// + [Methods For 1-D Arrays](#methods-for-1-d-arrays)\n/// + [Methods For 2-D Arrays](#methods-for-2-d-arrays)\n/// + [Methods for Dynamic-Dimensional Arrays](#methods-for-dynamic-dimensional-arrays)\n/// + [Numerical Methods for Arrays](#numerical-methods-for-arrays)\n///\n/// ## `Array`\n///\n/// [`Array`](type.Array.html) is an owned array that owns the underlying array\n/// elements directly (just like a `Vec`) and it is the default way to create and\n/// store n-dimensional data. `Array<A, D>` has two type parameters: `A` for\n/// the element type, and `D` for the dimensionality. A particular\n/// dimensionality's type alias like `Array3<A>` just has the type parameter\n/// `A` for element type.\n///\n/// An example:\n///\n/// ```\n/// // Create a three-dimensional f64 array, initialized with zeros\n/// use ndarray::Array3;\n/// let mut temperature = Array3::<f64>::zeros((3, 4, 5));\n/// // Increase the temperature in this location\n/// temperature[[2, 2, 2]] += 0.5;\n/// ```\n///\n/// ## `ArcArray`\n///\n/// [`ArcArray`](type.ArcArray.html) is an owned array with reference counted\n/// data (shared ownership).\n/// Sharing requires that it uses copy-on-write for mutable operations.\n/// Calling a method for mutating elements on `ArcArray`, for example\n/// [`view_mut()`](#method.view_mut) or [`get_mut()`](#method.get_mut),\n/// will break sharing and require a clone of the data (if it is not uniquely held).\n///\n/// ## `CowArray`\n///\n/// [`CowArray`](type.CowArray.html) is analogous to\n/// [`std::borrow::Cow`](https://doc.rust-lang.org/std/borrow/enum.Cow.html).\n/// It can represent either an immutable view or a uniquely owned array. If a\n/// `CowArray` instance is the immutable view variant, then calling a method\n/// for mutating elements in the array will cause it to be converted into the\n/// owned variant (by cloning all the elements) before the modification is\n/// performed.\n///\n/// ## Array Views\n///\n/// [`ArrayView`] and [`ArrayViewMut`] are read-only and read-write array views\n/// respectively. They use dimensionality, indexing, and almost all other\n/// methods the same was as the other array types.\n///\n/// Methods for `ArrayBase` apply to array views too, when the trait bounds\n/// allow.\n///\n/// Please see the documentation for the respective array view for an overview\n/// of methods specific to array views: [`ArrayView`], [`ArrayViewMut`].\n///\n/// A view is created from an array using `.view()`, `.view_mut()`, using\n/// slicing (`.slice()`, `.slice_mut()`) or from one of the many iterators\n/// that yield array views.\n///\n/// You can also create an array view from a regular slice of data not\n/// allocated with `Array`  see array view methods or their `From` impls.\n///\n/// Note that all `ArrayBase` variants can change their view (slicing) of the\n/// data freely, even when their data cant be mutated.\n///\n/// ## Indexing and Dimension\n///\n/// The dimensionality of the array determines the number of *axes*, for example\n/// a 2D array has two axes. These are listed in big endian order, so that\n/// the greatest dimension is listed first, the lowest dimension with the most\n/// rapidly varying index is the last.\n///\n/// In a 2D array the index of each element is `[row, column]` as seen in this\n/// 4  3 example:\n///\n/// ```ignore\n/// [[ [0, 0], [0, 1], [0, 2] ],  // row 0\n///  [ [1, 0], [1, 1], [1, 2] ],  // row 1\n///  [ [2, 0], [2, 1], [2, 2] ],  // row 2\n///  [ [3, 0], [3, 1], [3, 2] ]]  // row 3\n/// //    \\       \\       \\\n/// //   column 0  \\     column 2\n/// //            column 1\n/// ```\n///\n/// The number of axes for an array is fixed by its `D` type parameter: `Ix1`\n/// for a 1D array, `Ix2` for a 2D array etc. The dimension type `IxDyn` allows\n/// a dynamic number of axes.\n///\n/// A fixed size array (`[usize; N]`) of the corresponding dimensionality is\n/// used to index the `Array`, making the syntax `array[[` i, j,  ...`]]`\n///\n/// ```\n/// use ndarray::Array2;\n/// let mut array = Array2::zeros((4, 3));\n/// array[[1, 1]] = 7;\n/// ```\n///\n/// Important traits and types for dimension and indexing:\n///\n/// - A [`Dim`](struct.Dim.html) value represents a dimensionality or index.\n/// - Trait [`Dimension`](trait.Dimension.html) is implemented by all\n/// dimensionalities. It defines many operations for dimensions and indices.\n/// - Trait [`IntoDimension`](trait.IntoDimension.html) is used to convert into a\n/// `Dim` value.\n/// - Trait [`ShapeBuilder`](trait.ShapeBuilder.html) is an extension of\n/// `IntoDimension` and is used when constructing an array. A shape describes\n/// not just the extent of each axis but also their strides.\n/// - Trait [`NdIndex`](trait.NdIndex.html) is an extension of `Dimension` and is\n/// for values that can be used with indexing syntax.\n///\n///\n/// The default memory order of an array is *row major* order (a.k.a c order),\n/// where each row is contiguous in memory.\n/// A *column major* (a.k.a. f or fortran) memory order array has\n/// columns (or, in general, the outermost axis) with contiguous elements.\n///\n/// The logical order of any arrays elements is the row major order\n/// (the rightmost index is varying the fastest).\n/// The iterators `.iter(), .iter_mut()` always adhere to this order, for example.\n///\n/// ## Loops, Producers and Iterators\n///\n/// Using [`Zip`](struct.Zip.html) is the most general way to apply a procedure\n/// across one or several arrays or *producers*.\n///\n/// [`NdProducer`](trait.NdProducer.html) is like an iterable but for\n/// multidimensional data. All producers have dimensions and axes, like an\n/// array view, and they can be split and used with parallelization using `Zip`.\n///\n/// For example, `ArrayView<A, D>` is a producer, it has the same dimensions\n/// as the array view and for each iteration it produces a reference to\n/// the array element (`&A` in this case).\n///\n/// Another example, if we have a 10  10 array and use `.exact_chunks((2, 2))`\n/// we get a producer of chunks which has the dimensions 5  5 (because\n/// there are *10 / 2 = 5* chunks in either direction). The 5  5 chunks producer\n/// can be paired with any other producers of the same dimension with `Zip`, for\n/// example 5  5 arrays.\n///\n/// ### `.iter()` and `.iter_mut()`\n///\n/// These are the element iterators of arrays and they produce an element\n/// sequence in the logical order of the array, that means that the elements\n/// will be visited in the sequence that corresponds to increasing the\n/// last index first: *0, ..., 0,  0*; *0, ..., 0, 1*; *0, ...0, 2* and so on.\n///\n/// ### `.outer_iter()` and `.axis_iter()`\n///\n/// These iterators produce array views of one smaller dimension.\n///\n/// For example, for a 2D array, `.outer_iter()` will produce the 1D rows.\n/// For a 3D array, `.outer_iter()` produces 2D subviews.\n///\n/// `.axis_iter()` is like `outer_iter()` but allows you to pick which\n/// axis to traverse.\n///\n/// The `outer_iter` and `axis_iter` are one dimensional producers.\n///\n/// ## `.genrows()`, `.gencolumns()` and `.lanes()`\n///\n/// [`.genrows()`][gr] is a producer (and iterable) of all rows in an array.\n///\n/// ```\n/// use ndarray::Array;\n///\n/// // 1. Loop over the rows of a 2D array\n/// let mut a = Array::zeros((10, 10));\n/// for mut row in a.genrows_mut() {\n///     row.fill(1.);\n/// }\n///\n/// // 2. Use Zip to pair each row in 2D `a` with elements in 1D `b`\n/// use ndarray::Zip;\n/// let mut b = Array::zeros(a.nrows());\n///\n/// Zip::from(a.genrows())\n///     .and(&mut b)\n///     .apply(|a_row, b_elt| {\n///         *b_elt = a_row[a.ncols() - 1] - a_row[0];\n///     });\n/// ```\n///\n/// The *lanes* of an array are 1D segments along an axis and when pointed\n/// along the last axis they are *rows*, when pointed along the first axis\n/// they are *columns*.\n///\n/// A *m*  *n* array has *m* rows each of length *n* and conversely\n/// *n* columns each of length *m*.\n///\n/// To generalize this, we say that an array of dimension *a*  *m*  *n*\n/// has *a m* rows. It's composed of *a* times the previous array, so it\n/// has *a* times as many rows.\n///\n/// All methods: [`.genrows()`][gr], [`.genrows_mut()`][grm],\n/// [`.gencolumns()`][gc], [`.gencolumns_mut()`][gcm],\n/// [`.lanes(axis)`][l], [`.lanes_mut(axis)`][lm].\n///\n/// [gr]: #method.genrows\n/// [grm]: #method.genrows_mut\n/// [gc]: #method.gencolumns\n/// [gcm]: #method.gencolumns_mut\n/// [l]: #method.lanes\n/// [lm]: #method.lanes_mut\n///\n/// Yes, for 2D arrays `.genrows()` and `.outer_iter()` have about the same\n/// effect:\n///\n///  + `genrows()` is a producer with *n* - 1 dimensions of 1 dimensional items\n///  + `outer_iter()` is a producer with 1 dimension of *n* - 1 dimensional items\n///\n/// ## Slicing\n///\n/// You can use slicing to create a view of a subset of the data in\n/// the array. Slicing methods include [`.slice()`], [`.slice_mut()`],\n/// [`.slice_move()`], and [`.slice_collapse()`].\n///\n/// The slicing argument can be passed using the macro [`s![]`](macro.s!.html),\n/// which will be used in all examples. (The explicit form is an instance of\n/// [`&SliceInfo`]; see its docs for more information.)\n///\n/// [`&SliceInfo`]: struct.SliceInfo.html\n///\n/// If a range is used, the axis is preserved. If an index is used, that index\n/// is selected and the axis is removed; this selects a subview. See\n/// [*Subviews*](#subviews) for more information about subviews. Note that\n/// [`.slice_collapse()`] behaves like [`.collapse_axis()`] by preserving\n/// the number of dimensions.\n///\n/// [`.slice()`]: #method.slice\n/// [`.slice_mut()`]: #method.slice_mut\n/// [`.slice_move()`]: #method.slice_move\n/// [`.slice_collapse()`]: #method.slice_collapse\n///\n/// It's possible to take multiple simultaneous *mutable* slices with\n/// [`.multi_slice_mut()`] or (for [`ArrayViewMut`] only)\n/// [`.multi_slice_move()`].\n///\n/// [`.multi_slice_mut()`]: #method.multi_slice_mut\n/// [`.multi_slice_move()`]: type.ArrayViewMut.html#method.multi_slice_move\n///\n/// ```\n///\n/// use ndarray::{arr2, arr3, s};\n///\n/// // 2 submatrices of 2 rows with 3 elements per row, means a shape of `[2, 2, 3]`.\n///\n/// let a = arr3(&[[[ 1,  2,  3],     // -- 2 rows  \\_\n///                 [ 4,  5,  6]],    // --         /\n///                [[ 7,  8,  9],     //            \\_ 2 submatrices\n///                 [10, 11, 12]]]);  //            /\n/// //  3 columns ..../.../.../\n///\n/// assert_eq!(a.shape(), &[2, 2, 3]);\n///\n/// // Lets create a slice with\n/// //\n/// // - Both of the submatrices of the greatest dimension: `..`\n/// // - Only the first row in each submatrix: `0..1`\n/// // - Every element in each row: `..`\n///\n/// let b = a.slice(s![.., 0..1, ..]);\n/// let c = arr3(&[[[ 1,  2,  3]],\n///                [[ 7,  8,  9]]]);\n/// assert_eq!(b, c);\n/// assert_eq!(b.shape(), &[2, 1, 3]);\n///\n/// // Lets create a slice with\n/// //\n/// // - Both submatrices of the greatest dimension: `..`\n/// // - The last row in each submatrix: `-1..`\n/// // - Row elements in reverse order: `..;-1`\n/// let d = a.slice(s![.., -1.., ..;-1]);\n/// let e = arr3(&[[[ 6,  5,  4]],\n///                [[12, 11, 10]]]);\n/// assert_eq!(d, e);\n/// assert_eq!(d.shape(), &[2, 1, 3]);\n///\n/// // Lets create a slice while selecting a subview with\n/// //\n/// // - Both submatrices of the greatest dimension: `..`\n/// // - The last row in each submatrix, removing that axis: `-1`\n/// // - Row elements in reverse order: `..;-1`\n/// let f = a.slice(s![.., -1, ..;-1]);\n/// let g = arr2(&[[ 6,  5,  4],\n///                [12, 11, 10]]);\n/// assert_eq!(f, g);\n/// assert_eq!(f.shape(), &[2, 3]);\n///\n/// // Let's take two disjoint, mutable slices of a matrix with\n/// //\n/// // - One containing all the even-index columns in the matrix\n/// // - One containing all the odd-index columns in the matrix\n/// let mut h = arr2(&[[0, 1, 2, 3],\n///                    [4, 5, 6, 7]]);\n/// let (s0, s1) = h.multi_slice_mut((s![.., ..;2], s![.., 1..;2]));\n/// let i = arr2(&[[0, 2],\n///                [4, 6]]);\n/// let j = arr2(&[[1, 3],\n///                [5, 7]]);\n/// assert_eq!(s0, i);\n/// assert_eq!(s1, j);\n/// ```\n///\n/// ## Subviews\n///\n/// Subview methods allow you to restrict the array view while removing one\n/// axis from the array. Methods for selecting individual subviews include\n/// [`.index_axis()`], [`.index_axis_mut()`], [`.index_axis_move()`], and\n/// [`.index_axis_inplace()`]. You can also select a subview by using a single\n/// index instead of a range when slicing. Some other methods, such as\n/// [`.fold_axis()`], [`.axis_iter()`], [`.axis_iter_mut()`],\n/// [`.outer_iter()`], and [`.outer_iter_mut()`] operate on all the subviews\n/// along an axis.\n///\n/// A related method is [`.collapse_axis()`], which modifies the view in the\n/// same way as [`.index_axis()`] except for removing the collapsed axis, since\n/// it operates *in place*. The length of the axis becomes 1.\n///\n/// Methods for selecting an individual subview take two arguments: `axis` and\n/// `index`.\n///\n/// [`.axis_iter()`]: #method.axis_iter\n/// [`.axis_iter_mut()`]: #method.axis_iter_mut\n/// [`.fold_axis()`]: #method.fold_axis\n/// [`.index_axis()`]: #method.index_axis\n/// [`.index_axis_inplace()`]: #method.index_axis_inplace\n/// [`.index_axis_mut()`]: #method.index_axis_mut\n/// [`.index_axis_move()`]: #method.index_axis_move\n/// [`.collapse_axis()`]: #method.collapse_axis\n/// [`.outer_iter()`]: #method.outer_iter\n/// [`.outer_iter_mut()`]: #method.outer_iter_mut\n///\n/// ```\n///\n/// use ndarray::{arr3, aview1, aview2, s, Axis};\n///\n///\n/// // 2 submatrices of 2 rows with 3 elements per row, means a shape of `[2, 2, 3]`.\n///\n/// let a = arr3(&[[[ 1,  2,  3],    // \\ axis 0, submatrix 0\n///                 [ 4,  5,  6]],   // /\n///                [[ 7,  8,  9],    // \\ axis 0, submatrix 1\n///                 [10, 11, 12]]]); // /\n///         //        \\\n///         //         axis 2, column 0\n///\n/// assert_eq!(a.shape(), &[2, 2, 3]);\n///\n/// // Lets take a subview along the greatest dimension (axis 0),\n/// // taking submatrix 0, then submatrix 1\n///\n/// let sub_0 = a.index_axis(Axis(0), 0);\n/// let sub_1 = a.index_axis(Axis(0), 1);\n///\n/// assert_eq!(sub_0, aview2(&[[ 1,  2,  3],\n///                            [ 4,  5,  6]]));\n/// assert_eq!(sub_1, aview2(&[[ 7,  8,  9],\n///                            [10, 11, 12]]));\n/// assert_eq!(sub_0.shape(), &[2, 3]);\n///\n/// // This is the subview picking only axis 2, column 0\n/// let sub_col = a.index_axis(Axis(2), 0);\n///\n/// assert_eq!(sub_col, aview2(&[[ 1,  4],\n///                              [ 7, 10]]));\n///\n/// // You can take multiple subviews at once (and slice at the same time)\n/// let double_sub = a.slice(s![1, .., 0]);\n/// assert_eq!(double_sub, aview1(&[7, 10]));\n/// ```\n///\n/// ## Arithmetic Operations\n///\n/// Arrays support all arithmetic operations the same way: they apply elementwise.\n///\n/// Since the trait implementations are hard to overview, here is a summary.\n///\n/// ### Binary Operators with Two Arrays\n///\n/// Let `A` be an array or view of any kind. Let `B` be an array\n/// with owned storage (either `Array` or `ArcArray`).\n/// Let `C` be an array with mutable data (either `Array`, `ArcArray`\n/// or `ArrayViewMut`).\n/// The following combinations of operands\n/// are supported for an arbitrary binary operator denoted by `@` (it can be\n/// `+`, `-`, `*`, `/` and so on).\n///\n/// - `&A @ &A` which produces a new `Array`\n/// - `B @ A` which consumes `B`, updates it with the result, and returns it\n/// - `B @ &A` which consumes `B`, updates it with the result, and returns it\n/// - `C @= &A` which performs an arithmetic operation in place\n///\n/// Note that the element type needs to implement the operator trait and the\n/// `Clone` trait.\n///\n/// ```\n/// use ndarray::{array, ArrayView1};\n///\n/// let owned1 = array![1, 2];\n/// let owned2 = array![3, 4];\n/// let view1 = ArrayView1::from(&[5, 6]);\n/// let view2 = ArrayView1::from(&[7, 8]);\n/// let mut mutable = array![9, 10];\n///\n/// let sum1 = &view1 + &view2;   // Allocates a new array. Note the explicit `&`.\n/// // let sum2 = view1 + &view2; // This doesn't work because `view1` is not an owned array.\n/// let sum3 = owned1 + view1;    // Consumes `owned1`, updates it, and returns it.\n/// let sum4 = owned2 + &view2;   // Consumes `owned2`, updates it, and returns it.\n/// mutable += &view2;            // Updates `mutable` in-place.\n/// ```\n///\n/// ### Binary Operators with Array and Scalar\n///\n/// The trait [`ScalarOperand`](trait.ScalarOperand.html) marks types that can be used in arithmetic\n/// with arrays directly. For a scalar `K` the following combinations of operands\n/// are supported (scalar can be on either the left or right side, but\n/// `ScalarOperand` docs has the detailed condtions).\n///\n/// - `&A @ K` or `K @ &A` which produces a new `Array`\n/// - `B @ K` or `K @ B` which consumes `B`, updates it with the result and returns it\n/// - `C @= K` which performs an arithmetic operation in place\n///\n/// ### Unary Operators\n///\n/// Let `A` be an array or view of any kind. Let `B` be an array with owned\n/// storage (either `Array` or `ArcArray`). The following operands are supported\n/// for an arbitrary unary operator denoted by `@` (it can be `-` or `!`).\n///\n/// - `@&A` which produces a new `Array`\n/// - `@B` which consumes `B`, updates it with the result, and returns it\n///\n/// ## Broadcasting\n///\n/// Arrays support limited *broadcasting*, where arithmetic operations with\n/// array operands of different sizes can be carried out by repeating the\n/// elements of the smaller dimension array. See\n/// [`.broadcast()`](#method.broadcast) for a more detailed\n/// description.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[1., 1.],\n///                [1., 2.],\n///                [0., 3.],\n///                [0., 4.]]);\n///\n/// let b = arr2(&[[0., 1.]]);\n///\n/// let c = arr2(&[[1., 2.],\n///                [1., 3.],\n///                [0., 4.],\n///                [0., 5.]]);\n/// // We can add because the shapes are compatible even if not equal.\n/// // The `b` array is shape 1  2 but acts like a 4  2 array.\n/// assert!(\n///     c == a + b\n/// );\n/// ```\n///\n/// ## Conversions\n///\n/// ### Conversions Between Array Types\n///\n/// This table is a summary of the conversions between arrays of different\n/// ownership, dimensionality, and element type. All of the conversions in this\n/// table preserve the shape of the array.\n///\n/// <table>\n/// <tr>\n/// <th rowspan=\"2\">Output</th>\n/// <th colspan=\"5\">Input</th>\n/// </tr>\n///\n/// <tr>\n/// <td>\n///\n/// `Array<A, D>`\n///\n/// </td>\n/// <td>\n///\n/// `ArcArray<A, D>`\n///\n/// </td>\n/// <td>\n///\n/// `CowArray<'a, A, D>`\n///\n/// </td>\n/// <td>\n///\n/// `ArrayView<'a, A, D>`\n///\n/// </td>\n/// <td>\n///\n/// `ArrayViewMut<'a, A, D>`\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to `Array<A, D>`-->\n///\n/// <tr>\n/// <td>\n///\n/// `Array<A, D>`\n///\n/// </td>\n/// <td>\n///\n/// no-op\n///\n/// </td>\n/// <td>\n///\n/// [`a.into_owned()`][.into_owned()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.into_owned()`][.into_owned()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.to_owned()`][.to_owned()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.to_owned()`][.to_owned()]\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to `ArcArray<A, D>`-->\n///\n/// <tr>\n/// <td>\n///\n/// `ArcArray<A, D>`\n///\n/// </td>\n/// <td>\n///\n/// [`a.into_shared()`][.into_shared()]\n///\n/// </td>\n/// <td>\n///\n/// no-op\n///\n/// </td>\n/// <td>\n///\n/// [`a.into_owned().into_shared()`][.into_shared()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.to_owned().into_shared()`][.into_shared()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.to_owned().into_shared()`][.into_shared()]\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to `CowArray<'a, A, D>`-->\n///\n/// <tr>\n/// <td>\n///\n/// `CowArray<'a, A, D>`\n///\n/// </td>\n/// <td>\n///\n/// [`CowArray::from(a)`](type.CowArray.html#impl-From<ArrayBase<OwnedRepr<A>%2C%20D>>)\n///\n/// </td>\n/// <td>\n///\n/// [`CowArray::from(a.into_owned())`](type.CowArray.html#impl-From<ArrayBase<OwnedRepr<A>%2C%20D>>)\n///\n/// </td>\n/// <td>\n///\n/// no-op\n///\n/// </td>\n/// <td>\n///\n/// [`CowArray::from(a)`](type.CowArray.html#impl-From<ArrayBase<ViewRepr<%26%27a%20A>%2C%20D>>)\n///\n/// </td>\n/// <td>\n///\n/// [`CowArray::from(a.view())`](type.CowArray.html#impl-From<ArrayBase<ViewRepr<%26%27a%20A>%2C%20D>>)\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to `ArrayView<'b, A, D>`-->\n///\n/// <tr>\n/// <td>\n///\n/// `ArrayView<'b, A, D>`\n///\n/// </td>\n/// <td>\n///\n/// [`a.view()`][.view()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.view()`][.view()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.view()`][.view()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.view()`][.view()] or [`a.reborrow()`][ArrayView::reborrow()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.view()`][.view()]\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to `ArrayViewMut<'b, A, D>`-->\n///\n/// <tr>\n/// <td>\n///\n/// `ArrayViewMut<'b, A, D>`\n///\n/// </td>\n/// <td>\n///\n/// [`a.view_mut()`][.view_mut()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.view_mut()`][.view_mut()]\n///\n/// </td>\n/// <td>\n///\n/// [`a.view_mut()`][.view_mut()]\n///\n/// </td>\n/// <td>\n///\n/// illegal\n///\n/// </td>\n/// <td>\n///\n/// [`a.view_mut()`][.view_mut()] or [`a.reborrow()`][ArrayViewMut::reborrow()]\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to equivalent with dim `D2`-->\n///\n/// <tr>\n/// <td>\n///\n/// equivalent with dim `D2` (e.g. converting from dynamic dim to const dim)\n///\n/// </td>\n/// <td colspan=\"5\">\n///\n/// [`a.into_dimensionality::<D2>()`][.into_dimensionality()]\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to equivalent with dim `IxDyn`-->\n///\n/// <tr>\n/// <td>\n///\n/// equivalent with dim `IxDyn`\n///\n/// </td>\n/// <td colspan=\"5\">\n///\n/// [`a.into_dyn()`][.into_dyn()]\n///\n/// </td>\n/// </tr>\n///\n/// <!--Conversions to `Array<B, D>`-->\n///\n/// <tr>\n/// <td>\n///\n/// `Array<B, D>` (new element type)\n///\n/// </td>\n/// <td colspan=\"5\">\n///\n/// [`a.map(|x| x.do_your_conversion())`][.map()]\n///\n/// </td>\n/// </tr>\n/// </table>\n///\n/// ### Conversions Between Arrays and `Vec`s/Slices/Scalars\n///\n/// This is a table of the safe conversions between arrays and\n/// `Vec`s/slices/scalars. Note that some of the return values are actually\n/// `Result`/`Option` wrappers around the indicated output types.\n///\n/// Input | Output | Methods\n/// ------|--------|--------\n/// `Vec<A>` | `ArrayBase<S: DataOwned, Ix1>` | [`::from_vec()`](#method.from_vec)\n/// `Vec<A>` | `ArrayBase<S: DataOwned, D>` | [`::from_shape_vec()`](#method.from_shape_vec)\n/// `&[A]` | `ArrayView1<A>` | [`::from()`](type.ArrayView.html#method.from)\n/// `&[A]` | `ArrayView<A, D>` | [`::from_shape()`](type.ArrayView.html#method.from_shape)\n/// `&mut [A]` | `ArrayViewMut1<A>` | [`::from()`](type.ArrayViewMut.html#method.from)\n/// `&mut [A]` | `ArrayViewMut<A, D>` | [`::from_shape()`](type.ArrayViewMut.html#method.from_shape)\n/// `&ArrayBase<S, Ix1>` | `Vec<A>` | [`.to_vec()`](#method.to_vec)\n/// `Array<A, D>` | `Vec<A>` | [`.into_raw_vec()`](type.Array.html#method.into_raw_vec)<sup>[1](#into_raw_vec)</sup>\n/// `&ArrayBase<S, D>` | `&[A]` | [`.as_slice()`](#method.as_slice)<sup>[2](#req_contig_std)</sup>, [`.as_slice_memory_order()`](#method.as_slice_memory_order)<sup>[3](#req_contig)</sup>\n/// `&mut ArrayBase<S: DataMut, D>` | `&mut [A]` | [`.as_slice_mut()`](#method.as_slice_mut)<sup>[2](#req_contig_std)</sup>, [`.as_slice_memory_order_mut()`](#method.as_slice_memory_order_mut)<sup>[3](#req_contig)</sup>\n/// `ArrayView<A, D>` | `&[A]` | [`.to_slice()`](type.ArrayView.html#method.to_slice)<sup>[2](#req_contig_std)</sup>\n/// `ArrayViewMut<A, D>` | `&mut [A]` | [`.into_slice()`](type.ArrayViewMut.html#method.into_slice)<sup>[2](#req_contig_std)</sup>\n/// `Array0<A>` | `A` | [`.into_scalar()`](type.Array.html#method.into_scalar)\n///\n/// <sup><a name=\"into_raw_vec\">1</a></sup>Returns the data in memory order.\n///\n/// <sup><a name=\"req_contig_std\">2</a></sup>Works only if the array is\n/// contiguous and in standard order.\n///\n/// <sup><a name=\"req_contig\">3</a></sup>Works only if the array is contiguous.\n///\n/// The table above does not include all the constructors; it only shows\n/// conversions to/from `Vec`s/slices. See\n/// [below](#constructor-methods-for-owned-arrays) for more constructors.\n///\n/// [ArrayView::reborrow()]: type.ArrayView.html#method.reborrow\n/// [ArrayViewMut::reborrow()]: type.ArrayViewMut.html#method.reborrow\n/// [.into_dimensionality()]: #method.into_dimensionality\n/// [.into_dyn()]: #method.into_dyn\n/// [.into_owned()]: #method.into_owned\n/// [.into_shared()]: #method.into_shared\n/// [.to_owned()]: #method.to_owned\n/// [.map()]: #method.map\n/// [.view()]: #method.view\n/// [.view_mut()]: #method.view_mut\n///\n/// ### Conversions from Nested `Vec`s/`Array`s\n///\n/// It's generally a good idea to avoid nested `Vec`/`Array` types, such as\n/// `Vec<Vec<A>>` or `Vec<Array2<A>>` because:\n///\n/// * they require extra heap allocations compared to a single `Array`,\n///\n/// * they can scatter data all over memory (because of multiple allocations),\n///\n/// * they cause unnecessary indirection (traversing multiple pointers to reach\n///   the data),\n///\n/// * they don't enforce consistent shape within the nested\n///   `Vec`s/`ArrayBase`s, and\n///\n/// * they are generally more difficult to work with.\n///\n/// The most common case where users might consider using nested\n/// `Vec`s/`Array`s is when creating an array by appending rows/subviews in a\n/// loop, where the rows/subviews are computed within the loop. However, there\n/// are better ways than using nested `Vec`s/`Array`s.\n///\n/// If you know ahead-of-time the shape of the final array, the cleanest\n/// solution is to allocate the final array before the loop, and then assign\n/// the data to it within the loop, like this:\n///\n/// ```rust\n/// use ndarray::{array, Array2, Axis};\n///\n/// let mut arr = Array2::zeros((2, 3));\n/// for (i, mut row) in arr.axis_iter_mut(Axis(0)).enumerate() {\n///     // Perform calculations and assign to `row`; this is a trivial example:\n///     row.fill(i);\n/// }\n/// assert_eq!(arr, array![[0, 0, 0], [1, 1, 1]]);\n/// ```\n///\n/// If you don't know ahead-of-time the shape of the final array, then the\n/// cleanest solution is generally to append the data to a flat `Vec`, and then\n/// convert it to an `Array` at the end with\n/// [`::from_shape_vec()`](#method.from_shape_vec). You just have to be careful\n/// that the layout of the data (the order of the elements in the flat `Vec`)\n/// is correct.\n///\n/// ```rust\n/// use ndarray::{array, Array2};\n///\n/// let ncols = 3;\n/// let mut data = Vec::new();\n/// let mut nrows = 0;\n/// for i in 0..2 {\n///     // Compute `row` and append it to `data`; this is a trivial example:\n///     let row = vec![i; ncols];\n///     data.extend_from_slice(&row);\n///     nrows += 1;\n/// }\n/// let arr = Array2::from_shape_vec((nrows, ncols), data)?;\n/// assert_eq!(arr, array![[0, 0, 0], [1, 1, 1]]);\n/// # Ok::<(), ndarray::ShapeError>(())\n/// ```\n///\n/// If neither of these options works for you, and you really need to convert\n/// nested `Vec`/`Array` instances to an `Array`, the cleanest solution is\n/// generally to use\n/// [`Iterator::flatten()`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten)\n/// to get a flat `Vec`, and then convert the `Vec` to an `Array` with\n/// [`::from_shape_vec()`](#method.from_shape_vec), like this:\n///\n/// ```rust\n/// use ndarray::{array, Array2, Array3};\n///\n/// let nested: Vec<Array2<i32>> = vec![\n///     array![[1, 2, 3], [4, 5, 6]],\n///     array![[7, 8, 9], [10, 11, 12]],\n/// ];\n/// let inner_shape = nested[0].dim();\n/// let shape = (nested.len(), inner_shape.0, inner_shape.1);\n/// let flat: Vec<i32> = nested.iter().flatten().cloned().collect();\n/// let arr = Array3::from_shape_vec(shape, flat)?;\n/// assert_eq!(arr, array![\n///     [[1, 2, 3], [4, 5, 6]],\n///     [[7, 8, 9], [10, 11, 12]],\n/// ]);\n/// # Ok::<(), ndarray::ShapeError>(())\n/// ```\n///\n/// Note that this implementation assumes that the nested `Vec`s are all the\n/// same shape and that the `Vec` is non-empty. Depending on your application,\n/// it may be a good idea to add checks for these assumptions and possibly\n/// choose a different way to handle the empty case.\n///\npub struct ArrayBase<S, D>\nwhere\n    S: RawData,\n{\n    /// Data buffer / ownership information. (If owned, contains the data\n    /// buffer; if borrowed, contains the lifetime and mutability.)\n    data: S,\n    /// A non-null pointer into the buffer held by `data`; may point anywhere\n    /// in its range. If `S: Data`, this pointer must be aligned.\n    ptr: std::ptr::NonNull<S::Elem>,\n    /// The lengths of the axes.\n    dim: D,\n    /// The element count stride per axis. To be parsed as `isize`.\n    strides: D,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::broadcast_assume":["#[inline]\nfn broadcast_assume<E>(&self, dim: E) -> ArrayView<'_, A, E>\n    where\n        E: Dimension,{\n        let dim = dim.into_dimension();\n        debug_assert_eq!(self.shape(), dim.slice());\n        let ptr = self.ptr;\n        let mut strides = dim.clone();\n        strides.slice_mut().copy_from_slice(self.strides.slice());\n        unsafe { ArrayView::new(ptr, dim, strides) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::broadcast_unwrap":["#[inline]\nfn broadcast_unwrap<E>(&self, dim: E) -> ArrayView<'_, A, E>\n    where\n        E: Dimension,{\n        #[cold]\n        #[inline(never)]\n        fn broadcast_panic<D, E>(from: &D, to: &E) -> !\n        where\n            D: Dimension,\n            E: Dimension,\n        {\n            panic!(\n                \"ndarray: could not broadcast array from shape: {:?} to: {:?}\",\n                from.slice(),\n                to.slice()\n            )\n        }\n\n        match self.broadcast(dim.clone()) {\n            Some(it) => it,\n            None => broadcast_panic(&self.dim, &dim),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::broadcast_unwrap::broadcast_panic":["#[cold]\n#[inline(never)]\nfn broadcast_panic<D, E>(from: &D, to: &E) -> !\n        where\n            D: Dimension,\n            E: Dimension,{\n            panic!(\n                \"ndarray: could not broadcast array from shape: {:?} to: {:?}\",\n                from.slice(),\n                to.slice()\n            )\n        }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::inner_rows":["/// n-d generalization of rows, just like inner iter\nfn inner_rows(&self) -> iterators::Lanes<'_, A, D::Smaller>{\n        let n = self.ndim();\n        Lanes::new(self.view(), Axis(n.saturating_sub(1)))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::inner_rows_mut":["/// n-d generalization of rows, just like inner iter\nfn inner_rows_mut(&mut self) -> iterators::LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,{\n        let n = self.ndim();\n        LanesMut::new(self.view_mut(), Axis(n.saturating_sub(1)))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::raw_strides":["fn raw_strides(&self) -> D{\n        self.strides.clone()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::try_remove_axis":["/// Remove array axis `axis` and return the result.\nfn try_remove_axis(self, axis: Axis) -> ArrayBase<S, D::Smaller>{\n        let d = self.dim.try_remove_axis(axis);\n        let s = self.strides.try_remove_axis(axis);\n        ArrayBase {\n            ptr: self.ptr,\n            data: self.data,\n            dim: d,\n            strides: s,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBase::<S, D>::unordered_foreach_mut":["/// Apply closure `f` to each element in the array, in whatever\n/// order is the fastest to visit.\nfn unordered_foreach_mut<F>(&mut self, mut f: F)\n    where\n        S: DataMut,\n        F: FnMut(&mut A),{\n        if let Some(slc) = self.as_slice_memory_order_mut() {\n            slc.iter_mut().for_each(f);\n        } else {\n            for row in self.inner_rows_mut() {\n                row.into_iter_().fold((), |(), elt| f(elt));\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CowRepr":["/// CowArray's representation.\n///\n/// *Don't use this type directlyuse the type alias\n/// [`CowArray`](type.CowArray.html) for the array type!*\npub enum CowRepr<'a, A> {\n    /// Borrowed data.\n    View(ViewRepr<&'a A>),\n    /// Owned data.\n    Owned(OwnedRepr<A>),\n}","Real(LocalPath(\"src/lib.rs\"))"],"CowRepr::<'a, A>::is_owned":["/// Returns `true` iff the data is the `Owned` variant.\npub fn is_owned(&self) -> bool{\n        match self {\n            CowRepr::View(_) => false,\n            CowRepr::Owned(_) => true,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CowRepr::<'a, A>::is_view":["/// Returns `true` iff the data is the `View` variant.\npub fn is_view(&self) -> bool{\n        match self {\n            CowRepr::View(_) => true,\n            CowRepr::Owned(_) => false,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"OwnedArcRepr":["/// ArcArray's representation.\n///\n/// *Dont use this type directlyuse the type alias\n/// [`ArcArray`](type.ArcArray.html) for the array type!*\npub struct OwnedArcRepr<A>(Arc<OwnedRepr<A>>);","Real(LocalPath(\"src/lib.rs\"))"],"RawViewRepr":["/// Array pointers representation.\n///\n/// *Dont use this type directlyuse the type aliases\n/// [`RawArrayView`](type.RawArrayView.html) /\n/// [`RawArrayViewMut`](type.RawArrayViewMut.html) for the array type!*\npub struct RawViewRepr<A> {\n    ptr: PhantomData<A>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"RawViewRepr::<A>::new":["#[inline(always)]\nfn new() -> Self{\n        RawViewRepr { ptr: PhantomData }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Shape":["/// A contiguous array shape of n dimensions.\n///\n/// Either c- or f- memory ordered (*c* a.k.a *row major* is the default).\npub struct Shape<D> {\n    dim: D,\n    is_c: bool,\n}","Real(LocalPath(\"src/lib.rs\"))"],"StrideShape":["/// An array shape of n dimensions in c-order, f-order or custom strides.\npub struct StrideShape<D> {\n    dim: D,\n    strides: D,\n    custom: bool,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ViewRepr":["/// Array views representation.\n///\n/// *Dont use this type directlyuse the type aliases\n/// [`ArrayView`](type.ArrayView.html)\n/// / [`ArrayViewMut`](type.ArrayViewMut.html) for the array type!*\npub struct ViewRepr<A> {\n    life: PhantomData<A>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ViewRepr::<A>::new":["#[inline(always)]\nfn new() -> Self{\n        ViewRepr { life: PhantomData }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"aliases::Ix0":["/// Create a zero-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix0() -> Ix0{\n    Dim::new([])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::Ix1":["/// Create a one-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix1(i0: Ix) -> Ix1{\n    Dim::new([i0])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::Ix2":["/// Create a two-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix2(i0: Ix, i1: Ix) -> Ix2{\n    Dim::new([i0, i1])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::Ix3":["/// Create a three-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix3(i0: Ix, i1: Ix, i2: Ix) -> Ix3{\n    Dim::new([i0, i1, i2])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::Ix4":["/// Create a four-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix4(i0: Ix, i1: Ix, i2: Ix, i3: Ix) -> Ix4{\n    Dim::new([i0, i1, i2, i3])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::Ix5":["/// Create a five-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix5(i0: Ix, i1: Ix, i2: Ix, i3: Ix, i4: Ix) -> Ix5{\n    Dim::new([i0, i1, i2, i3, i4])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::Ix6":["/// Create a six-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn Ix6(i0: Ix, i1: Ix, i2: Ix, i3: Ix, i4: Ix, i5: Ix) -> Ix6{\n    Dim::new([i0, i1, i2, i3, i4, i5])\n}","Real(LocalPath(\"src/aliases.rs\"))"],"aliases::IxDyn":["/// Create a dynamic-dimensional index\n#[allow(non_snake_case)]\n#[inline(always)]\npub fn IxDyn(ix: &[Ix]) -> IxDyn{\n    Dim(ix)\n}","Real(LocalPath(\"src/aliases.rs\"))"],"argument_traits::AssignElem":["/// A producer element that can be assigned to once\npub trait AssignElem<T> {\n    /// Assign the value `input` to the element that self represents.\n    fn assign_elem(self, input: T);\n}","Real(LocalPath(\"src/argument_traits.rs\"))"],"arrayformat::<impl std::fmt::Binary for ArrayBase<S, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::<impl std::fmt::Debug for ArrayBase<S, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)?;\n\n        // Add extra information for Debug\n        write!(\n            f,\n            \", shape={:?}, strides={:?}, layout={:?}\",\n            self.shape(),\n            self.strides(),\n            layout = self.view().layout()\n        )?;\n        match D::NDIM {\n            Some(ndim) => write!(f, \", const ndim={}\", ndim)?,\n            None => write!(f, \", dynamic ndim={}\", self.ndim())?,\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::<impl std::fmt::Display for ArrayBase<S, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::<impl std::fmt::LowerExp for ArrayBase<S, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::<impl std::fmt::LowerHex for ArrayBase<S, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::<impl std::fmt::UpperExp for ArrayBase<S, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let fmt_opt = FormatOptions::default_for_array(self.len(), f.alternate());\n        format_array(self, f, <_>::fmt, &fmt_opt)\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::FormatOptions":["struct FormatOptions {\n    axis_collapse_limit: usize,\n    axis_collapse_limit_next_last: usize,\n    axis_collapse_limit_last: usize,\n}","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::FormatOptions::collapse_limit":["/// Axis length collapse limit before ellipsizing, where `axis_rindex` is\n/// the index of the axis from the back.\npub(crate) fn collapse_limit(&self, axis_rindex: usize) -> usize{\n        match axis_rindex {\n            0 => self.axis_collapse_limit_last,\n            1 => self.axis_collapse_limit_next_last,\n            _ => self.axis_collapse_limit,\n        }\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::FormatOptions::default_for_array":["pub(crate) fn default_for_array(nelem: usize, no_limit: bool) -> Self{\n        let default = Self {\n            axis_collapse_limit: AXIS_LIMIT_STACKED,\n            axis_collapse_limit_next_last: AXIS_LIMIT_COL,\n            axis_collapse_limit_last: AXIS_LIMIT_ROW,\n        };\n        default.set_no_limit(no_limit || nelem < ARRAY_MANY_ELEMENT_LIMIT)\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::FormatOptions::set_no_limit":["fn set_no_limit(mut self, no_limit: bool) -> Self{\n        if no_limit {\n            self.axis_collapse_limit = std::usize::MAX;\n            self.axis_collapse_limit_next_last = std::usize::MAX;\n            self.axis_collapse_limit_last = std::usize::MAX;\n            self\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::format_array":["fn format_array<A, S, D, F>(\n    array: &ArrayBase<S, D>,\n    f: &mut fmt::Formatter<'_>,\n    format: F,\n    fmt_opt: &FormatOptions,\n) -> fmt::Result\nwhere\n    F: FnMut(&A, &mut fmt::Formatter<'_>) -> fmt::Result + Clone,\n    D: Dimension,\n    S: Data<Elem = A>,{\n    // Cast into a dynamically dimensioned view\n    // This is required to be able to use `index_axis` for the recursive case\n    format_array_inner(array.view().into_dyn(), f, format, fmt_opt, 0, array.ndim())\n}","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::format_array_inner":["fn format_array_inner<A, F>(\n    view: ArrayView<A, IxDyn>,\n    f: &mut fmt::Formatter<'_>,\n    mut format: F,\n    fmt_opt: &FormatOptions,\n    depth: usize,\n    full_ndim: usize,\n) -> fmt::Result\nwhere\n    F: FnMut(&A, &mut fmt::Formatter<'_>) -> fmt::Result + Clone,{\n    // If any of the axes has 0 length, we return the same empty array representation\n    // e.g. [[]] for 2-d arrays\n    if view.is_empty() {\n        write!(f, \"{}{}\", \"[\".repeat(view.ndim()), \"]\".repeat(view.ndim()))?;\n        return Ok(());\n    }\n    match view.shape() {\n        // If it's 0 dimensional, we just print out the scalar\n        &[] => format(&view[[]], f)?,\n        // We handle 1-D arrays as a special case\n        &[len] => {\n            let view = view.view().into_dimensionality::<Ix1>().unwrap();\n            f.write_str(\"[\")?;\n            format_with_overflow(\n                f,\n                len,\n                fmt_opt.collapse_limit(0),\n                \", \",\n                ELLIPSIS,\n                &mut |f, index| format(&view[index], f),\n            )?;\n            f.write_str(\"]\")?;\n        }\n        // For n-dimensional arrays, we proceed recursively\n        shape => {\n            let blank_lines = \"\\n\".repeat(shape.len() - 2);\n            let indent = \" \".repeat(depth + 1);\n            let separator = format!(\",\\n{}{}\", blank_lines, indent);\n\n            f.write_str(\"[\")?;\n            let limit = fmt_opt.collapse_limit(full_ndim - depth - 1);\n            format_with_overflow(f, shape[0], limit, &separator, ELLIPSIS, &mut |f, index| {\n                format_array_inner(\n                    view.index_axis(Axis(0), index),\n                    f,\n                    format.clone(),\n                    fmt_opt,\n                    depth + 1,\n                    full_ndim,\n                )\n            })?;\n            f.write_str(\"]\")?;\n        }\n    }\n    Ok(())\n}","Real(LocalPath(\"src/arrayformat.rs\"))"],"arrayformat::format_with_overflow":["/// Formats the contents of a list of items, using an ellipsis to indicate when\n/// the `length` of the list is greater than `limit`.\n///\n/// # Parameters\n///\n/// * `f`: The formatter.\n/// * `length`: The length of the list.\n/// * `limit`: The maximum number of items before overflow.\n/// * `separator`: Separator to write between items.\n/// * `ellipsis`: Ellipsis for indicating overflow.\n/// * `fmt_elem`: A function that formats an element in the list, given the\n///   formatter and the index of the item in the list.\nfn format_with_overflow(\n    f: &mut fmt::Formatter<'_>,\n    length: usize,\n    limit: usize,\n    separator: &str,\n    ellipsis: &str,\n    fmt_elem: &mut dyn FnMut(&mut fmt::Formatter, usize) -> fmt::Result,\n) -> fmt::Result{\n    if length == 0 {\n        // no-op\n    } else if length <= limit {\n        fmt_elem(f, 0)?;\n        for i in 1..length {\n            f.write_str(separator)?;\n            fmt_elem(f, i)?\n        }\n    } else {\n        let edge = limit / 2;\n        fmt_elem(f, 0)?;\n        for i in 1..edge {\n            f.write_str(separator)?;\n            fmt_elem(f, i)?;\n        }\n        f.write_str(separator)?;\n        f.write_str(ellipsis)?;\n        for i in length - edge..length {\n            f.write_str(separator)?;\n            fmt_elem(f, i)?\n        }\n    }\n    Ok(())\n}","Real(LocalPath(\"src/arrayformat.rs\"))"],"arraytraits::<impl std::cmp::PartialEq<ArrayBase<S2, D>> for ArrayBase<S, D>>::eq":["fn eq(&self, rhs: &ArrayBase<S2, D>) -> bool{\n        if self.shape() != rhs.shape() {\n            return false;\n        }\n        if let Some(self_s) = self.as_slice() {\n            if let Some(rhs_s) = rhs.as_slice() {\n                return numeric_util::unrolled_eq(self_s, rhs_s);\n            }\n        }\n        Zip::from(self)\n            .and(rhs)\n            .fold_while(true, |_, a, b| {\n                if a != b {\n                    FoldWhile::Done(false)\n                } else {\n                    FoldWhile::Continue(true)\n                }\n            })\n            .into_inner()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::convert::From<&'a ArrayBase<S, D>> for ArrayBase<ViewRepr<&'a A>, D>>::from":["/// Create a read-only array view of the array.\nfn from(array: &'a ArrayBase<S, D>) -> Self{\n        array.view()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::convert::From<&'a Slice> for ArrayBase<ViewRepr<&'a A>, dimension::dim::Dim<[usize; 1]>>>::from":["/// Create a one-dimensional read-only array view of the data in `slice`.\n///\n/// **Panics** if the slice length is greater than `isize::MAX`.\nfn from(slice: &'a Slice) -> Self{\n        let xs = slice.as_ref();\n        if mem::size_of::<A>() == 0 {\n            assert!(\n                xs.len() <= ::std::isize::MAX as usize,\n                \"Slice length must fit in `isize`.\",\n            );\n        }\n        unsafe { Self::from_shape_ptr(xs.len(), xs.as_ptr()) }\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::convert::From<&'a mut ArrayBase<S, D>> for ArrayBase<ViewRepr<&'a mut A>, D>>::from":["/// Create a read-write array view of the array.\nfn from(array: &'a mut ArrayBase<S, D>) -> Self{\n        array.view_mut()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::convert::From<&'a mut Slice> for ArrayBase<ViewRepr<&'a mut A>, dimension::dim::Dim<[usize; 1]>>>::from":["/// Create a one-dimensional read-write array view of the data in `slice`.\n///\n/// **Panics** if the slice length is greater than `isize::MAX`.\nfn from(slice: &'a mut Slice) -> Self{\n        let xs = slice.as_mut();\n        if mem::size_of::<A>() == 0 {\n            assert!(\n                xs.len() <= ::std::isize::MAX as usize,\n                \"Slice length must fit in `isize`.\",\n            );\n        }\n        unsafe { Self::from_shape_ptr(xs.len(), xs.as_mut_ptr()) }\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::convert::From<std::vec::Vec<A>> for ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from":["/// Create a one-dimensional array from a vector (no copying needed).\n///\n/// **Panics** if the length is greater than `isize::MAX`.\n///\n/// ```rust\n/// use ndarray::Array;\n///\n/// let array = Array::from(vec![1., 2., 3., 4.]);\n/// ```\nfn from(v: Vec<A>) -> Self{\n        if mem::size_of::<A>() == 0 {\n            assert!(\n                v.len() <= isize::MAX as usize,\n                \"Length must fit in `isize`.\",\n            );\n        }\n        unsafe { Self::from_shape_vec_unchecked(v.len() as Ix, v) }\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::default::Default for ArrayBase<S, D>>::default":["fn default() -> Self{\n        ArrayBase::default(D::default())\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::hash::Hash for ArrayBase<S, D>>::hash":["fn hash<H: hash::Hasher>(&self, state: &mut H){\n        self.shape().hash(state);\n        if let Some(self_s) = self.as_slice() {\n            hash::Hash::hash_slice(self_s, state);\n        } else {\n            for row in self.inner_rows() {\n                if let Some(row_s) = row.as_slice() {\n                    hash::Hash::hash_slice(row_s, state);\n                } else {\n                    for elt in row {\n                        elt.hash(state)\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::iter::FromIterator<A> for ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from_iter":["/// Create a one-dimensional array from an iterable.\n///\n/// **Panics** if the length is greater than `isize::MAX`.\n///\n/// ```rust\n/// use ndarray::{Array, arr1};\n/// use std::iter::FromIterator;\n///\n/// // Either use `from_iter` directly or use `Iterator::collect`.\n/// let array = Array::from_iter((0..5).map(|x| x * x));\n/// assert!(array == arr1(&[0, 1, 4, 9, 16]))\n/// ```\nfn from_iter<I>(iterable: I) -> ArrayBase<S, Ix1>\n    where\n        I: IntoIterator<Item = A>,{\n        Self::from(iterable.into_iter().collect::<Vec<A>>())\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::iter::IntoIterator for &'a ArrayBase<S, D>>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::iter::IntoIterator for &'a mut ArrayBase<S, D>>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::iter::IntoIterator for ArrayBase<ViewRepr<&'a A>, D>>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.into_iter_()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::iter::IntoIterator for ArrayBase<ViewRepr<&'a mut A>, D>>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.into_iter_()\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::ops::Index<I> for ArrayBase<S, D>>::index":["#[inline]\nfn index(&self, index: I) -> &S::Elem{\n        debug_bounds_check!(self, index);\n        unsafe {\n            &*self.ptr.as_ptr().offset(\n                index\n                    .index_checked(&self.dim, &self.strides)\n                    .unwrap_or_else(|| array_out_of_bounds()),\n            )\n        }\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::<impl std::ops::IndexMut<I> for ArrayBase<S, D>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: I) -> &mut S::Elem{\n        debug_bounds_check!(self, index);\n        unsafe {\n            &mut *self.as_mut_ptr().offset(\n                index\n                    .index_checked(&self.dim, &self.strides)\n                    .unwrap_or_else(|| array_out_of_bounds()),\n            )\n        }\n    }","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::AsArray":["/// Argument conversion into an array view\n///\n/// The trait is parameterized over `A`, the element type, and `D`, the\n/// dimensionality of the array. `D` defaults to one-dimensional.\n///\n/// Use `.into()` to do the conversion.\n///\n/// ```\n/// use ndarray::AsArray;\n///\n/// fn sum<'a, V: AsArray<'a, f64>>(data: V) -> f64 {\n///     let array_view = data.into();\n///     array_view.sum()\n/// }\n///\n/// assert_eq!(\n///     sum(&[1., 2., 3.]),\n///     6.\n/// );\n///\n/// ```\npub trait AsArray<'a, A: 'a, D = Ix1>: Into<ArrayView<'a, A, D>>\nwhere\n    D: Dimension,\n{\n}","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::array_out_of_bounds":["#[cold]\n#[inline(never)]\npub(crate) fn array_out_of_bounds() -> !{\n    panic!(\"ndarray: index out of bounds\");\n}","Real(LocalPath(\"src/arraytraits.rs\"))"],"arraytraits::debug_bounds_check":["#[inline(always)]\npub fn debug_bounds_check<S, D, I>(_a: &ArrayBase<S, D>, _index: &I)\nwhere\n    D: Dimension,\n    I: NdIndex<D>,\n    S: Data,{\n    debug_bounds_check!(_a, *_index);\n}","Real(LocalPath(\"src/arraytraits.rs\"))"],"data_repr::OwnedRepr":["/// Array's representation.\n///\n/// *Dont use this type directlyuse the type alias\n/// [`Array`](type.Array.html) for the array type!*\npub struct OwnedRepr<A> {\n    ptr: NonNull<A>,\n    len: usize,\n    capacity: usize,\n}","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::as_nonnull_mut":["pub(crate) fn as_nonnull_mut(&mut self) -> NonNull<A>{\n        self.ptr\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::as_ptr":["pub(crate) fn as_ptr(&self) -> *const A{\n        self.ptr.as_ptr()\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::as_slice":["pub(crate) fn as_slice(&self) -> &[A]{\n        unsafe {\n            slice::from_raw_parts(self.ptr.as_ptr(), self.len)\n        }\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::from":["pub(crate) fn from(v: Vec<A>) -> Self{\n        let mut v = ManuallyDrop::new(v);\n        let len = v.len();\n        let capacity = v.capacity();\n        let ptr = nonnull::nonnull_from_vec_data(&mut v);\n        Self {\n            ptr,\n            len,\n            capacity,\n        }\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::into_vec":["pub(crate) fn into_vec(self) -> Vec<A>{\n        ManuallyDrop::new(self).take_as_vec()\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::len":["pub(crate) fn len(&self) -> usize{ self.len }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_repr::OwnedRepr::<A>::take_as_vec":["fn take_as_vec(&mut self) -> Vec<A>{\n        let capacity = self.capacity;\n        let len = self.len;\n        self.len = 0;\n        self.capacity = 0;\n        unsafe {\n            Vec::from_raw_parts(self.ptr.as_ptr(), len, capacity)\n        }\n    }","Real(LocalPath(\"src/data_repr.rs\"))"],"data_traits::Data":["/// Array representation trait.\n///\n/// For an array with elements that can be accessed with safe code.\n///\n/// ***Internal trait, see `RawData`.***\npub unsafe trait Data: RawData {\n    /// Converts the array to a uniquely owned array, cloning elements if necessary.\n    #[doc(hidden)]\n    fn into_owned<D>(self_: ArrayBase<Self, D>) -> ArrayBase<OwnedRepr<Self::Elem>, D>\n    where\n        Self::Elem: Clone,\n        D: Dimension;\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::DataClone":["/// Array representation trait.\n///\n/// An array representation that can be cloned and allows elements to be\n/// accessed with safe code.\n///\n/// ***Internal trait, see `Data`.***\n#[deprecated(note = \"use `Data + RawDataClone` instead\", since = \"0.13.0\")]\npub trait DataClone: Data + RawDataClone {}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::DataMut":["/// Array representation trait.\n///\n/// For an array with writable elements that can be accessed with safe code.\n///\n/// ***Internal trait, see `Data`.***\npub unsafe trait DataMut: Data + RawDataMut {\n    /// Ensures that the array has unique access to its data.\n    #[doc(hidden)]\n    #[inline]\n    fn ensure_unique<D>(self_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,\n    {\n        Self::try_ensure_unique(self_)\n    }\n\n    /// Returns whether the array has unique access to its data.\n    #[doc(hidden)]\n    #[inline]\n    fn is_unique(&mut self) -> bool {\n        self.try_is_unique().unwrap()\n    }\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::DataMut::ensure_unique":["/// Ensures that the array has unique access to its data.\n#[doc(hidden)]\n#[inline]\nfn ensure_unique<D>(self_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension,{\n        Self::try_ensure_unique(self_)\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::DataMut::is_unique":["/// Returns whether the array has unique access to its data.\n#[doc(hidden)]\n#[inline]\nfn is_unique(&mut self) -> bool{\n        self.try_is_unique().unwrap()\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::DataOwned":["/// Array representation trait.\n///\n/// A representation that is a unique or shared owner of its data.\n///\n/// ***Internal trait, see `Data`.***\npub unsafe trait DataOwned: Data {\n    #[doc(hidden)]\n    fn new(elements: Vec<Self::Elem>) -> Self;\n\n    /// Converts the data representation to a shared (copy on write)\n    /// representation, without any copying.\n    #[doc(hidden)]\n    fn into_shared(self) -> OwnedRcRepr<Self::Elem>;\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::DataShared":["/// Array representation trait.\n///\n/// A representation that is a lightweight view.\n///\n/// ***Internal trait, see `Data`.***\npub unsafe trait DataShared: Clone + Data + RawDataClone {}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::RawData":["/// Array representation trait.\n///\n/// For an array that meets the invariants of the `ArrayBase` type. This trait\n/// does not imply any ownership or lifetime; pointers to elements in the array\n/// may not be safe to dereference.\n///\n/// ***Note:*** `RawData` is not an extension interface at this point.\n/// Traits in Rust can serve many different roles. This trait is public because\n/// it is used as a bound on public methods.\npub unsafe trait RawData: Sized {\n    /// The array element type.\n    type Elem;\n\n    #[doc(hidden)]\n    // This method is only used for debugging\n    fn _data_slice(&self) -> Option<&[Self::Elem]>;\n\n    private_decl! {}\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::RawDataClone":["/// Array representation trait.\n///\n/// An array representation that can be cloned.\n///\n/// ***Internal trait, see `RawData`.***\npub unsafe trait RawDataClone: RawData {\n    #[doc(hidden)]\n    /// Unsafe because, `ptr` must point inside the current storage.\n    unsafe fn clone_with_ptr(&self, ptr: NonNull<Self::Elem>) -> (Self, NonNull<Self::Elem>);\n\n    #[doc(hidden)]\n    unsafe fn clone_from_with_ptr(\n        &mut self,\n        other: &Self,\n        ptr: NonNull<Self::Elem>,\n    ) -> NonNull<Self::Elem> {\n        let (data, ptr) = other.clone_with_ptr(ptr);\n        *self = data;\n        ptr\n    }\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::RawDataClone::clone_from_with_ptr":["#[doc(hidden)]\nunsafe fn clone_from_with_ptr(\n        &mut self,\n        other: &Self,\n        ptr: NonNull<Self::Elem>,\n    ) -> NonNull<Self::Elem>{\n        let (data, ptr) = other.clone_with_ptr(ptr);\n        *self = data;\n        ptr\n    }","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::RawDataMut":["/// Array representation trait.\n///\n/// For an array with writable elements.\n///\n/// ***Internal trait, see `RawData`.***\npub unsafe trait RawDataMut: RawData {\n    /// If possible, ensures that the array has unique access to its data.\n    ///\n    /// If `Self` provides safe mutable access to array elements, then it\n    /// **must** panic or ensure that the data is unique.\n    #[doc(hidden)]\n    fn try_ensure_unique<D>(_: &mut ArrayBase<Self, D>)\n    where\n        Self: Sized,\n        D: Dimension;\n\n    /// If possible, returns whether the array has unique access to its data.\n    ///\n    /// If `Self` provides safe mutable access to array elements, then it\n    /// **must** return `Some(_)`.\n    #[doc(hidden)]\n    fn try_is_unique(&mut self) -> Option<bool>;\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"data_traits::RawDataSubst":["/// Array representation trait.\n///\n/// The RawDataSubst trait maps the element type of array storage, while\n/// keeping the same kind of storage.\n///\n/// For example, `RawDataSubst<B>` can map the type `OwnedRepr<A>` to `OwnedRepr<B>`.\npub trait RawDataSubst<A>: RawData {\n    /// The resulting array storage of the same kind but substituted element type\n    type Output: RawData<Elem = A>;\n}","Real(LocalPath(\"src/data_traits.rs\"))"],"dimension::DimensionExt":["/// Implementation-specific extensions to `Dimension`\npub trait DimensionExt {\n    // note: many extensions go in the main trait if they need to be special-\n    // cased per dimension\n    /// Get the dimension at `axis`.\n    ///\n    /// *Panics* if `axis` is out of bounds.\n    fn axis(&self, axis: Axis) -> Ix;\n\n    /// Set the dimension at `axis`.\n    ///\n    /// *Panics* if `axis` is out of bounds.\n    fn set_axis(&mut self, axis: Axis, value: Ix);\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::abs_index":["/// Compute the equivalent unsigned index given the axis length and signed index.\n#[inline]\npub fn abs_index(len: Ix, index: Ixs) -> Ix{\n    if index < 0 {\n        len - (-index as Ix)\n    } else {\n        index as Ix\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::arith_seq_intersect":["/// Returns `true` if two (finite length) arithmetic sequences intersect.\n///\n/// `min*` and `max*` are the (inclusive) bounds of the sequences, and they\n/// must be elements in the sequences. `step*` are the steps between\n/// consecutive elements (the sign is irrelevant).\n///\n/// **Note** `step1` and `step2` must be nonzero.\nfn arith_seq_intersect(\n    (min1, max1, step1): (isize, isize, isize),\n    (min2, max2, step2): (isize, isize, isize),\n) -> bool{\n    debug_assert!(max1 >= min1);\n    debug_assert!(max2 >= min2);\n    debug_assert_eq!((max1 - min1) % step1, 0);\n    debug_assert_eq!((max2 - min2) % step2, 0);\n\n    // Handle the easy case where we don't have to solve anything.\n    if min1 > max2 || min2 > max1 {\n        false\n    } else {\n        // The sign doesn't matter semantically, and it's mathematically convenient\n        // for `step1` and `step2` to be positive.\n        let step1 = step1.abs();\n        let step2 = step2.abs();\n        // Ignoring the min/max bounds, the sequences are\n        //   a(x) = min1 + step1 * x\n        //   b(y) = min2 + step2 * y\n        //\n        // For intersections a(x) = b(y), we have:\n        //   min1 + step1 * x = min2 + step2 * y\n        //    -step1 * x + step2 * y = min1 - min2\n        // which is a linear Diophantine equation.\n        if let Some((x0, xd)) = solve_linear_diophantine_eq(-step1, step2, min1 - min2) {\n            // Minimum of [min1, max1]  [min2, max2]\n            let min = ::std::cmp::max(min1, min2);\n            // Maximum of [min1, max1]  [min2, max2]\n            let max = ::std::cmp::min(max1, max2);\n            // The potential intersections are\n            //   a(x) = min1 + step1 * (x0 + xd * t)\n            // where `t` is any integer.\n            //\n            // There is an intersection in `[min, max]` if there exists an\n            // integer `t` such that\n            //   min  a(x)  max\n            //    min  min1 + step1 * (x0 + xd * t)  max\n            //    min  min1 + step1 * x0 + step1 * xd * t  max\n            //    min - min1 - step1 * x0  (step1 * xd) * t  max - min1 - step1 * x0\n            //\n            // Therefore, the least possible intersection `a(x)` that is  `min` has\n            //   t = (min - min1 - step1 * x0) / (step1 * xd)\n            // If this `a(x) is also  `max`, then there is an intersection in `[min, max]`.\n            //\n            // The greatest possible intersection `a(x)` that is  `max` has\n            //   t = (max - min1 - step1 * x0) / (step1 * xd)\n            // If this `a(x) is also  `min`, then there is an intersection in `[min, max]`.\n            min1 + step1 * (x0 - xd * div_floor(min - min1 - step1 * x0, -step1 * xd)) <= max\n                || min1 + step1 * (x0 + xd * div_floor(max - min1 - step1 * x0, step1 * xd)) >= min\n        } else {\n            false\n        }\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::axes::Axes":["/// An iterator over the length and stride of each axis of an array.\n///\n/// See [`.axes()`](../struct.ArrayBase.html#method.axes) for more information.\n///\n/// Iterator element type is `AxisDescription`.\n///\n/// # Examples\n///\n/// ```\n/// use ndarray::Array3;\n/// use ndarray::Axis;\n///\n/// let a = Array3::<f32>::zeros((3, 5, 4));\n///\n/// let largest_axis = a.axes()\n///                     .max_by_key(|ax| ax.len())\n///                     .unwrap().axis();\n/// assert_eq!(largest_axis, Axis(1));\n/// ```\npub struct Axes<'a, D> {\n    dim: &'a D,\n    strides: &'a D,\n    start: usize,\n    end: usize,\n}","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axes::AxisDescription":["/// Description of the axis, its length and its stride.\npub struct AxisDescription(pub Axis, pub Ix, pub Ixs);","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axes::AxisDescription::axis":["/// Return axis\n#[inline(always)]\npub fn axis(self) -> Axis{\n        self.0\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axes::AxisDescription::len":["/// Return length\n#[inline(always)]\npub fn len(self) -> Ix{\n        self.1\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axes::AxisDescription::stride":["/// Return stride\n#[inline(always)]\npub fn stride(self) -> Ixs{\n        self.2\n    }","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axes::IncOps":["trait IncOps: Copy {\n    fn post_inc(&mut self) -> Self;\n    fn post_dec(&mut self) -> Self;\n    fn pre_dec(&mut self) -> Self;\n}","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axes::axes_of":["/// Create a new Axes iterator\npub fn axes_of<'a, D>(d: &'a D, strides: &'a D) -> Axes<'a, D>\nwhere\n    D: Dimension,{\n    Axes {\n        dim: d,\n        strides,\n        start: 0,\n        end: d.ndim(),\n    }\n}","Real(LocalPath(\"src/dimension/axes.rs\"))"],"dimension::axis::Axis":["/// An axis index.\n///\n/// An axis one of an arrays dimensions; an *n*-dimensional array has *n* axes.\n/// Axis *0* is the arrays outermost axis and *n*-1 is the innermost.\n///\n/// All array axis arguments use this type to make the code easier to write\n/// correctly and easier to understand.\npub struct Axis(pub usize);","Real(LocalPath(\"src/dimension/axis.rs\"))"],"dimension::axis::Axis::index":["/// Return the index of the axis.\n#[inline(always)]\npub fn index(self) -> usize{\n        self.0\n    }","Real(LocalPath(\"src/dimension/axis.rs\"))"],"dimension::can_index_slice":["/// Checks whether the given data, dimension, and strides meet the invariants\n/// of the `ArrayBase` type (except for checking ownership of the data).\n///\n/// To meet the invariants,\n///\n/// 1. The ndim of `dim` and `strides` must be the same.\n///\n/// 2. The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// 3. For axes with length > 1, the stride must be nonnegative. This is\n///    necessary to make sure the pointer cannot move backwards outside the\n///    slice. For axes with length  1, the stride can be anything.\n///\n/// 4. If the array will be empty (any axes are zero-length), the difference\n///    between the least address and greatest address accessible by moving\n///    along all axes must be  `data.len()`. (It's fine in this case to move\n///    one byte past the end of the slice since the pointers will be offset but\n///    never dereferenced.)\n///\n///    If the array will not be empty, the difference between the least address\n///    and greatest address accessible by moving along all axes must be <\n///    `data.len()`. This and #3 ensure that all dereferenceable pointers point\n///    to elements within the slice.\n///\n/// 5. The strides must not allow any element to be referenced by two different\n///    indices.\n///\n/// Note that since slices cannot contain more than `isize::MAX` bytes,\n/// condition 4 is sufficient to guarantee that the absolute difference in\n/// units of `A` and in units of bytes between the least address and greatest\n/// address accessible by moving along all axes does not exceed `isize::MAX`.\npub fn can_index_slice<A, D: Dimension>(\n    data: &[A],\n    dim: &D,\n    strides: &D,\n) -> Result<(), ShapeError>{\n    // Check conditions 1 and 2 and calculate `max_offset`.\n    let max_offset = max_abs_offset_check_overflow::<A, _>(dim, strides)?;\n\n    // Check condition 4.\n    let is_empty = dim.slice().iter().any(|&d| d == 0);\n    if is_empty && max_offset > data.len() {\n        return Err(from_kind(ErrorKind::OutOfBounds));\n    }\n    if !is_empty && max_offset >= data.len() {\n        return Err(from_kind(ErrorKind::OutOfBounds));\n    }\n\n    // Check condition 3.\n    for (&d, &s) in izip!(dim.slice(), strides.slice()) {\n        let s = s as isize;\n        if d > 1 && s < 0 {\n            return Err(from_kind(ErrorKind::Unsupported));\n        }\n    }\n\n    // Check condition 5.\n    if !is_empty && dim_stride_overlap(dim, strides) {\n        return Err(from_kind(ErrorKind::Unsupported));\n    }\n\n    Ok(())\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::can_index_slice_not_custom":["/// Checks whether the given data and dimension meet the invariants of the\n/// `ArrayBase` type, assuming the strides are created using\n/// `dim.default_strides()` or `dim.fortran_strides()`.\n///\n/// To meet the invariants,\n///\n/// 1. The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// 2. The result of `dim.size()` (assuming no overflow) must be less than or\n///    equal to the length of the slice.\n///\n///    (Since `dim.default_strides()` and `dim.fortran_strides()` always return\n///    contiguous strides for non-empty arrays, this ensures that for non-empty\n///    arrays the difference between the least address and greatest address\n///    accessible by moving along all axes is < the length of the slice. Since\n///    `dim.default_strides()` and `dim.fortran_strides()` always return all\n///    zero strides for empty arrays, this ensures that for empty arrays the\n///    difference between the least address and greatest address accessible by\n///    moving along all axes is  the length of the slice.)\n///\n/// Note that since slices cannot contain more than `isize::MAX` bytes,\n/// conditions 1 and 2 are sufficient to guarantee that the offset in units of\n/// `A` and in units of bytes between the least address and greatest address\n/// accessible by moving along all axes does not exceed `isize::MAX`.\npub fn can_index_slice_not_custom<A, D: Dimension>(data: &[A], dim: &D) -> Result<(), ShapeError>{\n    // Condition 1.\n    let len = size_of_shape_checked(dim)?;\n    // Condition 2.\n    if len > data.len() {\n        return Err(from_kind(ErrorKind::OutOfBounds));\n    }\n    Ok(())\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 0]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 0]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 1]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 1]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 2]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 2]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 3]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 3]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 4]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 4]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 5]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 5]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 6]>>::is_zero":["fn is_zero(&self) -> bool{\n                self.slice().iter().all(|x| *x == 0)\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 6]>>::zero":["#[inline]\nfn zero() -> Self{\n                Dim::new(index!(array_zero [] $n))\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 0]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 1]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 2]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 3]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 4]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 5]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 6]>>::index":["#[inline(always)]\nfn index(&self, index: usize) -> &Self::Output{\n                &self.ix()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 0]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 1]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 2]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 3]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 4]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 5]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 6]>>::index_mut":["#[inline(always)]\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n                &mut self.ixm()[index]\n            }","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::Convert":["pub trait Convert {\n    type To;\n    fn convert(self) -> Self::To;\n}","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::conversion::IntoDimension":["/// Argument conversion a dimension.\npub trait IntoDimension {\n    type Dim: Dimension;\n    fn into_dimension(self) -> Self::Dim;\n}","Real(LocalPath(\"src/dimension/conversion.rs\"))"],"dimension::dim::Dim":["/// Create a new dimension value.\n#[allow(non_snake_case)]\npub fn Dim<T>(index: T) -> T::Dim\nwhere\n    T: IntoDimension,{\n    index.into_dimension()\n}","Real(LocalPath(\"src/dimension/dim.rs\"))"],"dimension::dim::Dim::<I>::ix":["#[inline(always)]\npub(crate) fn ix(&self) -> &I{\n        &self.index\n    }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"dimension::dim::Dim::<I>::ixm":["#[inline(always)]\npub(crate) fn ixm(&mut self) -> &mut I{\n        &mut self.index\n    }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"dimension::dim::Dim::<I>::new":["/// Private constructor and accessors for Dim\npub(crate) fn new(index: I) -> Dim<I>{\n        Dim { index }\n    }","Real(LocalPath(\"src/dimension/dim.rs\"))"],"dimension::dim_stride_overlap":["/// Check whether the given `dim` and `stride` lead to overlapping indices\n///\n/// There is overlap if, when iterating through the dimensions in order of\n/// increasing stride, the current stride is less than or equal to the maximum\n/// possible offset along the preceding axes. (Axes of length 1 are ignored.)\n///\n/// The current implementation assumes that strides of axes with length > 1 are\n/// nonnegative. Additionally, it does not check for overflow.\npub fn dim_stride_overlap<D: Dimension>(dim: &D, strides: &D) -> bool{\n    let order = strides._fastest_varying_stride_order();\n    let mut sum_prev_offsets = 0;\n    for &index in order.slice() {\n        let d = dim[index];\n        let s = strides[index] as isize;\n        match d {\n            0 => return false,\n            1 => {}\n            _ => {\n                if s <= sum_prev_offsets {\n                    return true;\n                }\n                sum_prev_offsets += (d - 1) as isize * s;\n            }\n        }\n    }\n    false\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::dimension_trait::<impl std::ops::Index<usize> for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::index":["fn index(&self, index: usize) -> &Self::Output{\n        &self.ix()[index]\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::index_mut":["fn index_mut(&mut self, index: usize) -> &mut Self::Output{\n        &mut self.ixm()[index]\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension":["/// Array shape and index trait.\n///\n/// This trait defines a number of methods and operations that can be used on\n/// dimensions and indices.\n///\n/// **Note:** *This trait can not be implemented outside the crate*\npub trait Dimension:\n    Clone\n    + Eq\n    + Debug\n    + Send\n    + Sync\n    + Default\n    + IndexMut<usize, Output = usize>\n    + Add<Self, Output = Self>\n    + AddAssign\n    + for<'x> AddAssign<&'x Self>\n    + Sub<Self, Output = Self>\n    + SubAssign\n    + for<'x> SubAssign<&'x Self>\n    + Mul<usize, Output = Self>\n    + Mul<Self, Output = Self>\n    + MulAssign\n    + for<'x> MulAssign<&'x Self>\n    + MulAssign<usize>\n{\n    /// For fixed-size dimension representations (e.g. `Ix2`), this should be\n    /// `Some(ndim)`, and for variable-size dimension representations (e.g.\n    /// `IxDyn`), this should be `None`.\n    const NDIM: Option<usize>;\n    /// `SliceArg` is the type which is used to specify slicing for this\n    /// dimension.\n    ///\n    /// For the fixed size dimensions it is a fixed size array of the correct\n    /// size, which you pass by reference. For the dynamic dimension it is\n    /// a slice.\n    ///\n    /// - For `Ix1`: `[SliceOrIndex; 1]`\n    /// - For `Ix2`: `[SliceOrIndex; 2]`\n    /// - and so on..\n    /// - For `IxDyn`: `[SliceOrIndex]`\n    ///\n    /// The easiest way to create a `&SliceInfo<SliceArg, Do>` is using the\n    /// [`s![]`](macro.s!.html) macro.\n    type SliceArg: ?Sized + AsRef<[SliceOrIndex]>;\n    /// Pattern matching friendly form of the dimension value.\n    ///\n    /// - For `Ix1`: `usize`,\n    /// - For `Ix2`: `(usize, usize)`\n    /// - and so on..\n    /// - For `IxDyn`: `IxDyn`\n    type Pattern: IntoDimension<Dim = Self> + Clone + Debug + PartialEq + Eq + Default;\n    /// Next smaller dimension (if applicable)\n    type Smaller: Dimension;\n    /// Next larger dimension\n    type Larger: Dimension + RemoveAxis;\n\n    /// Returns the number of dimensions (number of axes).\n    fn ndim(&self) -> usize;\n\n    /// Convert the dimension into a pattern matching friendly value.\n    fn into_pattern(self) -> Self::Pattern;\n\n    /// Compute the size of the dimension (number of elements)\n    fn size(&self) -> usize {\n        self.slice().iter().fold(1, |s, &a| s * a as usize)\n    }\n\n    /// Compute the size while checking for overflow.\n    fn size_checked(&self) -> Option<usize> {\n        self.slice()\n            .iter()\n            .fold(Some(1), |s, &a| s.and_then(|s_| s_.checked_mul(a)))\n    }\n\n    #[doc(hidden)]\n    fn slice(&self) -> &[Ix];\n\n    #[doc(hidden)]\n    fn slice_mut(&mut self) -> &mut [Ix];\n\n    /// Borrow as a read-only array view.\n    fn as_array_view(&self) -> ArrayView1<'_, Ix> {\n        ArrayView1::from(self.slice())\n    }\n\n    /// Borrow as a read-write array view.\n    fn as_array_view_mut(&mut self) -> ArrayViewMut1<'_, Ix> {\n        ArrayViewMut1::from(self.slice_mut())\n    }\n\n    #[doc(hidden)]\n    fn equal(&self, rhs: &Self) -> bool {\n        self.slice() == rhs.slice()\n    }\n\n    /// Returns the strides for a standard layout array with the given shape.\n    ///\n    /// If the array is non-empty, the strides result in contiguous layout; if\n    /// the array is empty, the strides are all zeros.\n    #[doc(hidden)]\n    fn default_strides(&self) -> Self {\n        // Compute default array strides\n        // Shape (a, b, c) => Give strides (b * c, c, 1)\n        let mut strides = Self::zeros(self.ndim());\n        // For empty arrays, use all zero strides.\n        if self.slice().iter().all(|&d| d != 0) {\n            let mut it = strides.slice_mut().iter_mut().rev();\n            // Set first element to 1\n            if let Some(rs) = it.next() {\n                *rs = 1;\n            }\n            let mut cum_prod = 1;\n            for (rs, dim) in it.zip(self.slice().iter().rev()) {\n                cum_prod *= *dim;\n                *rs = cum_prod;\n            }\n        }\n        strides\n    }\n\n    /// Returns the strides for a Fortran layout array with the given shape.\n    ///\n    /// If the array is non-empty, the strides result in contiguous layout; if\n    /// the array is empty, the strides are all zeros.\n    #[doc(hidden)]\n    fn fortran_strides(&self) -> Self {\n        // Compute fortran array strides\n        // Shape (a, b, c) => Give strides (1, a, a * b)\n        let mut strides = Self::zeros(self.ndim());\n        // For empty arrays, use all zero strides.\n        if self.slice().iter().all(|&d| d != 0) {\n            let mut it = strides.slice_mut().iter_mut();\n            // Set first element to 1\n            if let Some(rs) = it.next() {\n                *rs = 1;\n            }\n            let mut cum_prod = 1;\n            for (rs, dim) in it.zip(self.slice()) {\n                cum_prod *= *dim;\n                *rs = cum_prod;\n            }\n        }\n        strides\n    }\n\n    /// Creates a dimension of all zeros with the specified ndim.\n    ///\n    /// This method is useful for generalizing over fixed-size and\n    /// variable-size dimension representations.\n    ///\n    /// **Panics** if `Self` has a fixed size that is not `ndim`.\n    fn zeros(ndim: usize) -> Self;\n\n    #[doc(hidden)]\n    #[inline]\n    fn first_index(&self) -> Option<Self> {\n        for ax in self.slice().iter() {\n            if *ax == 0 {\n                return None;\n            }\n        }\n        Some(Self::zeros(self.ndim()))\n    }\n\n    #[doc(hidden)]\n    /// Iteration -- Use self as size, and return next index after `index`\n    /// or None if there are no more.\n    // FIXME: use &Self for index or even &mut?\n    #[inline]\n    fn next_for(&self, index: Self) -> Option<Self> {\n        let mut index = index;\n        let mut done = false;\n        for (&dim, ix) in zip(self.slice(), index.slice_mut()).rev() {\n            *ix += 1;\n            if *ix == dim {\n                *ix = 0;\n            } else {\n                done = true;\n                break;\n            }\n        }\n        if done {\n            Some(index)\n        } else {\n            None\n        }\n    }\n\n    #[doc(hidden)]\n    /// Iteration -- Use self as size, and create the next index after `index`\n    /// Return false if iteration is done\n    ///\n    /// Next in f-order\n    #[inline]\n    fn next_for_f(&self, index: &mut Self) -> bool {\n        let mut end_iteration = true;\n        for (&dim, ix) in zip(self.slice(), index.slice_mut()) {\n            *ix += 1;\n            if *ix == dim {\n                *ix = 0;\n            } else {\n                end_iteration = false;\n                break;\n            }\n        }\n        !end_iteration\n    }\n\n    /// Returns `true` iff `strides1` and `strides2` are equivalent for the\n    /// shape `self`.\n    ///\n    /// The strides are equivalent if, for each axis with length > 1, the\n    /// strides are equal.\n    ///\n    /// Note: Returns `false` if any of the ndims don't match.\n    #[doc(hidden)]\n    fn strides_equivalent<D>(&self, strides1: &Self, strides2: &D) -> bool\n    where\n        D: Dimension,\n    {\n        let shape_ndim = self.ndim();\n        shape_ndim == strides1.ndim()\n            && shape_ndim == strides2.ndim()\n            && izip!(self.slice(), strides1.slice(), strides2.slice())\n                .all(|(&d, &s1, &s2)| d <= 1 || s1 as isize == s2 as isize)\n    }\n\n    #[doc(hidden)]\n    /// Return stride offset for index.\n    fn stride_offset(index: &Self, strides: &Self) -> isize {\n        let mut offset = 0;\n        for (&i, &s) in izip!(index.slice(), strides.slice()) {\n            offset += stride_offset(i, s);\n        }\n        offset\n    }\n\n    #[doc(hidden)]\n    /// Return stride offset for this dimension and index.\n    fn stride_offset_checked(&self, strides: &Self, index: &Self) -> Option<isize> {\n        stride_offset_checked(self.slice(), strides.slice(), index.slice())\n    }\n\n    #[doc(hidden)]\n    fn last_elem(&self) -> usize {\n        if self.ndim() == 0 {\n            0\n        } else {\n            self.slice()[self.ndim() - 1]\n        }\n    }\n\n    #[doc(hidden)]\n    fn set_last_elem(&mut self, i: usize) {\n        let nd = self.ndim();\n        self.slice_mut()[nd - 1] = i;\n    }\n\n    #[doc(hidden)]\n    fn is_contiguous(dim: &Self, strides: &Self) -> bool {\n        let defaults = dim.default_strides();\n        if strides.equal(&defaults) {\n            return true;\n        }\n        if dim.ndim() == 1 {\n            return false;\n        }\n        let order = strides._fastest_varying_stride_order();\n        let strides = strides.slice();\n\n        // FIXME: Negative strides\n        let dim_slice = dim.slice();\n        let mut cstride = 1;\n        for &i in order.slice() {\n            // a dimension of length 1 can have unequal strides\n            if dim_slice[i] != 1 && strides[i] != cstride {\n                return false;\n            }\n            cstride *= dim_slice[i];\n        }\n        true\n    }\n\n    /// Return the axis ordering corresponding to the fastest variation\n    /// (in ascending order).\n    ///\n    /// Assumes that no stride value appears twice. This cannot yield the correct\n    /// result the strides are not positive.\n    #[doc(hidden)]\n    fn _fastest_varying_stride_order(&self) -> Self {\n        let mut indices = self.clone();\n        for (i, elt) in enumerate(indices.slice_mut()) {\n            *elt = i;\n        }\n        let strides = self.slice();\n        indices.slice_mut().sort_by_key(|&i| strides[i]);\n        indices\n    }\n\n    /// Compute the minimum stride axis (absolute value), under the constraint\n    /// that the length of the axis is > 1;\n    #[doc(hidden)]\n    fn min_stride_axis(&self, strides: &Self) -> Axis {\n        let n = match self.ndim() {\n            0 => panic!(\"min_stride_axis: Array must have ndim > 0\"),\n            1 => return Axis(0),\n            n => n,\n        };\n        axes_of(self, strides)\n            .rev()\n            .min_by_key(|ax| ax.stride().abs())\n            .map_or(Axis(n - 1), |ax| ax.axis())\n    }\n\n    /// Compute the maximum stride axis (absolute value), under the constraint\n    /// that the length of the axis is > 1;\n    #[doc(hidden)]\n    fn max_stride_axis(&self, strides: &Self) -> Axis {\n        match self.ndim() {\n            0 => panic!(\"max_stride_axis: Array must have ndim > 0\"),\n            1 => return Axis(0),\n            _ => {}\n        }\n        axes_of(self, strides)\n            .filter(|ax| ax.len() > 1)\n            .max_by_key(|ax| ax.stride().abs())\n            .map_or(Axis(0), |ax| ax.axis())\n    }\n\n    /// Convert the dimensional into a dynamic dimensional (IxDyn).\n    fn into_dyn(self) -> IxDyn {\n        IxDyn(self.slice())\n    }\n\n    #[doc(hidden)]\n    fn from_dimension<D2: Dimension>(d: &D2) -> Option<Self> {\n        let mut s = Self::default();\n        if s.ndim() == d.ndim() {\n            for i in 0..d.ndim() {\n                s[i] = d[i];\n            }\n            Some(s)\n        } else {\n            None\n        }\n    }\n\n    #[doc(hidden)]\n    fn insert_axis(&self, axis: Axis) -> Self::Larger;\n\n    #[doc(hidden)]\n    fn try_remove_axis(&self, axis: Axis) -> Self::Smaller;\n\n    private_decl! {}\n}","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::_fastest_varying_stride_order":["/// Return the axis ordering corresponding to the fastest variation\n/// (in ascending order).\n///\n/// Assumes that no stride value appears twice. This cannot yield the correct\n/// result the strides are not positive.\n#[doc(hidden)]\nfn _fastest_varying_stride_order(&self) -> Self{\n        let mut indices = self.clone();\n        for (i, elt) in enumerate(indices.slice_mut()) {\n            *elt = i;\n        }\n        let strides = self.slice();\n        indices.slice_mut().sort_by_key(|&i| strides[i]);\n        indices\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::as_array_view":["/// Borrow as a read-only array view.\nfn as_array_view(&self) -> ArrayView1<'_, Ix>{\n        ArrayView1::from(self.slice())\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::as_array_view_mut":["/// Borrow as a read-write array view.\nfn as_array_view_mut(&mut self) -> ArrayViewMut1<'_, Ix>{\n        ArrayViewMut1::from(self.slice_mut())\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::default_strides":["/// Returns the strides for a standard layout array with the given shape.\n///\n/// If the array is non-empty, the strides result in contiguous layout; if\n/// the array is empty, the strides are all zeros.\n#[doc(hidden)]\nfn default_strides(&self) -> Self{\n        // Compute default array strides\n        // Shape (a, b, c) => Give strides (b * c, c, 1)\n        let mut strides = Self::zeros(self.ndim());\n        // For empty arrays, use all zero strides.\n        if self.slice().iter().all(|&d| d != 0) {\n            let mut it = strides.slice_mut().iter_mut().rev();\n            // Set first element to 1\n            if let Some(rs) = it.next() {\n                *rs = 1;\n            }\n            let mut cum_prod = 1;\n            for (rs, dim) in it.zip(self.slice().iter().rev()) {\n                cum_prod *= *dim;\n                *rs = cum_prod;\n            }\n        }\n        strides\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::equal":["#[doc(hidden)]\nfn equal(&self, rhs: &Self) -> bool{\n        self.slice() == rhs.slice()\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::first_index":["#[doc(hidden)]\n#[inline]\nfn first_index(&self) -> Option<Self>{\n        for ax in self.slice().iter() {\n            if *ax == 0 {\n                return None;\n            }\n        }\n        Some(Self::zeros(self.ndim()))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::fortran_strides":["/// Returns the strides for a Fortran layout array with the given shape.\n///\n/// If the array is non-empty, the strides result in contiguous layout; if\n/// the array is empty, the strides are all zeros.\n#[doc(hidden)]\nfn fortran_strides(&self) -> Self{\n        // Compute fortran array strides\n        // Shape (a, b, c) => Give strides (1, a, a * b)\n        let mut strides = Self::zeros(self.ndim());\n        // For empty arrays, use all zero strides.\n        if self.slice().iter().all(|&d| d != 0) {\n            let mut it = strides.slice_mut().iter_mut();\n            // Set first element to 1\n            if let Some(rs) = it.next() {\n                *rs = 1;\n            }\n            let mut cum_prod = 1;\n            for (rs, dim) in it.zip(self.slice()) {\n                cum_prod *= *dim;\n                *rs = cum_prod;\n            }\n        }\n        strides\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::from_dimension":["#[doc(hidden)]\nfn from_dimension<D2: Dimension>(d: &D2) -> Option<Self>{\n        let mut s = Self::default();\n        if s.ndim() == d.ndim() {\n            for i in 0..d.ndim() {\n                s[i] = d[i];\n            }\n            Some(s)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::into_dyn":["/// Convert the dimensional into a dynamic dimensional (IxDyn).\nfn into_dyn(self) -> IxDyn{\n        IxDyn(self.slice())\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::is_contiguous":["#[doc(hidden)]\nfn is_contiguous(dim: &Self, strides: &Self) -> bool{\n        let defaults = dim.default_strides();\n        if strides.equal(&defaults) {\n            return true;\n        }\n        if dim.ndim() == 1 {\n            return false;\n        }\n        let order = strides._fastest_varying_stride_order();\n        let strides = strides.slice();\n\n        // FIXME: Negative strides\n        let dim_slice = dim.slice();\n        let mut cstride = 1;\n        for &i in order.slice() {\n            // a dimension of length 1 can have unequal strides\n            if dim_slice[i] != 1 && strides[i] != cstride {\n                return false;\n            }\n            cstride *= dim_slice[i];\n        }\n        true\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::last_elem":["#[doc(hidden)]\nfn last_elem(&self) -> usize{\n        if self.ndim() == 0 {\n            0\n        } else {\n            self.slice()[self.ndim() - 1]\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::max_stride_axis":["/// Compute the maximum stride axis (absolute value), under the constraint\n/// that the length of the axis is > 1;\n#[doc(hidden)]\nfn max_stride_axis(&self, strides: &Self) -> Axis{\n        match self.ndim() {\n            0 => panic!(\"max_stride_axis: Array must have ndim > 0\"),\n            1 => return Axis(0),\n            _ => {}\n        }\n        axes_of(self, strides)\n            .filter(|ax| ax.len() > 1)\n            .max_by_key(|ax| ax.stride().abs())\n            .map_or(Axis(0), |ax| ax.axis())\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::min_stride_axis":["/// Compute the minimum stride axis (absolute value), under the constraint\n/// that the length of the axis is > 1;\n#[doc(hidden)]\nfn min_stride_axis(&self, strides: &Self) -> Axis{\n        let n = match self.ndim() {\n            0 => panic!(\"min_stride_axis: Array must have ndim > 0\"),\n            1 => return Axis(0),\n            n => n,\n        };\n        axes_of(self, strides)\n            .rev()\n            .min_by_key(|ax| ax.stride().abs())\n            .map_or(Axis(n - 1), |ax| ax.axis())\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::next_for":["#[doc(hidden)]\n/// Iteration -- Use self as size, and return next index after `index`\n/// or None if there are no more.\n#[inline]\nfn next_for(&self, index: Self) -> Option<Self>{\n        let mut index = index;\n        let mut done = false;\n        for (&dim, ix) in zip(self.slice(), index.slice_mut()).rev() {\n            *ix += 1;\n            if *ix == dim {\n                *ix = 0;\n            } else {\n                done = true;\n                break;\n            }\n        }\n        if done {\n            Some(index)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::next_for_f":["#[doc(hidden)]\n/// Iteration -- Use self as size, and create the next index after `index`\n/// Return false if iteration is done\n///\n/// Next in f-order\n#[inline]\nfn next_for_f(&self, index: &mut Self) -> bool{\n        let mut end_iteration = true;\n        for (&dim, ix) in zip(self.slice(), index.slice_mut()) {\n            *ix += 1;\n            if *ix == dim {\n                *ix = 0;\n            } else {\n                end_iteration = false;\n                break;\n            }\n        }\n        !end_iteration\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::set_last_elem":["#[doc(hidden)]\nfn set_last_elem(&mut self, i: usize){\n        let nd = self.ndim();\n        self.slice_mut()[nd - 1] = i;\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::size":["/// Compute the size of the dimension (number of elements)\nfn size(&self) -> usize{\n        self.slice().iter().fold(1, |s, &a| s * a as usize)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::size_checked":["/// Compute the size while checking for overflow.\nfn size_checked(&self) -> Option<usize>{\n        self.slice()\n            .iter()\n            .fold(Some(1), |s, &a| s.and_then(|s_| s_.checked_mul(a)))\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::stride_offset":["#[doc(hidden)]\n/// Return stride offset for index.\nfn stride_offset(index: &Self, strides: &Self) -> isize{\n        let mut offset = 0;\n        for (&i, &s) in izip!(index.slice(), strides.slice()) {\n            offset += stride_offset(i, s);\n        }\n        offset\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::stride_offset_checked":["#[doc(hidden)]\n/// Return stride offset for this dimension and index.\nfn stride_offset_checked(&self, strides: &Self, index: &Self) -> Option<isize>{\n        stride_offset_checked(self.slice(), strides.slice(), index.slice())\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::dimension_trait::Dimension::strides_equivalent":["/// Returns `true` iff `strides1` and `strides2` are equivalent for the\n/// shape `self`.\n///\n/// The strides are equivalent if, for each axis with length > 1, the\n/// strides are equal.\n///\n/// Note: Returns `false` if any of the ndims don't match.\n#[doc(hidden)]\nfn strides_equivalent<D>(&self, strides1: &Self, strides2: &D) -> bool\n    where\n        D: Dimension,{\n        let shape_ndim = self.ndim();\n        shape_ndim == strides1.ndim()\n            && shape_ndim == strides2.ndim()\n            && izip!(self.slice(), strides1.slice(), strides2.slice())\n                .all(|(&d, &s1, &s2)| d <= 1 || s1 as isize == s2 as isize)\n    }","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))"],"dimension::do_collapse_axis":["/// Collapse axis `axis` and shift so that only subarray `index` is\n/// available.\n///\n/// **Panics** if `index` is larger than the size of the axis\npub fn do_collapse_axis<D: Dimension>(\n    dims: &mut D,\n    strides: &D,\n    axis: usize,\n    index: usize,\n) -> isize{\n    let dim = dims.slice()[axis];\n    let stride = strides.slice()[axis];\n    ndassert!(\n        index < dim,\n        \"collapse_axis: Index {} must be less than axis length {} for \\\n         array with shape {:?}\",\n        index,\n        dim,\n        *dims\n    );\n    dims.slice_mut()[axis] = 1;\n    stride_offset(index, stride)\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::do_slice":["/// Modify dimension, stride and return data pointer offset\n///\n/// **Panics** if stride is 0 or if any index is out of bounds.\npub fn do_slice(dim: &mut usize, stride: &mut usize, slice: Slice) -> isize{\n    let (start, end, step) = to_abs_slice(*dim, slice);\n\n    let m = end - start;\n    let s = (*stride) as isize;\n\n    // Compute data pointer offset.\n    let offset = if m == 0 {\n        // In this case, the resulting array is empty, so we *can* avoid performing a nonzero\n        // offset.\n        //\n        // In two special cases (which are the true reason for this `m == 0` check), we *must* avoid\n        // the nonzero offset corresponding to the general case.\n        //\n        // * When `end == 0 && step < 0`. (These conditions imply that `m == 0` since `to_abs_slice`\n        //   ensures that `0 <= start <= end`.) We cannot execute `stride_offset(end - 1, *stride)`\n        //   because the `end - 1` would underflow.\n        //\n        // * When `start == *dim && step > 0`. (These conditions imply that `m == 0` since\n        //   `to_abs_slice` ensures that `start <= end <= *dim`.) We cannot use the offset returned\n        //   by `stride_offset(start, *stride)` because that would be past the end of the axis.\n        0\n    } else if step < 0 {\n        // When the step is negative, the new first element is `end - 1`, not `start`, since the\n        // direction is reversed.\n        stride_offset(end - 1, *stride)\n    } else {\n        stride_offset(start, *stride)\n    };\n\n    // Update dimension.\n    let abs_step = step.abs() as usize;\n    *dim = if abs_step == 1 {\n        m\n    } else {\n        let d = m / abs_step;\n        let r = m % abs_step;\n        d + if r > 0 { 1 } else { 0 }\n    };\n\n    // Update stride. The additional check is necessary to avoid possible\n    // overflow in the multiplication.\n    *stride = if *dim <= 1 { 0 } else { (s * step) as usize };\n\n    offset\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::dynindeximpl::<impl dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::zeros":["/// Create a new dimension value with `n` axes, all zeros\n#[inline]\npub fn zeros(n: usize) -> IxDyn{\n        const ZEROS: &[usize] = &[0; 4];\n        if n <= ZEROS.len() {\n            Dim(&ZEROS[..n])\n        } else {\n            Dim(vec![0; n])\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::<impl dimension::remove_axis::RemoveAxis for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::remove_axis":["fn remove_axis(&self, axis: Axis) -> Self{\n        debug_assert!(axis.index() < self.ndim());\n        Dim::new(self.ix().remove(axis.index()))\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynImpl":["/// Dynamic dimension or index type.\n///\n/// Use `IxDyn` directly. This type implements a dynamic number of\n/// dimensions or indices. Short dimensions are stored inline and don't need\n/// any dynamic memory allocation.\npub struct IxDynImpl(IxDynRepr<Ix>);","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynImpl::insert":["pub(crate) fn insert(&self, i: usize) -> Self{\n        let len = self.len();\n        debug_assert!(i <= len);\n        IxDynImpl(if len < CAP {\n            let mut out = [1; CAP];\n            out[0..i].copy_from_slice(&self[0..i]);\n            out[i + 1..=len].copy_from_slice(&self[i..len]);\n            IxDynRepr::Inline((len + 1) as u32, out)\n        } else {\n            let mut out = Vec::with_capacity(len + 1);\n            out.extend_from_slice(&self[0..i]);\n            out.push(1);\n            out.extend_from_slice(&self[i..len]);\n            IxDynRepr::from_vec(out)\n        })\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynImpl::remove":["fn remove(&self, i: usize) -> Self{\n        IxDynImpl(match self.0 {\n            IxDynRepr::Inline(0, _) => IxDynRepr::Inline(0, [0; CAP]),\n            IxDynRepr::Inline(1, _) => IxDynRepr::Inline(0, [0; CAP]),\n            IxDynRepr::Inline(2, ref arr) => {\n                let mut out = [0; CAP];\n                out[0] = arr[1 - i];\n                IxDynRepr::Inline(1, out)\n            }\n            ref ixdyn => {\n                let len = ixdyn.len();\n                let mut result = IxDynRepr::copy_from(&ixdyn[..len - 1]);\n                for j in i..len - 1 {\n                    result[j] = ixdyn[j + 1]\n                }\n                result\n            }\n        })\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynRepr":["/// T is usize or isize\nenum IxDynRepr<T> {\n    Inline(u32, [T; CAP]),\n    Alloc(Box<[T]>),\n}","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynRepr::<T>::copy_from":["pub fn copy_from(x: &[T]) -> Self{\n        if x.len() <= CAP {\n            let mut arr = [T::zero(); CAP];\n            arr[..x.len()].copy_from_slice(&x[..]);\n            IxDynRepr::Inline(x.len() as _, arr)\n        } else {\n            Self::from(x)\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynRepr::<T>::from":["fn from(x: &[T]) -> Self{\n        Self::from_vec(x.to_vec())\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynRepr::<T>::from_vec":["fn from_vec(v: Vec<T>) -> Self{\n        IxDynRepr::Alloc(v.into_boxed_slice())\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::dynindeximpl::IxDynRepr::<T>::from_vec_auto":["fn from_vec_auto(v: Vec<T>) -> Self{\n        if v.len() <= CAP {\n            Self::copy_from(&v)\n        } else {\n            Self::from_vec(v)\n        }\n    }","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))"],"dimension::extended_gcd":["/// Solves `a * x + b * y = gcd(a, b)` for `x`, `y`, and `gcd(a, b)`.\n///\n/// Returns `(g, (x, y))`, where `g` is `gcd(a, b)`, and `g` is always\n/// nonnegative.\n///\n/// See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\nfn extended_gcd(a: isize, b: isize) -> (isize, (isize, isize)){\n    if a == 0 {\n        (b.abs(), (0, b.signum()))\n    } else if b == 0 {\n        (a.abs(), (a.signum(), 0))\n    } else {\n        let mut r = (a, b);\n        let mut s = (1, 0);\n        let mut t = (0, 1);\n        while r.1 != 0 {\n            let q = r.0 / r.1;\n            r = (r.1, r.0 - q * r.1);\n            s = (s.1, s.0 - q * s.1);\n            t = (t.1, t.0 - q * t.1);\n        }\n        if r.0 > 0 {\n            (r.0, (s.0, t.0))\n        } else {\n            (-r.0, (-s.0, -t.0))\n        }\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::max_abs_offset_check_overflow":["/// Returns the absolute difference in units of `A` between least and greatest\n/// address accessible by moving along all axes.\n///\n/// Returns `Ok` only if\n///\n/// 1. The ndim of `dim` and `strides` is the same.\n///\n/// 2. The absolute difference in units of `A` and in units of bytes between\n///    the least address and greatest address accessible by moving along all axes\n///    does not exceed `isize::MAX`.\n///\n/// 3. The product of non-zero axis lengths does not exceed `isize::MAX`. (This\n///    also implies that the length of any individual axis does not exceed\n///    `isize::MAX`.)\npub fn max_abs_offset_check_overflow<A, D>(dim: &D, strides: &D) -> Result<usize, ShapeError>\nwhere\n    D: Dimension,{\n    // Condition 1.\n    if dim.ndim() != strides.ndim() {\n        return Err(from_kind(ErrorKind::IncompatibleLayout));\n    }\n\n    // Condition 3.\n    let _ = size_of_shape_checked(dim)?;\n\n    // Determine absolute difference in units of `A` between least and greatest\n    // address accessible by moving along all axes.\n    let max_offset: usize = izip!(dim.slice(), strides.slice())\n        .try_fold(0usize, |acc, (&d, &s)| {\n            let s = s as isize;\n            // Calculate maximum possible absolute movement along this axis.\n            let off = d.saturating_sub(1).checked_mul(s.abs() as usize)?;\n            acc.checked_add(off)\n        })\n        .ok_or_else(|| from_kind(ErrorKind::Overflow))?;\n    // Condition 2a.\n    if max_offset > isize::MAX as usize {\n        return Err(from_kind(ErrorKind::Overflow));\n    }\n\n    // Determine absolute difference in units of bytes between least and\n    // greatest address accessible by moving along all axes\n    let max_offset_bytes = max_offset\n        .checked_mul(mem::size_of::<A>())\n        .ok_or_else(|| from_kind(ErrorKind::Overflow))?;\n    // Condition 2b.\n    if max_offset_bytes > isize::MAX as usize {\n        return Err(from_kind(ErrorKind::Overflow));\n    }\n\n    Ok(max_offset)\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::merge_axes":["pub fn merge_axes<D>(dim: &mut D, strides: &mut D, take: Axis, into: Axis) -> bool\nwhere\n    D: Dimension,{\n    let into_len = dim.axis(into);\n    let into_stride = strides.axis(into) as isize;\n    let take_len = dim.axis(take);\n    let take_stride = strides.axis(take) as isize;\n    let merged_len = into_len * take_len;\n    if take_len <= 1 {\n        dim.set_axis(into, merged_len);\n        dim.set_axis(take, if merged_len == 0 { 0 } else { 1 });\n        true\n    } else if into_len <= 1 {\n        strides.set_axis(into, take_stride as usize);\n        dim.set_axis(into, merged_len);\n        dim.set_axis(take, if merged_len == 0 { 0 } else { 1 });\n        true\n    } else if take_stride == into_len as isize * into_stride {\n        dim.set_axis(into, merged_len);\n        dim.set_axis(take, 1);\n        true\n    } else {\n        false\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::ndindex::<impl dimension::conversion::IntoDimension for &'a [usize]>::into_dimension":["fn into_dimension(self) -> Self::Dim{\n        Dim(IxDynImpl::from(self))\n    }","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"dimension::ndindex::NdIndex":["/// Tuple or fixed size arrays that can be used to index an array.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let mut a = arr2(&[[0, 1],\n///                    [2, 3]]);\n/// assert_eq!(a[[0, 1]], 1);\n/// assert_eq!(a[[1, 1]], 3);\n/// a[[1, 1]] += 1;\n/// assert_eq!(a[(1, 1)], 4);\n/// ```\npub unsafe trait NdIndex<E>: Debug {\n    #[doc(hidden)]\n    fn index_checked(&self, dim: &E, strides: &E) -> Option<isize>;\n    #[doc(hidden)]\n    fn index_unchecked(&self, strides: &E) -> isize;\n}","Real(LocalPath(\"src/dimension/ndindex.rs\"))"],"dimension::remove_axis::RemoveAxis":["/// Array shape with a next smaller dimension.\n///\n/// `RemoveAxis` defines a larger-than relation for array shapes:\n/// removing one axis from *Self* gives smaller dimension *Smaller*.\npub trait RemoveAxis: Dimension {\n    fn remove_axis(&self, axis: Axis) -> Self::Smaller;\n}","Real(LocalPath(\"src/dimension/remove_axis.rs\"))"],"dimension::size_of_shape_checked":["/// Returns the `size` of the `dim`, checking that the product of non-zero axis\n/// lengths does not exceed `isize::MAX`.\n///\n/// If `size_of_checked_shape(dim)` returns `Ok(size)`, the data buffer is a\n/// slice or `Vec` of length `size`, and `strides` are created with\n/// `self.default_strides()` or `self.fortran_strides()`, then the invariants\n/// are met to construct an array from the data buffer, `dim`, and `strides`.\n/// (The data buffer being a slice or `Vec` guarantees that it contains no more\n/// than `isize::MAX` bytes.)\npub fn size_of_shape_checked<D: Dimension>(dim: &D) -> Result<usize, ShapeError>{\n    let size_nonzero = dim\n        .slice()\n        .iter()\n        .filter(|&&d| d != 0)\n        .try_fold(1usize, |acc, &d| acc.checked_mul(d))\n        .ok_or_else(|| from_kind(ErrorKind::Overflow))?;\n    if size_nonzero > ::std::isize::MAX as usize {\n        Err(from_kind(ErrorKind::Overflow))\n    } else {\n        Ok(dim.size())\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::slice_min_max":["/// Returns the minimum and maximum values of the indices (inclusive).\n///\n/// If the slice is empty, then returns `None`, otherwise returns `Some((min, max))`.\nfn slice_min_max(axis_len: usize, slice: Slice) -> Option<(usize, usize)>{\n    let (start, end, step) = to_abs_slice(axis_len, slice);\n    if start == end {\n        None\n    } else if step > 0 {\n        Some((start, end - 1 - (end - start - 1) % (step as usize)))\n    } else {\n        Some((start + (end - start - 1) % (-step as usize), end - 1))\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::slices_intersect":["/// Returns `true` iff the slices intersect.\npub fn slices_intersect<D: Dimension>(\n    dim: &D,\n    indices1: &D::SliceArg,\n    indices2: &D::SliceArg,\n) -> bool{\n    debug_assert_eq!(indices1.as_ref().len(), indices2.as_ref().len());\n    for (&axis_len, &si1, &si2) in izip!(dim.slice(), indices1.as_ref(), indices2.as_ref()) {\n        // The slices do not intersect iff any pair of `SliceOrIndex` does not intersect.\n        match (si1, si2) {\n            (\n                SliceOrIndex::Slice {\n                    start: start1,\n                    end: end1,\n                    step: step1,\n                },\n                SliceOrIndex::Slice {\n                    start: start2,\n                    end: end2,\n                    step: step2,\n                },\n            ) => {\n                let (min1, max1) = match slice_min_max(axis_len, Slice::new(start1, end1, step1)) {\n                    Some(m) => m,\n                    None => return false,\n                };\n                let (min2, max2) = match slice_min_max(axis_len, Slice::new(start2, end2, step2)) {\n                    Some(m) => m,\n                    None => return false,\n                };\n                if !arith_seq_intersect(\n                    (min1 as isize, max1 as isize, step1),\n                    (min2 as isize, max2 as isize, step2),\n                ) {\n                    return false;\n                }\n            }\n            (SliceOrIndex::Slice { start, end, step }, SliceOrIndex::Index(ind))\n            | (SliceOrIndex::Index(ind), SliceOrIndex::Slice { start, end, step }) => {\n                let ind = abs_index(axis_len, ind);\n                let (min, max) = match slice_min_max(axis_len, Slice::new(start, end, step)) {\n                    Some(m) => m,\n                    None => return false,\n                };\n                if ind < min || ind > max || (ind - min) % step.abs() as usize != 0 {\n                    return false;\n                }\n            }\n            (SliceOrIndex::Index(ind1), SliceOrIndex::Index(ind2)) => {\n                let ind1 = abs_index(axis_len, ind1);\n                let ind2 = abs_index(axis_len, ind2);\n                if ind1 != ind2 {\n                    return false;\n                }\n            }\n        }\n    }\n    true\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::solve_linear_diophantine_eq":["/// Solves `a * x + b * y = c` for `x` where `a`, `b`, `c`, `x`, and `y` are\n/// integers.\n///\n/// If the return value is `Some((x0, xd))`, there is a solution. `xd` is\n/// always positive. Solutions `x` are given by `x0 + xd * t` where `t` is any\n/// integer. The value of `y` for any `x` is then `y = (c - a * x) / b`.\n///\n/// If the return value is `None`, no solutions exist.\n///\n/// **Note** `a` and `b` must be nonzero.\n///\n/// See https://en.wikipedia.org/wiki/Diophantine_equation#One_equation\n/// and https://math.stackexchange.com/questions/1656120#1656138\nfn solve_linear_diophantine_eq(a: isize, b: isize, c: isize) -> Option<(isize, isize)>{\n    debug_assert_ne!(a, 0);\n    debug_assert_ne!(b, 0);\n    let (g, (u, _)) = extended_gcd(a, b);\n    if c % g == 0 {\n        Some((c / g * u, (b / g).abs()))\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::stride_offset":["/// Calculate offset from `Ix` stride converting sign properly\n#[inline(always)]\npub fn stride_offset(n: Ix, stride: Ix) -> isize{\n    (n as isize) * ((stride as Ixs) as isize)\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::stride_offset_checked":["/// Stride offset checked general version (slices)\n#[inline]\npub fn stride_offset_checked(dim: &[Ix], strides: &[Ix], index: &[Ix]) -> Option<isize>{\n    if index.len() != dim.len() {\n        return None;\n    }\n    let mut offset = 0;\n    for (&d, &i, &s) in izip!(dim, index, strides) {\n        if i >= d {\n            return None;\n        }\n        offset += stride_offset(i, s);\n    }\n    Some(offset)\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"dimension::to_abs_slice":["/// Determines nonnegative start and end indices, and performs sanity checks.\n///\n/// The return value is (start, end, step).\n///\n/// **Panics** if stride is 0 or if any index is out of bounds.\nfn to_abs_slice(axis_len: usize, slice: Slice) -> (usize, usize, isize){\n    let Slice { start, end, step } = slice;\n    let start = abs_index(axis_len, start);\n    let mut end = abs_index(axis_len, end.unwrap_or(axis_len as isize));\n    if end < start {\n        end = start;\n    }\n    ndassert!(\n        start <= axis_len,\n        \"Slice begin {} is past end of axis of length {}\",\n        start,\n        axis_len,\n    );\n    ndassert!(\n        end <= axis_len,\n        \"Slice end {} is past end of axis of length {}\",\n        end,\n        axis_len,\n    );\n    ndassert!(step != 0, \"Slice stride must not be zero\");\n    (start, end, step)\n}","Real(LocalPath(\"src/dimension/mod.rs\"))"],"error::ErrorKind":["/// Error code for an error related to array shape or layout.\n///\n/// This enumeration is not exhaustive. The representation of the enum\n/// is not guaranteed.\npub enum ErrorKind {\n    /// incompatible shape\n    IncompatibleShape = 1,\n    /// incompatible memory layout\n    IncompatibleLayout,\n    /// the shape does not fit inside type limits\n    RangeLimited,\n    /// out of bounds indexing\n    OutOfBounds,\n    /// aliasing array elements\n    Unsupported,\n    /// overflow when computing offset, length, etc.\n    Overflow,\n    #[doc(hidden)]\n    __Incomplete,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ShapeError":["/// An error related to array shape or layout.\npub struct ShapeError {\n    // we want to be able to change this representation later\n    repr: ErrorKind,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ShapeError::from_kind":["/// Create a new `ShapeError`\npub fn from_kind(error: ErrorKind) -> Self{\n        from_kind(error)\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::ShapeError::kind":["/// Return the `ErrorKind` of this error.\n#[inline]\npub fn kind(&self) -> ErrorKind{\n        self.repr\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::from_kind":["#[inline(always)]\npub fn from_kind(k: ErrorKind) -> ShapeError{\n    ShapeError { repr: k }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::incompatible_shapes":["pub fn incompatible_shapes<D, E>(_a: &D, _b: &E) -> ShapeError\nwhere\n    D: Dimension,\n    E: Dimension,{\n    from_kind(ErrorKind::IncompatibleShape)\n}","Real(LocalPath(\"src/error.rs\"))"],"extension::nonnull::nonnull_debug_checked_from_ptr":["/// Converts `ptr` to `NonNull<T>`\n///\n/// Safety: `ptr` *must* be non-null.\n/// This is checked with a debug assertion, and will panic if this is not true,\n/// but treat this as an unconditional conversion.\n#[inline]\npub(crate) unsafe fn nonnull_debug_checked_from_ptr<T>(ptr: *mut T) -> NonNull<T>{\n    debug_assert!(!ptr.is_null());\n    NonNull::new_unchecked(ptr)\n}","Real(LocalPath(\"src/extension/nonnull.rs\"))"],"extension::nonnull::nonnull_from_vec_data":["/// Return a NonNull<T> pointer to the vector's data\npub(crate) fn nonnull_from_vec_data<T>(v: &mut Vec<T>) -> NonNull<T>{\n    // this pointer is guaranteed to be non-null\n    unsafe { NonNull::new_unchecked(v.as_mut_ptr()) }\n}","Real(LocalPath(\"src/extension/nonnull.rs\"))"],"free_functions::<impl std::convert::From<std::vec::Vec<V>> for ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 2]>>>::from":["/// Converts the `Vec` of arrays to an owned 2-D array.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\nfn from(mut xs: Vec<V>) -> Self{\n        let dim = Ix2(xs.len(), V::len());\n        let ptr = xs.as_mut_ptr();\n        let cap = xs.capacity();\n        let expand_len = dimension::size_of_shape_checked(&dim)\n            .expect(\"Product of non-zero axis lengths must not overflow isize.\");\n        forget(xs);\n        unsafe {\n            let v = if size_of::<A>() == 0 {\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_len)\n            } else if V::len() == 0 {\n                Vec::new()\n            } else {\n                // Guaranteed not to overflow in this case since A is non-ZST\n                // and Vec never allocates more than isize bytes.\n                let expand_cap = cap * V::len();\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_cap)\n            };\n            ArrayBase::from_shape_vec_unchecked(dim, v)\n        }\n    }","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::<impl std::convert::From<std::vec::Vec<V>> for ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 3]>>>::from":["/// Converts the `Vec` of arrays to an owned 3-D array.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\nfn from(mut xs: Vec<V>) -> Self{\n        let dim = Ix3(xs.len(), V::len(), U::len());\n        let ptr = xs.as_mut_ptr();\n        let cap = xs.capacity();\n        let expand_len = dimension::size_of_shape_checked(&dim)\n            .expect(\"Product of non-zero axis lengths must not overflow isize.\");\n        forget(xs);\n        unsafe {\n            let v = if size_of::<A>() == 0 {\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_len)\n            } else if V::len() == 0 || U::len() == 0 {\n                Vec::new()\n            } else {\n                // Guaranteed not to overflow in this case since A is non-ZST\n                // and Vec never allocates more than isize bytes.\n                let expand_cap = cap * V::len() * U::len();\n                Vec::from_raw_parts(ptr as *mut A, expand_len, expand_cap)\n            };\n            ArrayBase::from_shape_vec_unchecked(dim, v)\n        }\n    }","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::FixedInitializer":["/// Fixed-size array used for array initialization\npub unsafe trait FixedInitializer {\n    type Elem;\n    fn as_init_slice(&self) -> &[Self::Elem];\n    fn len() -> usize;\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::arr0":["/// Create a zero-dimensional array with the element `x`.\npub fn arr0<A>(x: A) -> Array0<A>{\n    unsafe { ArrayBase::from_shape_vec_unchecked((), vec![x]) }\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::arr1":["/// Create a one-dimensional array with elements from `xs`.\npub fn arr1<A: Clone>(xs: &[A]) -> Array1<A>{\n    ArrayBase::from(xs.to_vec())\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::arr2":["/// Create a two-dimensional array with elements from `xs`.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[1, 2, 3],\n///                [4, 5, 6]]);\n/// assert!(\n///     a.shape() == [2, 3]\n/// );\n/// ```\npub fn arr2<A: Clone, V: FixedInitializer<Elem = A>>(xs: &[V]) -> Array2<A>\nwhere\n    V: Clone,{\n    Array2::from(xs.to_vec())\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::arr3":["/// Create a three-dimensional array with elements from `xs`.\n///\n/// **Panics** if the slices are not all of the same length.\n///\n/// ```\n/// use ndarray::arr3;\n///\n/// let a = arr3(&[[[1, 2],\n///                 [3, 4]],\n///                [[5, 6],\n///                 [7, 8]],\n///                [[9, 0],\n///                 [1, 2]]]);\n/// assert!(\n///     a.shape() == [3, 2, 2]\n/// );\n/// ```\npub fn arr3<A: Clone, V: FixedInitializer<Elem = U>, U: FixedInitializer<Elem = A>>(\n    xs: &[V],\n) -> Array3<A>\nwhere\n    V: Clone,\n    U: Clone,{\n    Array3::from(xs.to_vec())\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::aview0":["/// Create a zero-dimensional array view borrowing `x`.\npub fn aview0<A>(x: &A) -> ArrayView0<'_, A>{\n    unsafe { ArrayView::from_shape_ptr(Ix0(), x) }\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::aview1":["/// Create a one-dimensional array view with elements borrowing `xs`.\n///\n/// ```\n/// use ndarray::aview1;\n///\n/// let data = [1.0; 1024];\n///\n/// // Create a 2D array view from borrowed data\n/// let a2d = aview1(&data).into_shape((32, 32)).unwrap();\n///\n/// assert_eq!(a2d.sum(), 1024.0);\n/// ```\npub fn aview1<A>(xs: &[A]) -> ArrayView1<'_, A>{\n    ArrayView::from(xs)\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::aview2":["/// Create a two-dimensional array view with elements borrowing `xs`.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`. (This\n/// can only occur when `V` is zero-sized.)\npub fn aview2<A, V: FixedInitializer<Elem = A>>(xs: &[V]) -> ArrayView2<'_, A>{\n    let cols = V::len();\n    let rows = xs.len();\n    let dim = Ix2(rows, cols);\n    if size_of::<V>() == 0 {\n        dimension::size_of_shape_checked(&dim)\n            .expect(\"Product of non-zero axis lengths must not overflow isize.\");\n    }\n    // `rows` is guaranteed to fit in `isize` because we've checked the ZST\n    // case and slices never contain > `isize::MAX` bytes. `cols` is guaranteed\n    // to fit in `isize` because `FixedInitializer` is not implemented for any\n    // array lengths > `isize::MAX`. `cols * rows` is guaranteed to fit in\n    // `isize` because we've checked the ZST case and slices never contain >\n    // `isize::MAX` bytes.\n    unsafe {\n        let data = slice::from_raw_parts(xs.as_ptr() as *const A, cols * rows);\n        ArrayView::from_shape_ptr(dim, data.as_ptr())\n    }\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::aview_mut1":["/// Create a one-dimensional read-write array view with elements borrowing `xs`.\n///\n/// ```\n/// use ndarray::{aview_mut1, s};\n/// // Create an array view over some data, then slice it and modify it.\n/// let mut data = [0; 1024];\n/// {\n///     let mut a = aview_mut1(&mut data).into_shape((32, 32)).unwrap();\n///     a.slice_mut(s![.., ..;3]).fill(5);\n/// }\n/// assert_eq!(&data[..10], [5, 0, 0, 5, 0, 0, 5, 0, 0, 5]);\n/// ```\npub fn aview_mut1<A>(xs: &mut [A]) -> ArrayViewMut1<'_, A>{\n    ArrayViewMut::from(xs)\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::aview_mut2":["/// Create a two-dimensional read-write array view with elements borrowing `xs`.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`. (This\n/// can only occur when `V` is zero-sized.)\n///\n/// # Example\n///\n/// ```\n/// use ndarray::aview_mut2;\n///\n/// // The inner (nested) array must be of length 1 to 16, but the outer\n/// // can be of any length.\n/// let mut data = [[0.; 2]; 128];\n/// {\n///     // Make a 128 x 2 mut array view then turn it into 2 x 128\n///     let mut a = aview_mut2(&mut data).reversed_axes();\n///     // Make the first row ones and second row minus ones.\n///     a.row_mut(0).fill(1.);\n///     a.row_mut(1).fill(-1.);\n/// }\n/// // look at the start of the result\n/// assert_eq!(&data[..3], [[1., -1.], [1., -1.], [1., -1.]]);\n/// ```\npub fn aview_mut2<A, V: FixedInitializer<Elem = A>>(xs: &mut [V]) -> ArrayViewMut2<'_, A>{\n    let cols = V::len();\n    let rows = xs.len();\n    let dim = Ix2(rows, cols);\n    if size_of::<V>() == 0 {\n        dimension::size_of_shape_checked(&dim)\n            .expect(\"Product of non-zero axis lengths must not overflow isize.\");\n    }\n    // `rows` is guaranteed to fit in `isize` because we've checked the ZST\n    // case and slices never contain > `isize::MAX` bytes. `cols` is guaranteed\n    // to fit in `isize` because `FixedInitializer` is not implemented for any\n    // array lengths > `isize::MAX`. `cols * rows` is guaranteed to fit in\n    // `isize` because we've checked the ZST case and slices never contain >\n    // `isize::MAX` bytes.\n    unsafe {\n        let data = slice::from_raw_parts_mut(xs.as_mut_ptr() as *mut A, cols * rows);\n        ArrayViewMut::from_shape_ptr(dim, data.as_mut_ptr())\n    }\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::rcarr1":["/// Create a one-dimensional array with elements from `xs`.\npub fn rcarr1<A: Clone>(xs: &[A]) -> ArcArray1<A>{\n    arr1(xs).into_shared()\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::rcarr2":["/// Create a two-dimensional array with elements from `xs`.\n///\npub fn rcarr2<A: Clone, V: Clone + FixedInitializer<Elem = A>>(xs: &[V]) -> ArcArray2<A>{\n    arr2(xs).into_shared()\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"free_functions::rcarr3":["/// Create a three-dimensional array with elements from `xs`.\npub fn rcarr3<A: Clone, V: FixedInitializer<Elem = U>, U: FixedInitializer<Elem = A>>(\n    xs: &[V],\n) -> ArcArray<A, Ix3>\nwhere\n    V: Clone,\n    U: Clone,{\n    arr3(xs).into_shared()\n}","Real(LocalPath(\"src/free_functions.rs\"))"],"geomspace::Geomspace":["/// An iterator of a sequence of geometrically spaced floats.\n///\n/// Iterator element type is `F`.\npub struct Geomspace<F> {\n    sign: F,\n    start: F,\n    step: F,\n    index: usize,\n    len: usize,\n}","Real(LocalPath(\"src/geomspace.rs\"))"],"geomspace::geomspace":["/// An iterator of a sequence of geometrically spaced values.\n///\n/// The `Geomspace` has `n` geometrically spaced elements from `start` to `end`\n/// (inclusive).\n///\n/// The iterator element type is `F`, where `F` must implement `Float`, e.g.\n/// `f32` or `f64`.\n///\n/// Returns `None` if `start` and `end` have different signs or if either one\n/// is zero. Conceptually, this means that in order to obtain a `Some` result,\n/// `end / start` must be positive.\n///\n/// **Panics** if converting `n - 1` to type `F` fails.\n#[inline]\npub fn geomspace<F>(a: F, b: F, n: usize) -> Option<Geomspace<F>>\nwhere\n    F: Float,{\n    if a == F::zero() || b == F::zero() || a.is_sign_negative() != b.is_sign_negative() {\n        return None;\n    }\n    let log_a = a.abs().ln();\n    let log_b = b.abs().ln();\n    let step = if n > 1 {\n        let num_steps = F::from(n - 1).expect(\"Converting number of steps to `A` must not fail.\");\n        (log_b - log_a) / num_steps\n    } else {\n        F::zero()\n    };\n    Some(Geomspace {\n        sign: a.signum(),\n        start: log_a,\n        step,\n        index: 0,\n        len: n,\n    })\n}","Real(LocalPath(\"src/geomspace.rs\"))"],"impl_1d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::to_vec":["/// Return an vector with the elements of the one-dimensional array.\npub fn to_vec(&self) -> Vec<A>\n    where\n        A: Clone,\n        S: Data,{\n        if let Some(slc) = self.as_slice() {\n            slc.to_vec()\n        } else {\n            crate::iterators::to_vec(self.iter().cloned())\n        }\n    }","Real(LocalPath(\"src/impl_1d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::cols":["/// Return the number of columns (length of `Axis(1)`) in the two-dimensional array.\n#[deprecated(note = \"Renamed to .ncols(), please use the new name\")]\npub fn cols(&self) -> usize{\n        self.ncols()\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::column":["/// Return an array view of column `index`.\n///\n/// **Panics** if `index` is out of bounds.\npub fn column(&self, index: Ix) -> ArrayView1<'_, A>\n    where\n        S: Data,{\n        self.index_axis(Axis(1), index)\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::column_mut":["/// Return a mutable array view of column `index`.\n///\n/// **Panics** if `index` is out of bounds.\npub fn column_mut(&mut self, index: Ix) -> ArrayViewMut1<'_, A>\n    where\n        S: DataMut,{\n        self.index_axis_mut(Axis(1), index)\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::is_square":["/// Return true if the array is square, false otherwise.\npub fn is_square(&self) -> bool{\n        self.nrows() == self.ncols()\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::ncols":["/// Return the number of columns (length of `Axis(1)`) in the two-dimensional array.\npub fn ncols(&self) -> usize{\n        self.len_of(Axis(1))\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::nrows":["/// Return the number of rows (length of `Axis(0)`) in the two-dimensional array.\npub fn nrows(&self) -> usize{\n        self.len_of(Axis(0))\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::row":["/// Return an array view of row `index`.\n///\n/// **Panics** if `index` is out of bounds.\npub fn row(&self, index: Ix) -> ArrayView1<'_, A>\n    where\n        S: Data,{\n        self.index_axis(Axis(0), index)\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::row_mut":["/// Return a mutable array view of row `index`.\n///\n/// **Panics** if `index` is out of bounds.\npub fn row_mut(&mut self, index: Ix) -> ArrayViewMut1<'_, A>\n    where\n        S: DataMut,{\n        self.index_axis_mut(Axis(0), index)\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::rows":["/// Return the number of rows (length of `Axis(0)`) in the two-dimensional array.\n#[deprecated(note = \"Renamed to .nrows(), please use the new name\")]\npub fn rows(&self) -> usize{\n        self.nrows()\n    }","Real(LocalPath(\"src/impl_2d.rs\"))"],"impl_clone::<impl std::clone::Clone for ArrayBase<S, D>>::clone":["fn clone(&self) -> ArrayBase<S, D>{\n        unsafe {\n            let (data, ptr) = self.data.clone_with_ptr(self.ptr);\n            ArrayBase {\n                data,\n                ptr,\n                dim: self.dim.clone(),\n                strides: self.strides.clone(),\n            }\n        }\n    }","Real(LocalPath(\"src/impl_clone.rs\"))"],"impl_clone::<impl std::clone::Clone for ArrayBase<S, D>>::clone_from":["/// `Array` implements `.clone_from()` to reuse an array's existing\n/// allocation. Semantically equivalent to `*self = other.clone()`, but\n/// potentially more efficient.\nfn clone_from(&mut self, other: &Self){\n        unsafe {\n            self.ptr = self.data.clone_from_with_ptr(&other.data, other.ptr);\n            self.dim.clone_from(&other.dim);\n            self.strides.clone_from(&other.strides);\n        }\n    }","Real(LocalPath(\"src/impl_clone.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::default":["/// Create an array with default values, shape `shape`\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\npub fn default<Sh>(shape: Sh) -> Self\n    where\n        A: Default,\n        Sh: ShapeBuilder<Dim = D>,{\n        Self::from_shape_simple_fn(shape, A::default)\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_elem":["/// Create an array with copies of `elem`, shape `shape`.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\n///\n/// ```\n/// use ndarray::{Array, arr3, ShapeBuilder};\n///\n/// let a = Array::from_elem((2, 2, 2), 1.);\n///\n/// assert!(\n///     a == arr3(&[[[1., 1.],\n///                  [1., 1.]],\n///                 [[1., 1.],\n///                  [1., 1.]]])\n/// );\n/// assert!(a.strides() == &[4, 2, 1]);\n///\n/// let b = Array::from_elem((2, 2, 2).f(), 1.);\n/// assert!(b.strides() == &[1, 2, 4]);\n/// ```\npub fn from_elem<Sh>(shape: Sh, elem: A) -> Self\n    where\n        A: Clone,\n        Sh: ShapeBuilder<Dim = D>,{\n        let shape = shape.into_shape();\n        let size = size_of_shape_checked_unwrap!(&shape.dim);\n        let v = vec![elem; size];\n        unsafe { Self::from_shape_vec_unchecked(shape, v) }\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_fn":["/// Create an array with values created by the function `f`.\n///\n/// `f` is called with the index of the element to create; the elements are\n/// visited in arbitrary order.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\n///\n/// ```\n/// use ndarray::{Array, arr2};\n///\n/// // Create a table of i j (with i and j from 1 to 3)\n/// let ij_table = Array::from_shape_fn((3, 3), |(i, j)| (1 + i) * (1 + j));\n///\n/// assert_eq!(\n///     ij_table,\n///     arr2(&[[1, 2, 3],\n///            [2, 4, 6],\n///            [3, 6, 9]])\n/// );\n/// ```\npub fn from_shape_fn<Sh, F>(shape: Sh, f: F) -> Self\n    where\n        Sh: ShapeBuilder<Dim = D>,\n        F: FnMut(D::Pattern) -> A,{\n        let shape = shape.into_shape();\n        let _ = size_of_shape_checked_unwrap!(&shape.dim);\n        if shape.is_c {\n            let v = to_vec_mapped(indices(shape.dim.clone()).into_iter(), f);\n            unsafe { Self::from_shape_vec_unchecked(shape, v) }\n        } else {\n            let dim = shape.dim.clone();\n            let v = to_vec_mapped(indexes::indices_iter_f(dim), f);\n            unsafe { Self::from_shape_vec_unchecked(shape, v) }\n        }\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_simple_fn":["/// Create an array with values created by the function `f`.\n///\n/// `f` is called with no argument, and it should return the element to\n/// create. If the precise index of the element to create is needed,\n/// use [`from_shape_fn`](ArrayBase::from_shape_fn) instead.\n///\n/// This constructor can be useful if the element order is not important,\n/// for example if they are identical or random.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\npub fn from_shape_simple_fn<Sh, F>(shape: Sh, mut f: F) -> Self\n    where\n        Sh: ShapeBuilder<Dim = D>,\n        F: FnMut() -> A,{\n        let shape = shape.into_shape();\n        let len = size_of_shape_checked_unwrap!(&shape.dim);\n        let v = to_vec_mapped(0..len, move |_| f());\n        unsafe { Self::from_shape_vec_unchecked(shape, v) }\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec":["/// Create an array with the given shape from a vector. (No cloning of\n/// elements needed.)\n///\n/// ----\n///\n/// For a contiguous c- or f-order shape, the following applies:\n///\n/// **Errors** if `shape` does not correspond to the number of elements in\n/// `v` or if the shape/strides would result in overflowing `isize`.\n///\n/// ----\n///\n/// For custom strides, the following applies:\n///\n/// **Errors** if strides and dimensions can point out of bounds of `v`, if\n/// strides allow multiple indices to point to the same element, or if the\n/// shape/strides would result in overflowing `isize`.\n///\n/// ```\n/// use ndarray::Array;\n/// use ndarray::ShapeBuilder; // Needed for .strides() method\n/// use ndarray::arr2;\n///\n/// let a = Array::from_shape_vec((2, 2), vec![1., 2., 3., 4.]);\n/// assert!(a.is_ok());\n///\n/// let b = Array::from_shape_vec((2, 2).strides((1, 2)),\n///                               vec![1., 2., 3., 4.]).unwrap();\n/// assert!(\n///     b == arr2(&[[1., 3.],\n///                 [2., 4.]])\n/// );\n/// ```\npub fn from_shape_vec<Sh>(shape: Sh, v: Vec<A>) -> Result<Self, ShapeError>\n    where\n        Sh: Into<StrideShape<D>>,{\n        // eliminate the type parameter Sh as soon as possible\n        Self::from_shape_vec_impl(shape.into(), v)\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec_impl":["fn from_shape_vec_impl(shape: StrideShape<D>, v: Vec<A>) -> Result<Self, ShapeError>{\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if shape.custom {\n            dimension::can_index_slice(&v, &dim, &strides)?;\n        } else {\n            dimension::can_index_slice_not_custom::<A, _>(&v, &dim)?;\n            if dim.size() != v.len() {\n                return Err(error::incompatible_shapes(&Ix1(v.len()), &dim));\n            }\n        }\n        unsafe { Ok(Self::from_vec_dim_stride_unchecked(dim, strides, v)) }\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec_unchecked":["/// Creates an array from a vector and interpret it according to the\n/// provided shape and strides. (No cloning of elements needed.)\n///\n/// # Safety\n///\n/// The caller must ensure that the following conditions are met:\n///\n/// 1. The ndim of `dim` and `strides` must be the same.\n///\n/// 2. The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// 3. For axes with length > 1, the stride must be nonnegative.\n///\n/// 4. If the array will be empty (any axes are zero-length), the\n///    difference between the least address and greatest address accessible\n///    by moving along all axes must be  `v.len()`.\n///\n///    If the array will not be empty, the difference between the least\n///    address and greatest address accessible by moving along all axes\n///    must be < `v.len()`.\n///\n/// 5. The strides must not allow any element to be referenced by two different\n///    indices.\npub unsafe fn from_shape_vec_unchecked<Sh>(shape: Sh, v: Vec<A>) -> Self\n    where\n        Sh: Into<StrideShape<D>>,{\n        let shape = shape.into();\n        Self::from_vec_dim_stride_unchecked(shape.dim, shape.strides, v)\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::from_vec_dim_stride_unchecked":["unsafe fn from_vec_dim_stride_unchecked(dim: D, strides: D, mut v: Vec<A>) -> Self{\n        // debug check for issues that indicates wrong use of this constructor\n        debug_assert!(dimension::can_index_slice(&v, &dim, &strides).is_ok());\n        ArrayBase {\n            ptr: nonnull_from_vec_data(&mut v),\n            data: DataOwned::new(v),\n            strides,\n            dim,\n        }\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::maybe_uninit":["/// Create an array with uninitalized elements, shape `shape`.\n///\n/// The uninitialized elements of type `A` are represented by the type `MaybeUninit<A>`,\n/// an easier way to handle uninit values correctly.\n///\n/// Only *when* the array is completely initialized with valid elements, can it be\n/// converted to an array of `A` elements using [`.assume_init()`].\n///\n/// **Panics** if the number of elements in `shape` would overflow isize.\n///\n/// ### Safety\n///\n/// The whole of the array must be initialized before it is converted\n/// using [`.assume_init()`] or otherwise traversed.\n///\n/// ### Examples\n///\n/// It is possible to assign individual values through `*elt = MaybeUninit::new(value)`\n/// and so on.\n///\n/// [`.assume_init()`]: ArrayBase::assume_init\n///\n/// ```\n/// use ndarray::{s, Array2};\n/// use ndarray::Zip;\n/// use ndarray::Axis;\n///\n/// // Example Task: Let's create a column shifted copy of the input\n///\n/// fn shift_by_two(a: &Array2<f32>) -> Array2<f32> {\n///     // create an uninitialized array\n///     let mut b = Array2::maybe_uninit(a.dim());\n///\n///     // two first columns in b are two last in a\n///     // rest of columns in b are the initial columns in a\n///\n///     assign_to(a.slice(s![.., -2..]), b.slice_mut(s![.., ..2]));\n///     assign_to(a.slice(s![.., 2..]), b.slice_mut(s![.., ..-2]));\n///\n///     // Now we can promise that `b` is safe to use with all operations\n///     unsafe {\n///         b.assume_init()\n///     }\n/// }\n///\n/// use ndarray::{IntoNdProducer, AssignElem};\n///\n/// // This function clones elements from the first input to the second;\n/// // the two producers must have the same shape\n/// fn assign_to<'a, P1, P2, A>(from: P1, to: P2)\n///     where P1: IntoNdProducer<Item = &'a A>,\n///           P2: IntoNdProducer<Dim = P1::Dim>,\n///           P2::Item: AssignElem<A>,\n///           A: Clone + 'a\n/// {\n///     Zip::from(from)\n///         .apply_assign_into(to, A::clone);\n/// }\n///\n/// # shift_by_two(&Array2::zeros((8, 8)));\n/// ```\npub fn maybe_uninit<Sh>(shape: Sh) -> Self\n    where\n        Sh: ShapeBuilder<Dim = D>,{\n        unsafe {\n            let shape = shape.into_shape();\n            let size = size_of_shape_checked_unwrap!(&shape.dim);\n            let mut v = Vec::with_capacity(size);\n            v.set_len(size);\n            Self::from_shape_vec_unchecked(shape, v)\n        }\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::ones":["/// Create an array with ones, shape `shape`.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\npub fn ones<Sh>(shape: Sh) -> Self\n    where\n        A: Clone + One,\n        Sh: ShapeBuilder<Dim = D>,{\n        Self::from_elem(shape, A::one())\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::uninitialized":["/// Create an array with uninitalized elements, shape `shape`.\n///\n/// Prefer to use [`maybe_uninit()`](ArrayBase::maybe_uninit) if possible, because it is\n/// easier to use correctly.\n///\n/// **Panics** if the number of elements in `shape` would overflow isize.\n///\n/// ### Safety\n///\n/// Accessing uninitalized values is undefined behaviour. You must overwrite *all* the elements\n/// in the array after it is created; for example using\n/// [`raw_view_mut`](ArrayBase::raw_view_mut) or other low-level element access.\n///\n/// The contents of the array is indeterminate before initialization and it\n/// is an error to perform operations that use the previous values. For\n/// example it would not be legal to use `a += 1.;` on such an array.\n///\n/// This constructor is limited to elements where `A: Copy` (no destructors)\n/// to avoid users shooting themselves too hard in the foot.\n/// \n/// (Also note that the constructors `from_shape_vec` and\n/// `from_shape_vec_unchecked` allow the user yet more control, in the sense\n/// that Arrays can be created from arbitrary vectors.)\npub unsafe fn uninitialized<Sh>(shape: Sh) -> Self\n    where\n        A: Copy,\n        Sh: ShapeBuilder<Dim = D>,{\n        let shape = shape.into_shape();\n        let size = size_of_shape_checked_unwrap!(&shape.dim);\n        let mut v = Vec::with_capacity(size);\n        v.set_len(size);\n        Self::from_shape_vec_unchecked(shape, v)\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, D>>::zeros":["/// Create an array with zeros, shape `shape`.\n///\n/// **Panics** if the product of non-zero axis lengths overflows `isize`.\npub fn zeros<Sh>(shape: Sh) -> Self\n    where\n        A: Clone + Zero,\n        Sh: ShapeBuilder<Dim = D>,{\n        Self::from_elem(shape, A::zero())\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from_vec":["/// Create a one-dimensional array from a vector (no copying needed).\n///\n/// **Panics** if the length is greater than `isize::MAX`.\n///\n/// ```rust\n/// use ndarray::Array;\n///\n/// let array = Array::from(vec![1., 2., 3., 4.]);\n/// ```\n#[deprecated(note = \"use standard `from`\", since = \"0.13.0\")]\npub fn from_vec(v: Vec<A>) -> Self{\n        Self::from(v)\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::geomspace":["/// Create a one-dimensional array with `n` geometrically spaced elements\n/// from `start` to `end` (inclusive). `A` must be a floating point type.\n///\n/// Returns `None` if `start` and `end` have different signs or if either\n/// one is zero. Conceptually, this means that in order to obtain a `Some`\n/// result, `end / start` must be positive.\n///\n/// **Panics** if `n` is greater than `isize::MAX` or if converting `n - 1`\n/// to type `A` fails.\n///\n/// ```rust\n/// use approx::assert_abs_diff_eq;\n/// use ndarray::{Array, arr1};\n///\n/// # fn example() -> Option<()> {\n/// # #[cfg(feature = \"approx\")] {\n/// let array = Array::geomspace(1e0, 1e3, 4)?;\n/// assert_abs_diff_eq!(array, arr1(&[1e0, 1e1, 1e2, 1e3]), epsilon = 1e-12);\n///\n/// let array = Array::geomspace(-1e3, -1e0, 4)?;\n/// assert_abs_diff_eq!(array, arr1(&[-1e3, -1e2, -1e1, -1e0]), epsilon = 1e-12);\n/// # }\n/// # Some(())\n/// # }\n/// #\n/// # example().unwrap();\n/// ```\npub fn geomspace(start: A, end: A, n: usize) -> Option<Self>\n    where\n        A: Float,{\n        Some(Self::from(to_vec(geomspace::geomspace(start, end, n)?)))\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::linspace":["/// Create a one-dimensional array with `n` evenly spaced elements from\n/// `start` to `end` (inclusive). `A` must be a floating point type.\n///\n/// Note that if `start > end`, the first element will still be `start`,\n/// and the following elements will be decreasing. This is different from\n/// the behavior of `std::ops::RangeInclusive`, which interprets `start >\n/// end` to mean that the range is empty.\n///\n/// **Panics** if `n` is greater than `isize::MAX` or if converting `n - 1`\n/// to type `A` fails.\n///\n/// ```rust\n/// use ndarray::{Array, arr1};\n///\n/// let array = Array::linspace(0., 1., 5);\n/// assert!(array == arr1(&[0.0, 0.25, 0.5, 0.75, 1.0]))\n/// ```\npub fn linspace(start: A, end: A, n: usize) -> Self\n    where\n        A: Float,{\n        Self::from(to_vec(linspace::linspace(start, end, n)))\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::logspace":["/// Create a one-dimensional array with `n` logarithmically spaced\n/// elements, with the starting value being `base.powf(start)` and the\n/// final one being `base.powf(end)`. `A` must be a floating point type.\n///\n/// If `base` is negative, all values will be negative.\n///\n/// **Panics** if `n` is greater than `isize::MAX` or if converting `n - 1`\n/// to type `A` fails.\n///\n/// ```rust\n/// use approx::assert_abs_diff_eq;\n/// use ndarray::{Array, arr1};\n///\n/// # #[cfg(feature = \"approx\")] {\n/// let array = Array::logspace(10.0, 0.0, 3.0, 4);\n/// assert_abs_diff_eq!(array, arr1(&[1e0, 1e1, 1e2, 1e3]));\n///\n/// let array = Array::logspace(-10.0, 3.0, 0.0, 4);\n/// assert_abs_diff_eq!(array, arr1(&[-1e3, -1e2, -1e1, -1e0]));\n/// # }\n/// ```\npub fn logspace(base: A, start: A, end: A, n: usize) -> Self\n    where\n        A: Float,{\n        Self::from(to_vec(logspace::logspace(base, start, end, n)))\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::range":["/// Create a one-dimensional array with elements from `start` to `end`\n/// (exclusive), incrementing by `step`. `A` must be a floating point type.\n///\n/// **Panics** if the length is greater than `isize::MAX`.\n///\n/// ```rust\n/// use ndarray::{Array, arr1};\n///\n/// let array = Array::range(0., 5., 1.);\n/// assert!(array == arr1(&[0., 1., 2., 3., 4.]))\n/// ```\npub fn range(start: A, end: A, step: A) -> Self\n    where\n        A: Float,{\n        Self::from(to_vec(linspace::range(start, end, step)))\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::eye":["/// Create an identity matrix of size `n` (square 2D array).\n///\n/// **Panics** if `n * n` would overflow `isize`.\npub fn eye(n: Ix) -> Self\n    where\n        S: DataMut,\n        A: Clone + Zero + One,{\n        let mut eye = Self::zeros((n, n));\n        for a_ii in eye.diag_mut() {\n            *a_ii = A::one();\n        }\n        eye\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::from_diag":["/// Create a 2D matrix from its diagonal\n///\n/// **Panics** if `diag.len() * diag.len()` would overflow `isize`.\n///\n/// ```rust\n/// use ndarray::{Array2, arr1, arr2};\n///\n/// let diag = arr1(&[1, 2]);\n/// let array = Array2::from_diag(&diag);\n/// assert_eq!(array, arr2(&[[1, 0], [0, 2]]));\n/// ```\npub fn from_diag<S2>(diag: &ArrayBase<S2, Ix1>) -> Self\n    where\n        A: Clone + Zero,\n        S: DataMut,\n        S2: Data<Elem = A>,{\n        let n = diag.len();\n        let mut arr = Self::zeros((n, n));\n        arr.diag_mut().assign(&diag);\n        arr\n    }","Real(LocalPath(\"src/impl_constructors.rs\"))"],"impl_cow::<impl ArrayBase<CowRepr<'a, A>, D>>::is_owned":["/// Returns `true` iff the array is the owned variant.\npub fn is_owned(&self) -> bool{\n        self.data.is_owned()\n    }","Real(LocalPath(\"src/impl_cow.rs\"))"],"impl_cow::<impl ArrayBase<CowRepr<'a, A>, D>>::is_view":["/// Returns `true` iff the array is the view (borrowed) variant.\npub fn is_view(&self) -> bool{\n        self.data.is_view()\n    }","Real(LocalPath(\"src/impl_cow.rs\"))"],"impl_cow::<impl std::convert::From<ArrayBase<ViewRepr<&'a A>, D>> for ArrayBase<CowRepr<'a, A>, D>>::from":["fn from(view: ArrayView<'a, A, D>) -> CowArray<'a, A, D>{\n        ArrayBase {\n            data: CowRepr::View(view.data),\n            ptr: view.ptr,\n            dim: view.dim,\n            strides: view.strides,\n        }\n    }","Real(LocalPath(\"src/impl_cow.rs\"))"],"impl_cow::<impl std::convert::From<ArrayBase<data_repr::OwnedRepr<A>, D>> for ArrayBase<CowRepr<'a, A>, D>>::from":["fn from(array: Array<A, D>) -> CowArray<'a, A, D>{\n        ArrayBase {\n            data: CowRepr::Owned(array.data),\n            ptr: array.ptr,\n            dim: array.dim,\n            strides: array.strides,\n        }\n    }","Real(LocalPath(\"src/impl_cow.rs\"))"],"impl_dyn::<impl ArrayBase<S, dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_axis_inplace":["/// Collapses the array to `index` along the axis and removes the axis,\n/// modifying the shape and strides in-place.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\n///\n/// ```\n/// use ndarray::{Axis, arr1, arr2};\n///\n/// let mut a = arr2(&[[1, 2, 3], [4, 5, 6]]).into_dyn();\n/// assert_eq!(a.shape(), &[2, 3]);\n///\n/// a.index_axis_inplace(Axis(1), 1);\n/// assert_eq!(a, arr1(&[2, 5]).into_dyn());\n/// assert_eq!(a.shape(), &[2]);\n/// ```\npub fn index_axis_inplace(&mut self, axis: Axis, index: usize){\n        self.collapse_axis(axis, index);\n        self.dim = self.dim.remove_axis(axis);\n        self.strides = self.strides.remove_axis(axis);\n    }","Real(LocalPath(\"src/impl_dyn.rs\"))"],"impl_dyn::<impl ArrayBase<S, dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::insert_axis_inplace":["/// Insert new array axis of length 1 at `axis`, modifying the shape and\n/// strides in-place.\n///\n/// **Panics** if the axis is out of bounds.\n///\n/// ```\n/// use ndarray::{Axis, arr2, arr3};\n///\n/// let mut a = arr2(&[[1, 2, 3], [4, 5, 6]]).into_dyn();\n/// assert_eq!(a.shape(), &[2, 3]);\n///\n/// a.insert_axis_inplace(Axis(1));\n/// assert_eq!(a, arr3(&[[[1, 2, 3]], [[4, 5, 6]]]).into_dyn());\n/// assert_eq!(a.shape(), &[2, 1, 3]);\n/// ```\npub fn insert_axis_inplace(&mut self, axis: Axis){\n        assert!(axis.index() <= self.ndim());\n        self.dim = self.dim.insert_axis(axis);\n        self.strides = self.strides.insert_axis(axis);\n    }","Real(LocalPath(\"src/impl_dyn.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::accumulate_axis_inplace":["/// Iterates over pairs of consecutive elements along the axis.\n///\n/// The first argument to the closure is an element, and the second\n/// argument is the next element along the axis. Iteration is guaranteed to\n/// proceed in order along the specified axis, but in all other respects\n/// the iteration order is unspecified.\n///\n/// # Example\n///\n/// For example, this can be used to compute the cumulative sum along an\n/// axis:\n///\n/// ```\n/// use ndarray::{array, Axis};\n///\n/// let mut arr = array![\n///     [[1, 2], [3, 4], [5, 6]],\n///     [[7, 8], [9, 10], [11, 12]],\n/// ];\n/// arr.accumulate_axis_inplace(Axis(1), |&prev, curr| *curr += prev);\n/// assert_eq!(\n///     arr,\n///     array![\n///         [[1, 2], [4, 6], [9, 12]],\n///         [[7, 8], [16, 18], [27, 30]],\n///     ],\n/// );\n/// ```\npub fn accumulate_axis_inplace<F>(&mut self, axis: Axis, mut f: F)\n    where\n        F: FnMut(&A, &mut A),\n        S: DataMut,{\n        if self.len_of(axis) <= 1 {\n            return;\n        }\n        let mut curr = self.raw_view_mut(); // mut borrow of the array here\n        let mut prev = curr.raw_view(); // derive further raw views from the same borrow\n        prev.slice_axis_inplace(axis, Slice::from(..-1));\n        curr.slice_axis_inplace(axis, Slice::from(1..));\n        // This implementation relies on `Zip` iterating along `axis` in order.\n        Zip::from(prev).and(curr).apply(|prev, curr| unsafe {\n            // These pointer dereferences and borrows are safe because:\n            //\n            // 1. They're pointers to elements in the array.\n            //\n            // 2. `S: DataMut` guarantees that elements are safe to borrow\n            //    mutably and that they don't alias.\n            //\n            // 3. The lifetimes of the borrows last only for the duration\n            //    of the call to `f`, so aliasing across calls to `f`\n            //    cannot occur.\n            f(&*prev, &mut *curr)\n        });\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_mut_ptr":["/// Return a mutable pointer to the first element in the array.\n#[inline(always)]\npub fn as_mut_ptr(&mut self) -> *mut A\n    where\n        S: RawDataMut,{\n        self.try_ensure_unique(); // for RcArray\n        self.ptr.as_ptr()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_ptr":["/// Return a pointer to the first element in the array.\n///\n/// Raw access to array elements needs to follow the strided indexing\n/// scheme: an element at multi-index *I* in an array with strides *S* is\n/// located at offset\n///\n/// *<sub>0  k < d</sub> I<sub>k</sub>  S<sub>k</sub>*\n///\n/// where *d* is `self.ndim()`.\n#[inline(always)]\npub fn as_ptr(&self) -> *const A{\n        self.ptr.as_ptr() as *const A\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_slice":["/// Return the arrays data as a slice, if it is contiguous and in standard order.\n/// Return `None` otherwise.\n///\n/// If this function returns `Some(_)`, then the element order in the slice\n/// corresponds to the logical order of the arrays elements.\npub fn as_slice(&self) -> Option<&[A]>\n    where\n        S: Data,{\n        if self.is_standard_layout() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_slice_memory_order":["/// Return the arrays data as a slice if it is contiguous,\n/// return `None` otherwise.\n///\n/// If this function returns `Some(_)`, then the elements in the slice\n/// have whatever order the elements have in memory.\n///\n/// Implementation notes: Does not yet support negatively strided arrays.\npub fn as_slice_memory_order(&self) -> Option<&[A]>\n    where\n        S: Data,{\n        if self.is_contiguous() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_slice_memory_order_mut":["/// Return the arrays data as a slice if it is contiguous,\n/// return `None` otherwise.\npub fn as_slice_memory_order_mut(&mut self) -> Option<&mut [A]>\n    where\n        S: DataMut,{\n        if self.is_contiguous() {\n            self.ensure_unique();\n            unsafe { Some(slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_slice_mut":["/// Return the arrays data as a slice, if it is contiguous and in standard order.\n/// Return `None` otherwise.\npub fn as_slice_mut(&mut self) -> Option<&mut [A]>\n    where\n        S: DataMut,{\n        if self.is_standard_layout() {\n            self.ensure_unique();\n            unsafe { Some(slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::as_standard_layout":["/// Return a standard-layout array containing the data, cloning if\n/// necessary.\n///\n/// If `self` is in standard layout, a COW view of the data is returned\n/// without cloning. Otherwise, the data is cloned, and the returned array\n/// owns the cloned data.\n///\n/// ```\n/// use ndarray::Array2;\n///\n/// let standard = Array2::<f64>::zeros((3, 4));\n/// assert!(standard.is_standard_layout());\n/// let cow_view = standard.as_standard_layout();\n/// assert!(cow_view.is_view());\n/// assert!(cow_view.is_standard_layout());\n///\n/// let fortran = standard.reversed_axes();\n/// assert!(!fortran.is_standard_layout());\n/// let cow_owned = fortran.as_standard_layout();\n/// assert!(cow_owned.is_owned());\n/// assert!(cow_owned.is_standard_layout());\n/// ```\npub fn as_standard_layout(&self) -> CowArray<'_, A, D>\n    where\n        S: Data<Elem = A>,\n        A: Clone,{\n        if self.is_standard_layout() {\n            CowArray::from(self.view())\n        } else {\n            let v: Vec<A> = self.iter().cloned().collect();\n            let dim = self.dim.clone();\n            assert_eq!(v.len(), dim.size());\n            let owned_array: Array<A, D> = unsafe {\n                // Safe because the shape and element type are from the existing array\n                // and the strides are the default strides.\n                Array::from_shape_vec_unchecked(dim, v)\n            };\n            CowArray::from(owned_array)\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::assign":["/// Perform an elementwise assigment to `self` from `rhs`.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// **Panics** if broadcasting isnt possible.\npub fn assign<E: Dimension, S2>(&mut self, rhs: &ArrayBase<S2, E>)\n    where\n        S: DataMut,\n        A: Clone,\n        S2: Data<Elem = A>,{\n        self.zip_mut_with(rhs, |x, y| *x = y.clone());\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::axes":["/// Return an iterator over the length and stride of each axis.\npub fn axes(&self) -> Axes<'_, D>{\n        axes_of(&self.dim, &self.strides)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::axis_chunks_iter":["/// Return an iterator that traverses over `axis` by chunks of `size`,\n/// yielding non-overlapping views along that axis.\n///\n/// Iterator element is `ArrayView<A, D>`\n///\n/// The last view may have less elements if `size` does not divide\n/// the axis' dimension.\n///\n/// **Panics** if `axis` is out of bounds or if `size` is zero.\n///\n/// ```\n/// use ndarray::Array;\n/// use ndarray::{arr3, Axis};\n/// use std::iter::FromIterator;\n///\n/// let a = Array::from_iter(0..28).into_shape((2, 7, 2)).unwrap();\n/// let mut iter = a.axis_chunks_iter(Axis(1), 2);\n///\n/// // first iteration yields a 2  2  2 view\n/// assert_eq!(iter.next().unwrap(),\n///            arr3(&[[[ 0,  1], [ 2, 3]],\n///                   [[14, 15], [16, 17]]]));\n///\n/// // however the last element is a 2  1  2 view since 7 % 2 == 1\n/// assert_eq!(iter.next_back().unwrap(), arr3(&[[[12, 13]],\n///                                              [[26, 27]]]));\n/// ```\npub fn axis_chunks_iter(&self, axis: Axis, size: usize) -> AxisChunksIter<'_, A, D>\n    where\n        S: Data,{\n        AxisChunksIter::new(self.view(), axis, size)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::axis_chunks_iter_mut":["/// Return an iterator that traverses over `axis` by chunks of `size`,\n/// yielding non-overlapping read-write views along that axis.\n///\n/// Iterator element is `ArrayViewMut<A, D>`\n///\n/// **Panics** if `axis` is out of bounds or if `size` is zero.\npub fn axis_chunks_iter_mut(&mut self, axis: Axis, size: usize) -> AxisChunksIterMut<'_, A, D>\n    where\n        S: DataMut,{\n        AxisChunksIterMut::new(self.view_mut(), axis, size)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::axis_iter":["/// Return an iterator that traverses over `axis`\n/// and yields each subview along it.\n///\n/// For example, in a 3  4  5 array, with `axis` equal to `Axis(2)`,\n/// the iterator element\n/// is a 3  4 subview (and there are 5 in total), as shown\n/// in the picture below.\n///\n/// Iterator element is `ArrayView<A, D::Smaller>` (read-only array view).\n///\n/// See [*Subviews*](#subviews) for full documentation.\n///\n/// **Panics** if `axis` is out of bounds.\n///\n/// <img src=\"https://rust-ndarray.github.io/ndarray/images/axis_iter_3_4_5.svg\" height=\"250px\">\npub fn axis_iter(&self, axis: Axis) -> AxisIter<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,{\n        AxisIter::new(self.view(), axis)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::axis_iter_mut":["/// Return an iterator that traverses over `axis`\n/// and yields each mutable subview along it.\n///\n/// Iterator element is `ArrayViewMut<A, D::Smaller>`\n/// (read-write array view).\n///\n/// **Panics** if `axis` is out of bounds.\npub fn axis_iter_mut(&mut self, axis: Axis) -> AxisIterMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,{\n        AxisIterMut::new(self.view_mut(), axis)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::broadcast":["/// Act like a larger size and/or shape array by *broadcasting*\n/// into a larger shape, if possible.\n///\n/// Return `None` if shapes can not be broadcast together.\n///\n/// ***Background***\n///\n///  * Two axes are compatible if they are equal, or one of them is 1.\n///  * In this instance, only the axes of the smaller side (self) can be 1.\n///\n/// Compare axes beginning with the *last* axis of each shape.\n///\n/// For example (1, 2, 4) can be broadcast into (7, 6, 2, 4)\n/// because its axes are either equal or 1 (or missing);\n/// while (2, 2) can *not* be broadcast into (2, 4).\n///\n/// The implementation creates a view with strides set to zero for the\n/// axes that are to be repeated.\n///\n/// The broadcasting documentation for Numpy has more information.\n///\n/// ```\n/// use ndarray::{aview1, aview2};\n///\n/// assert!(\n///     aview1(&[1., 0.]).broadcast((10, 2)).unwrap()\n///     == aview2(&[[1., 0.]; 10])\n/// );\n/// ```\npub fn broadcast<E>(&self, dim: E) -> Option<ArrayView<'_, A, E::Dim>>\n    where\n        E: IntoDimension,\n        S: Data,{\n        /// Return new stride when trying to grow `from` into shape `to`\n        ///\n        /// Broadcasting works by returning a \"fake stride\" where elements\n        /// to repeat are in axes with 0 stride, so that several indexes point\n        /// to the same element.\n        ///\n        /// **Note:** Cannot be used for mutable iterators, since repeating\n        /// elements would create aliasing pointers.\n        fn upcast<D: Dimension, E: Dimension>(to: &D, from: &E, stride: &E) -> Option<D> {\n            // Make sure the product of non-zero axis lengths does not exceed\n            // `isize::MAX`. This is the only safety check we need to perform\n            // because all the other constraints of `ArrayBase` are guaranteed\n            // to be met since we're starting from a valid `ArrayBase`.\n            let _ = size_of_shape_checked(to).ok()?;\n\n            let mut new_stride = to.clone();\n            // begin at the back (the least significant dimension)\n            // size of the axis has to either agree or `from` has to be 1\n            if to.ndim() < from.ndim() {\n                return None;\n            }\n\n            {\n                let mut new_stride_iter = new_stride.slice_mut().iter_mut().rev();\n                for ((er, es), dr) in from\n                    .slice()\n                    .iter()\n                    .rev()\n                    .zip(stride.slice().iter().rev())\n                    .zip(new_stride_iter.by_ref())\n                {\n                    /* update strides */\n                    if *dr == *er {\n                        /* keep stride */\n                        *dr = *es;\n                    } else if *er == 1 {\n                        /* dead dimension, zero stride */\n                        *dr = 0\n                    } else {\n                        return None;\n                    }\n                }\n\n                /* set remaining strides to zero */\n                for dr in new_stride_iter {\n                    *dr = 0;\n                }\n            }\n            Some(new_stride)\n        }\n        let dim = dim.into_dimension();\n\n        // Note: zero strides are safe precisely because we return an read-only view\n        let broadcast_strides = match upcast(&dim, &self.dim, &self.strides) {\n            Some(st) => st,\n            None => return None,\n        };\n        unsafe { Some(ArrayView::new(self.ptr, dim, broadcast_strides)) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::broadcast::upcast":["/// Return new stride when trying to grow `from` into shape `to`\n///\n/// Broadcasting works by returning a \"fake stride\" where elements\n/// to repeat are in axes with 0 stride, so that several indexes point\n/// to the same element.\n///\n/// **Note:** Cannot be used for mutable iterators, since repeating\n/// elements would create aliasing pointers.\nfn upcast<D: Dimension, E: Dimension>(to: &D, from: &E, stride: &E) -> Option<D>{\n            // Make sure the product of non-zero axis lengths does not exceed\n            // `isize::MAX`. This is the only safety check we need to perform\n            // because all the other constraints of `ArrayBase` are guaranteed\n            // to be met since we're starting from a valid `ArrayBase`.\n            let _ = size_of_shape_checked(to).ok()?;\n\n            let mut new_stride = to.clone();\n            // begin at the back (the least significant dimension)\n            // size of the axis has to either agree or `from` has to be 1\n            if to.ndim() < from.ndim() {\n                return None;\n            }\n\n            {\n                let mut new_stride_iter = new_stride.slice_mut().iter_mut().rev();\n                for ((er, es), dr) in from\n                    .slice()\n                    .iter()\n                    .rev()\n                    .zip(stride.slice().iter().rev())\n                    .zip(new_stride_iter.by_ref())\n                {\n                    /* update strides */\n                    if *dr == *er {\n                        /* keep stride */\n                        *dr = *es;\n                    } else if *er == 1 {\n                        /* dead dimension, zero stride */\n                        *dr = 0\n                    } else {\n                        return None;\n                    }\n                }\n\n                /* set remaining strides to zero */\n                for dr in new_stride_iter {\n                    *dr = 0;\n                }\n            }\n            Some(new_stride)\n        }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::collapse_axis":["/// Selects `index` along the axis, collapsing the axis into length one.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\npub fn collapse_axis(&mut self, axis: Axis, index: usize){\n        let offset = dimension::do_collapse_axis(&mut self.dim, &self.strides, axis.index(), index);\n        self.ptr = unsafe { self.ptr.offset(offset) };\n        debug_assert!(self.pointer_is_inbounds());\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::diag":["/// Return an view of the diagonal elements of the array.\n///\n/// The diagonal is simply the sequence indexed by *(0, 0, .., 0)*,\n/// *(1, 1, ..., 1)* etc as long as all axes have elements.\npub fn diag(&self) -> ArrayView1<'_, A>\n    where\n        S: Data,{\n        self.view().into_diag()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::diag_mut":["/// Return a read-write view over the diagonal elements of the array.\npub fn diag_mut(&mut self) -> ArrayViewMut1<'_, A>\n    where\n        S: DataMut,{\n        self.view_mut().into_diag()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::diag_params":["fn diag_params(&self) -> (Ix, Ixs){\n        /* empty shape has len 1 */\n        let len = self.dim.slice().iter().cloned().min().unwrap_or(1);\n        let stride = self.strides().iter().sum();\n        (len, stride)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::dim":["/// Return the shape of the array in its pattern form,\n/// an integer in the one-dimensional case, tuple in the n-dimensional cases\n/// and so on.\npub fn dim(&self) -> D::Pattern{\n        self.dim.clone().into_pattern()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::ensure_unique":["/// Make the array unshared.\n///\n/// This method is mostly only useful with unsafe code.\nfn ensure_unique(&mut self)\n    where\n        S: DataMut,{\n        debug_assert!(self.pointer_is_inbounds());\n        S::ensure_unique(self);\n        debug_assert!(self.pointer_is_inbounds());\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::exact_chunks":["/// Return an exact chunks producer (and iterable).\n///\n/// It produces the whole chunks of a given n-dimensional chunk size,\n/// skipping the remainder along each dimension that doesn't fit evenly.\n///\n/// The produced element is a `ArrayView<A, D>` with exactly the dimension\n/// `chunk_size`.\n///\n/// **Panics** if any dimension of `chunk_size` is zero<br>\n/// (**Panics** if `D` is `IxDyn` and `chunk_size` does not match the\n/// number of array axes.)\npub fn exact_chunks<E>(&self, chunk_size: E) -> ExactChunks<'_, A, D>\n    where\n        E: IntoDimension<Dim = D>,\n        S: Data,{\n        ExactChunks::new(self.view(), chunk_size)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::exact_chunks_mut":["/// Return an exact chunks producer (and iterable).\n///\n/// It produces the whole chunks of a given n-dimensional chunk size,\n/// skipping the remainder along each dimension that doesn't fit evenly.\n///\n/// The produced element is a `ArrayViewMut<A, D>` with exactly\n/// the dimension `chunk_size`.\n///\n/// **Panics** if any dimension of `chunk_size` is zero<br>\n/// (**Panics** if `D` is `IxDyn` and `chunk_size` does not match the\n/// number of array axes.)\n///\n/// ```rust\n/// use ndarray::Array;\n/// use ndarray::arr2;\n/// let mut a = Array::zeros((6, 7));\n///\n/// // Fill each 2  2 chunk with the index of where it appeared in iteration\n/// for (i, mut chunk) in a.exact_chunks_mut((2, 2)).into_iter().enumerate() {\n///     chunk.fill(i);\n/// }\n///\n/// // The resulting array is:\n/// assert_eq!(\n///   a,\n///   arr2(&[[0, 0, 1, 1, 2, 2, 0],\n///          [0, 0, 1, 1, 2, 2, 0],\n///          [3, 3, 4, 4, 5, 5, 0],\n///          [3, 3, 4, 4, 5, 5, 0],\n///          [6, 6, 7, 7, 8, 8, 0],\n///          [6, 6, 7, 7, 8, 8, 0]]));\n/// ```\npub fn exact_chunks_mut<E>(&mut self, chunk_size: E) -> ExactChunksMut<'_, A, D>\n    where\n        E: IntoDimension<Dim = D>,\n        S: DataMut,{\n        ExactChunksMut::new(self.view_mut(), chunk_size)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::fill":["/// Perform an elementwise assigment to `self` from element `x`.\npub fn fill(&mut self, x: A)\n    where\n        S: DataMut,\n        A: Clone,{\n        self.unordered_foreach_mut(move |elt| *elt = x.clone());\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::first":["/// Returns a reference to the first element of the array, or `None` if it\n/// is empty.\npub fn first(&self) -> Option<&A>\n    where\n        S: Data,{\n        if self.is_empty() {\n            None\n        } else {\n            Some(unsafe { &*self.as_ptr() })\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::first_mut":["/// Returns a mutable reference to the first element of the array, or\n/// `None` if it is empty.\npub fn first_mut(&mut self) -> Option<&mut A>\n    where\n        S: DataMut,{\n        if self.is_empty() {\n            None\n        } else {\n            Some(unsafe { &mut *self.as_mut_ptr() })\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::fold":["/// Traverse the array elements and apply a fold,\n/// returning the resulting value.\n///\n/// Elements are visited in arbitrary order.\npub fn fold<'a, F, B>(&'a self, init: B, f: F) -> B\n    where\n        F: FnMut(B, &'a A) -> B,\n        A: 'a,\n        S: Data,{\n        if let Some(slc) = self.as_slice_memory_order() {\n            slc.iter().fold(init, f)\n        } else {\n            let mut v = self.view();\n            // put the narrowest axis at the last position\n            match v.ndim() {\n                0 | 1 => {}\n                2 => {\n                    if self.len_of(Axis(1)) <= 1\n                        || self.len_of(Axis(0)) > 1\n                            && self.stride_of(Axis(0)).abs() < self.stride_of(Axis(1)).abs()\n                    {\n                        v.swap_axes(0, 1);\n                    }\n                }\n                n => {\n                    let last = n - 1;\n                    let narrow_axis = v\n                        .axes()\n                        .filter(|ax| ax.len() > 1)\n                        .min_by_key(|ax| ax.stride().abs())\n                        .map_or(last, |ax| ax.axis().index());\n                    v.swap_axes(last, narrow_axis);\n                }\n            }\n            v.into_elements_base().fold(init, f)\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::fold_axis":["/// Fold along an axis.\n///\n/// Combine the elements of each subview with the previous using the `fold`\n/// function and initial value `init`.\n///\n/// Return the result as an `Array`.\n///\n/// **Panics** if `axis` is out of bounds.\npub fn fold_axis<B, F>(&self, axis: Axis, init: B, mut fold: F) -> Array<B, D::Smaller>\n    where\n        D: RemoveAxis,\n        F: FnMut(&B, &A) -> B,\n        B: Clone,\n        S: Data,{\n        let mut res = Array::from_elem(self.raw_dim().remove_axis(axis), init);\n        for subview in self.axis_iter(axis) {\n            res.zip_mut_with(&subview, |x, y| *x = fold(x, y));\n        }\n        res\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::gencolumns":["/// Return a producer and iterable that traverses over the *generalized*\n/// columns of the array. For a 2D array these are the regular columns.\n///\n/// This is equivalent to `.lanes(Axis(0))`.\n///\n/// For an array of dimensions *a*  *b*  *c*  ...  *l*  *m*\n/// it has *b*  *c*  ...  *l*  *m* columns each of length *a*.\n///\n/// For example, in a 2  2  3 array, each column is 2 elements long\n/// and there are 2  3 = 6 columns in total.\n///\n/// Iterator element is `ArrayView1<A>` (1D array view).\n///\n/// ```\n/// use ndarray::{arr3, Axis, arr1};\n///\n/// // The generalized columns of a 3D array:\n/// // are directed along the 0th axis: 0 and 6, 1 and 7 and so on...\n/// let a = arr3(&[[[ 0,  1,  2], [ 3,  4,  5]],\n///                [[ 6,  7,  8], [ 9, 10, 11]]]);\n///\n/// // Here `gencolumns` will yield the six generalized columns of the array.\n/// for row in a.gencolumns() {\n///     /* loop body */\n/// }\n/// ```\npub fn gencolumns(&self) -> Lanes<'_, A, D::Smaller>\n    where\n        S: Data,{\n        Lanes::new(self.view(), Axis(0))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::gencolumns_mut":["/// Return a producer and iterable that traverses over the *generalized*\n/// columns of the array and yields mutable array views.\n///\n/// Iterator element is `ArrayView1<A>` (1D read-write array view).\npub fn gencolumns_mut(&mut self) -> LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,{\n        LanesMut::new(self.view_mut(), Axis(0))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::genrows":["/// Return a producer and iterable that traverses over the *generalized*\n/// rows of the array. For a 2D array these are the regular rows.\n///\n/// This is equivalent to `.lanes(Axis(n - 1))` where *n* is `self.ndim()`.\n///\n/// For an array of dimensions *a*  *b*  *c*  ...  *l*  *m*\n/// it has *a*  *b*  *c*  ...  *l* rows each of length *m*.\n///\n/// For example, in a 2  2  3 array, each row is 3 elements long\n/// and there are 2  2 = 4 rows in total.\n///\n/// Iterator element is `ArrayView1<A>` (1D array view).\n///\n/// ```\n/// use ndarray::{arr3, Axis, arr1};\n///\n/// let a = arr3(&[[[ 0,  1,  2],    // -- row 0, 0\n///                 [ 3,  4,  5]],   // -- row 0, 1\n///                [[ 6,  7,  8],    // -- row 1, 0\n///                 [ 9, 10, 11]]]); // -- row 1, 1\n///\n/// // `genrows` will yield the four generalized rows of the array.\n/// for row in a.genrows() {\n///     /* loop body */\n/// }\n/// ```\npub fn genrows(&self) -> Lanes<'_, A, D::Smaller>\n    where\n        S: Data,{\n        let mut n = self.ndim();\n        if n == 0 {\n            n += 1;\n        }\n        Lanes::new(self.view(), Axis(n - 1))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::genrows_mut":["/// Return a producer and iterable that traverses over the *generalized*\n/// rows of the array and yields mutable array views.\n///\n/// Iterator element is `ArrayView1<A>` (1D read-write array view).\npub fn genrows_mut(&mut self) -> LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,{\n        let mut n = self.ndim();\n        if n == 0 {\n            n += 1;\n        }\n        LanesMut::new(self.view_mut(), Axis(n - 1))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::get":["/// Return a reference to the element at `index`, or return `None`\n/// if the index is out of bounds.\n///\n/// Arrays also support indexing syntax: `array[index]`.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[1., 2.],\n///                [3., 4.]]);\n///\n/// assert!(\n///     a.get((0, 1)) == Some(&2.) &&\n///     a.get((0, 2)) == None &&\n///     a[(0, 1)] == 2. &&\n///     a[[0, 1]] == 2.\n/// );\n/// ```\npub fn get<I>(&self, index: I) -> Option<&A>\n    where\n        I: NdIndex<D>,\n        S: Data,{\n        unsafe { self.get_ptr(index).map(|ptr| &*ptr) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::get_0d":["fn get_0d(&self) -> &A\n    where\n        S: Data,{\n        assert!(self.ndim() == 0);\n        unsafe { &*self.as_ptr() }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::get_mut":["/// Return a mutable reference to the element at `index`, or return `None`\n/// if the index is out of bounds.\npub fn get_mut<I>(&mut self, index: I) -> Option<&mut A>\n    where\n        S: DataMut,\n        I: NdIndex<D>,{\n        unsafe { self.get_ptr_mut(index).map(|ptr| &mut *ptr) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::get_ptr":["pub(crate) fn get_ptr<I>(&self, index: I) -> Option<*const A>\n    where\n        I: NdIndex<D>,{\n        let ptr = self.ptr;\n        index\n            .index_checked(&self.dim, &self.strides)\n            .map(move |offset| unsafe { ptr.as_ptr().offset(offset) as *const _ })\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::get_ptr_mut":["pub(crate) fn get_ptr_mut<I>(&mut self, index: I) -> Option<*mut A>\n    where\n        S: RawDataMut,\n        I: NdIndex<D>,{\n        // const and mut are separate to enforce &mutness as well as the\n        // extra code in as_mut_ptr\n        let ptr = self.as_mut_ptr();\n        index\n            .index_checked(&self.dim, &self.strides)\n            .map(move |offset| unsafe { ptr.offset(offset) })\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::index_axis":["/// Returns a view restricted to `index` along the axis, with the axis\n/// removed.\n///\n/// See [*Subviews*](#subviews) for full documentation.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\n///\n/// ```\n/// use ndarray::{arr2, ArrayView, Axis};\n///\n/// let a = arr2(&[[1., 2. ],    // ... axis 0, row 0\n///                [3., 4. ],    // --- axis 0, row 1\n///                [5., 6. ]]);  // ... axis 0, row 2\n/// //               .   \\\n/// //                .   axis 1, column 1\n/// //                 axis 1, column 0\n/// assert!(\n///     a.index_axis(Axis(0), 1) == ArrayView::from(&[3., 4.]) &&\n///     a.index_axis(Axis(1), 1) == ArrayView::from(&[2., 4., 6.])\n/// );\n/// ```\npub fn index_axis(&self, axis: Axis, index: usize) -> ArrayView<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,{\n        self.view().index_axis_move(axis, index)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::index_axis_move":["/// Collapses the array to `index` along the axis and removes the axis.\n///\n/// See [`.index_axis()`](#method.index_axis) and [*Subviews*](#subviews) for full documentation.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\npub fn index_axis_move(mut self, axis: Axis, index: usize) -> ArrayBase<S, D::Smaller>\n    where\n        D: RemoveAxis,{\n        self.collapse_axis(axis, index);\n        let dim = self.dim.remove_axis(axis);\n        let strides = self.strides.remove_axis(axis);\n        ArrayBase {\n            ptr: self.ptr,\n            data: self.data,\n            dim,\n            strides,\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::index_axis_mut":["/// Returns a mutable view restricted to `index` along the axis, with the\n/// axis removed.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\n///\n/// ```\n/// use ndarray::{arr2, aview2, Axis};\n///\n/// let mut a = arr2(&[[1., 2. ],\n///                    [3., 4. ]]);\n/// //                   .   \\\n/// //                    .   axis 1, column 1\n/// //                     axis 1, column 0\n///\n/// {\n///     let mut column1 = a.index_axis_mut(Axis(1), 1);\n///     column1 += 10.;\n/// }\n///\n/// assert!(\n///     a == aview2(&[[1., 12.],\n///                   [3., 14.]])\n/// );\n/// ```\npub fn index_axis_mut(&mut self, axis: Axis, index: usize) -> ArrayViewMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,{\n        self.view_mut().index_axis_move(axis, index)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::indexed_iter":["/// Return an iterator of indexes and references to the elements of the array.\n///\n/// Elements are visited in the *logical order* of the array, which\n/// is where the rightmost index is varying the fastest.\n///\n/// Iterator element type is `(D::Pattern, &A)`.\n///\n/// See also [`Zip::indexed`](struct.Zip.html)\npub fn indexed_iter(&self) -> IndexedIter<'_, A, D>\n    where\n        S: Data,{\n        IndexedIter::new(self.view().into_elements_base())\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::indexed_iter_mut":["/// Return an iterator of indexes and mutable references to the elements of the array.\n///\n/// Elements are visited in the *logical order* of the array, which\n/// is where the rightmost index is varying the fastest.\n///\n/// Iterator element type is `(D::Pattern, &mut A)`.\npub fn indexed_iter_mut(&mut self) -> IndexedIterMut<'_, A, D>\n    where\n        S: DataMut,{\n        IndexedIterMut::new(self.view_mut().into_elements_base())\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::insert_axis":["/// Insert new array axis at `axis` and return the result.\n///\n/// ```\n/// use ndarray::{Array3, Axis, arr1, arr2};\n///\n/// // Convert a 1-D array into a row vector (2-D).\n/// let a = arr1(&[1, 2, 3]);\n/// let row = a.insert_axis(Axis(0));\n/// assert_eq!(row, arr2(&[[1, 2, 3]]));\n///\n/// // Convert a 1-D array into a column vector (2-D).\n/// let b = arr1(&[1, 2, 3]);\n/// let col = b.insert_axis(Axis(1));\n/// assert_eq!(col, arr2(&[[1], [2], [3]]));\n///\n/// // The new axis always has length 1.\n/// let b = Array3::<f64>::zeros((3, 4, 5));\n/// assert_eq!(b.insert_axis(Axis(2)).shape(), &[3, 4, 1, 5]);\n/// ```\n///\n/// ***Panics*** if the axis is out of bounds.\npub fn insert_axis(self, axis: Axis) -> ArrayBase<S, D::Larger>{\n        assert!(axis.index() <= self.ndim());\n        let ArrayBase {\n            ptr,\n            data,\n            dim,\n            strides,\n        } = self;\n        ArrayBase {\n            ptr,\n            data,\n            dim: dim.insert_axis(axis),\n            strides: strides.insert_axis(axis),\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_diag":["/// Return the diagonal as a one-dimensional array.\npub fn into_diag(self) -> ArrayBase<S, Ix1>{\n        let (len, stride) = self.diag_params();\n        ArrayBase {\n            data: self.data,\n            ptr: self.ptr,\n            dim: Ix1(len),\n            strides: Ix1(stride as Ix),\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_dimensionality":["/// Convert an array or array view to another with the same type, but\n/// different dimensionality type. Errors if the dimensions don't agree.\n///\n/// ```\n/// use ndarray::{ArrayD, Ix2, IxDyn};\n///\n/// // Create a dynamic dimensionality array and convert it to an Array2\n/// // (Ix2 dimension type).\n///\n/// let array = ArrayD::<f64>::zeros(IxDyn(&[10, 10]));\n///\n/// assert!(array.into_dimensionality::<Ix2>().is_ok());\n/// ```\npub fn into_dimensionality<D2>(self) -> Result<ArrayBase<S, D2>, ShapeError>\n    where\n        D2: Dimension,{\n        if let Some(dim) = D2::from_dimension(&self.dim) {\n            if let Some(strides) = D2::from_dimension(&self.strides) {\n                return Ok(ArrayBase {\n                    data: self.data,\n                    ptr: self.ptr,\n                    dim,\n                    strides,\n                });\n            }\n        }\n        Err(ShapeError::from_kind(ErrorKind::IncompatibleShape))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_dyn":["/// Convert any array or array view to a dynamic dimensional array or\n/// array view (respectively).\n///\n/// ```\n/// use ndarray::{arr2, ArrayD};\n///\n/// let array: ArrayD<i32> = arr2(&[[1, 2],\n///                                 [3, 4]]).into_dyn();\n/// ```\npub fn into_dyn(self) -> ArrayBase<S, IxDyn>{\n        ArrayBase {\n            data: self.data,\n            ptr: self.ptr,\n            dim: self.dim.into_dyn(),\n            strides: self.strides.into_dyn(),\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_owned":["/// Turn the array into a uniquely owned array, cloning the array elements\n/// if necessary.\npub fn into_owned(self) -> Array<A, D>\n    where\n        A: Clone,\n        S: Data,{\n        S::into_owned(self)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_shape":["/// Transform the array into `shape`; any shape with the same number of\n/// elements is accepted, but the source array or view must be in standard\n/// or column-major (Fortran) layout.\n///\n/// **Errors** if the shapes don't have the same number of elements.<br>\n/// **Errors** if the input array is not c- or f-contiguous.\n///\n/// ```\n/// use ndarray::{aview1, aview2};\n///\n/// assert!(\n///     aview1(&[1., 2., 3., 4.]).into_shape((2, 2)).unwrap()\n///     == aview2(&[[1., 2.],\n///                 [3., 4.]])\n/// );\n/// ```\npub fn into_shape<E>(self, shape: E) -> Result<ArrayBase<S, E::Dim>, ShapeError>\n    where\n        E: IntoDimension,{\n        let shape = shape.into_dimension();\n        if size_of_shape_checked(&shape) != Ok(self.dim.size()) {\n            return Err(error::incompatible_shapes(&self.dim, &shape));\n        }\n        // Check if contiguous, if not => copy all, else just adapt strides\n        if self.is_standard_layout() {\n            Ok(ArrayBase {\n                data: self.data,\n                ptr: self.ptr,\n                strides: shape.default_strides(),\n                dim: shape,\n            })\n        } else if self.ndim() > 1 && self.raw_view().reversed_axes().is_standard_layout() {\n            Ok(ArrayBase {\n                data: self.data,\n                ptr: self.ptr,\n                strides: shape.fortran_strides(),\n                dim: shape,\n            })\n        } else {\n            Err(error::from_kind(error::ErrorKind::IncompatibleLayout))\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_shared":["/// Turn the array into a shared ownership (copy on write) array,\n/// without any copying.\npub fn into_shared(self) -> ArcArray<A, D>\n    where\n        S: DataOwned,{\n        let data = self.data.into_shared();\n        ArrayBase {\n            data,\n            ptr: self.ptr,\n            dim: self.dim,\n            strides: self.strides,\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::into_subview":["/// Along `axis`, select the subview `index` and return `self`\n/// with that axis removed.\n#[deprecated(note = \"renamed to `index_axis_move`\", since = \"0.12.1\")]\npub fn into_subview(self, axis: Axis, index: Ix) -> ArrayBase<S, D::Smaller>\n    where\n        D: RemoveAxis,{\n        self.index_axis_move(axis, index)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::invert_axis":["/// Reverse the stride of `axis`.\n///\n/// ***Panics*** if the axis is out of bounds.\npub fn invert_axis(&mut self, axis: Axis){\n        unsafe {\n            let s = self.strides.axis(axis) as Ixs;\n            let m = self.dim.axis(axis);\n            if m != 0 {\n                self.ptr = self.ptr.offset(stride_offset(m - 1, s as Ix));\n            }\n            self.strides.set_axis(axis, (-s) as Ix);\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::is_contiguous":["fn is_contiguous(&self) -> bool{\n        D::is_contiguous(&self.dim, &self.strides)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::is_empty":["/// Return whether the array has any elements\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::is_standard_layout":["/// Return `true` if the array data is laid out in contiguous C order in\n/// memory (where the last index is the most rapidly varying).\n///\n/// Return `false` otherwise, i.e the array is possibly not\n/// contiguous in memory, it has custom strides, etc.\npub fn is_standard_layout(&self) -> bool{\n        fn is_standard_layout<D: Dimension>(dim: &D, strides: &D) -> bool {\n            if let Some(1) = D::NDIM {\n                return strides[0] == 1 || dim[0] <= 1;\n            }\n            if dim.slice().iter().any(|&d| d == 0) {\n                return true;\n            }\n            let defaults = dim.default_strides();\n            // check all dimensions -- a dimension of length 1 can have unequal strides\n            for (&dim, &s, &ds) in izip!(dim.slice(), strides.slice(), defaults.slice()) {\n                if dim != 1 && s != ds {\n                    return false;\n                }\n            }\n            true\n        }\n        is_standard_layout(&self.dim, &self.strides)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::is_standard_layout::is_standard_layout":["fn is_standard_layout<D: Dimension>(dim: &D, strides: &D) -> bool{\n            if let Some(1) = D::NDIM {\n                return strides[0] == 1 || dim[0] <= 1;\n            }\n            if dim.slice().iter().any(|&d| d == 0) {\n                return true;\n            }\n            let defaults = dim.default_strides();\n            // check all dimensions -- a dimension of length 1 can have unequal strides\n            for (&dim, &s, &ds) in izip!(dim.slice(), strides.slice(), defaults.slice()) {\n                if dim != 1 && s != ds {\n                    return false;\n                }\n            }\n            true\n        }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::iter":["/// Return an iterator of references to the elements of the array.\n///\n/// Elements are visited in the *logical order* of the array, which\n/// is where the rightmost index is varying the fastest.\n///\n/// Iterator element type is `&A`.\npub fn iter(&self) -> Iter<'_, A, D>\n    where\n        S: Data,{\n        debug_assert!(self.pointer_is_inbounds());\n        self.view().into_iter_()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::iter_mut":["/// Return an iterator of mutable references to the elements of the array.\n///\n/// Elements are visited in the *logical order* of the array, which\n/// is where the rightmost index is varying the fastest.\n///\n/// Iterator element type is `&mut A`.\npub fn iter_mut(&mut self) -> IterMut<'_, A, D>\n    where\n        S: DataMut,{\n        self.view_mut().into_iter_()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::lanes":["/// Return a producer and iterable that traverses over all 1D lanes\n/// pointing in the direction of `axis`.\n///\n/// When the pointing in the direction of the first axis, they are *columns*,\n/// in the direction of the last axis *rows*; in general they are all\n/// *lanes* and are one dimensional.\n///\n/// Iterator element is `ArrayView1<A>` (1D array view).\n///\n/// ```\n/// use ndarray::{arr3, aview1, Axis};\n///\n/// let a = arr3(&[[[ 0,  1,  2],\n///                 [ 3,  4,  5]],\n///                [[ 6,  7,  8],\n///                 [ 9, 10, 11]]]);\n///\n/// let inner0 = a.lanes(Axis(0));\n/// let inner1 = a.lanes(Axis(1));\n/// let inner2 = a.lanes(Axis(2));\n///\n/// // The first lane for axis 0 is [0, 6]\n/// assert_eq!(inner0.into_iter().next().unwrap(), aview1(&[0, 6]));\n/// // The first lane for axis 1 is [0, 3]\n/// assert_eq!(inner1.into_iter().next().unwrap(), aview1(&[0, 3]));\n/// // The first lane for axis 2 is [0, 1, 2]\n/// assert_eq!(inner2.into_iter().next().unwrap(), aview1(&[0, 1, 2]));\n/// ```\npub fn lanes(&self, axis: Axis) -> Lanes<'_, A, D::Smaller>\n    where\n        S: Data,{\n        Lanes::new(self.view(), axis)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::lanes_mut":["/// Return a producer and iterable that traverses over all 1D lanes\n/// pointing in the direction of `axis`.\n///\n/// Iterator element is `ArrayViewMut1<A>` (1D read-write array view).\npub fn lanes_mut(&mut self, axis: Axis) -> LanesMut<'_, A, D::Smaller>\n    where\n        S: DataMut,{\n        LanesMut::new(self.view_mut(), axis)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::len":["/// Return the total number of elements in the array.\npub fn len(&self) -> usize{\n        self.dim.size()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::len_of":["/// Return the length of `axis`.\n///\n/// The axis should be in the range `Axis(` 0 .. *n* `)` where *n* is the\n/// number of dimensions (axes) of the array.\n///\n/// ***Panics*** if the axis is out of bounds.\npub fn len_of(&self, axis: Axis) -> usize{\n        self.dim[axis.index()]\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::map":["/// Call `f` by reference on each element and create a new array\n/// with the new values.\n///\n/// Elements are visited in arbitrary order.\n///\n/// Return an array with the same shape as `self`.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[ 0., 1.],\n///                [-1., 2.]]);\n/// assert!(\n///     a.map(|x| *x >= 1.0)\n///     == arr2(&[[false, true],\n///               [false, true]])\n/// );\n/// ```\npub fn map<'a, B, F>(&'a self, f: F) -> Array<B, D>\n    where\n        F: FnMut(&'a A) -> B,\n        A: 'a,\n        S: Data,{\n        if let Some(slc) = self.as_slice_memory_order() {\n            let v = crate::iterators::to_vec_mapped(slc.iter(), f);\n            unsafe {\n                ArrayBase::from_shape_vec_unchecked(\n                    self.dim.clone().strides(self.strides.clone()),\n                    v,\n                )\n            }\n        } else {\n            let v = crate::iterators::to_vec_mapped(self.iter(), f);\n            unsafe { ArrayBase::from_shape_vec_unchecked(self.dim.clone(), v) }\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::map_axis":["/// Reduce the values along an axis into just one value, producing a new\n/// array with one less dimension.\n///\n/// Elements are visited in arbitrary order.\n///\n/// Return the result as an `Array`.\n///\n/// **Panics** if `axis` is out of bounds.\npub fn map_axis<'a, B, F>(&'a self, axis: Axis, mut mapping: F) -> Array<B, D::Smaller>\n    where\n        D: RemoveAxis,\n        F: FnMut(ArrayView1<'a, A>) -> B,\n        A: 'a,\n        S: Data,{\n        let view_len = self.len_of(axis);\n        let view_stride = self.strides.axis(axis);\n        if view_len == 0 {\n            let new_dim = self.dim.remove_axis(axis);\n            Array::from_shape_simple_fn(new_dim, move || mapping(ArrayView::from(&[])))\n        } else {\n            // use the 0th subview as a map to each 1d array view extended from\n            // the 0th element.\n            self.index_axis(axis, 0).map(|first_elt| unsafe {\n                mapping(ArrayView::new_(first_elt, Ix1(view_len), Ix1(view_stride)))\n            })\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::map_axis_mut":["/// Reduce the values along an axis into just one value, producing a new\n/// array with one less dimension.\n/// 1-dimensional lanes are passed as mutable references to the reducer,\n/// allowing for side-effects.\n///\n/// Elements are visited in arbitrary order.\n///\n/// Return the result as an `Array`.\n///\n/// **Panics** if `axis` is out of bounds.\npub fn map_axis_mut<'a, B, F>(&'a mut self, axis: Axis, mut mapping: F) -> Array<B, D::Smaller>\n    where\n        D: RemoveAxis,\n        F: FnMut(ArrayViewMut1<'a, A>) -> B,\n        A: 'a,\n        S: DataMut,{\n        let view_len = self.len_of(axis);\n        let view_stride = self.strides.axis(axis);\n        if view_len == 0 {\n            let new_dim = self.dim.remove_axis(axis);\n            Array::from_shape_simple_fn(new_dim, move || mapping(ArrayViewMut::from(&mut [])))\n        } else {\n            // use the 0th subview as a map to each 1d array view extended from\n            // the 0th element.\n            self.index_axis_mut(axis, 0).map_mut(|first_elt| unsafe {\n                mapping(ArrayViewMut::new_(\n                    first_elt,\n                    Ix1(view_len),\n                    Ix1(view_stride),\n                ))\n            })\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::map_inplace":["/// Modify the array in place by calling `f` by mutable reference on each element.\n///\n/// Elements are visited in arbitrary order.\npub fn map_inplace<F>(&mut self, f: F)\n    where\n        S: DataMut,\n        F: FnMut(&mut A),{\n        self.unordered_foreach_mut(f);\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::map_mut":["/// Call `f` on a mutable reference of each element and create a new array\n/// with the new values.\n///\n/// Elements are visited in arbitrary order.\n///\n/// Return an array with the same shape as `self`.\npub fn map_mut<'a, B, F>(&'a mut self, f: F) -> Array<B, D>\n    where\n        F: FnMut(&'a mut A) -> B,\n        A: 'a,\n        S: DataMut,{\n        let dim = self.dim.clone();\n        if self.is_contiguous() {\n            let strides = self.strides.clone();\n            let slc = self.as_slice_memory_order_mut().unwrap();\n            let v = crate::iterators::to_vec_mapped(slc.iter_mut(), f);\n            unsafe { ArrayBase::from_shape_vec_unchecked(dim.strides(strides), v) }\n        } else {\n            let v = crate::iterators::to_vec_mapped(self.iter_mut(), f);\n            unsafe { ArrayBase::from_shape_vec_unchecked(dim, v) }\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::mapv":["/// Call `f` by **v**alue on each element and create a new array\n/// with the new values.\n///\n/// Elements are visited in arbitrary order.\n///\n/// Return an array with the same shape as `self`.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[ 0., 1.],\n///                [-1., 2.]]);\n/// assert!(\n///     a.mapv(f32::abs) == arr2(&[[0., 1.],\n///                                [1., 2.]])\n/// );\n/// ```\npub fn mapv<B, F>(&self, mut f: F) -> Array<B, D>\n    where\n        F: FnMut(A) -> B,\n        A: Clone,\n        S: Data,{\n        self.map(move |x| f(x.clone()))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::mapv_inplace":["/// Modify the array in place by calling `f` by **v**alue on each element.\n/// The array is updated with the new values.\n///\n/// Elements are visited in arbitrary order.\n///\n/// ```\n/// use approx::assert_abs_diff_eq;\n/// use ndarray::arr2;\n///\n/// # #[cfg(feature = \"approx\")] {\n/// let mut a = arr2(&[[ 0., 1.],\n///                    [-1., 2.]]);\n/// a.mapv_inplace(f32::exp);\n/// assert_abs_diff_eq!(\n///     a,\n///     arr2(&[[1.00000, 2.71828],\n///            [0.36788, 7.38906]]),\n///     epsilon = 1e-5,\n/// );\n/// # }\n/// ```\npub fn mapv_inplace<F>(&mut self, mut f: F)\n    where\n        S: DataMut,\n        F: FnMut(A) -> A,\n        A: Clone,{\n        self.unordered_foreach_mut(move |x| *x = f(x.clone()));\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::mapv_into":["/// Call `f` by **v**alue on each element, update the array with the new values\n/// and return it.\n///\n/// Elements are visited in arbitrary order.\npub fn mapv_into<F>(mut self, f: F) -> Self\n    where\n        S: DataMut,\n        F: FnMut(A) -> A,\n        A: Clone,{\n        self.mapv_inplace(f);\n        self\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::max_stride_axis":["/// Return the axis with the greatest stride (by absolute value),\n/// preferring axes with len > 1.\npub fn max_stride_axis(&self) -> Axis{\n        self.dim.max_stride_axis(&self.strides)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::merge_axes":["/// If possible, merge in the axis `take` to `into`.\n///\n/// Returns `true` iff the axes are now merged.\n///\n/// This method merges the axes if movement along the two original axes\n/// (moving fastest along the `into` axis) can be equivalently represented\n/// as movement along one (merged) axis. Merging the axes preserves this\n/// order in the merged axis. If `take` and `into` are the same axis, then\n/// the axis is \"merged\" if its length is  1.\n///\n/// If the return value is `true`, then the following hold:\n///\n/// * The new length of the `into` axis is the product of the original\n///   lengths of the two axes.\n///\n/// * The new length of the `take` axis is 0 if the product of the original\n///   lengths of the two axes is 0, and 1 otherwise.\n///\n/// If the return value is `false`, then merging is not possible, and the\n/// original shape and strides have been preserved.\n///\n/// Note that the ordering constraint means that if it's possible to merge\n/// `take` into `into`, it's usually not possible to merge `into` into\n/// `take`, and vice versa.\n///\n/// ```\n/// use ndarray::Array3;\n/// use ndarray::Axis;\n///\n/// let mut a = Array3::<f64>::zeros((2, 3, 4));\n/// assert!(a.merge_axes(Axis(1), Axis(2)));\n/// assert_eq!(a.shape(), &[2, 1, 12]);\n/// ```\n///\n/// ***Panics*** if an axis is out of bounds.\npub fn merge_axes(&mut self, take: Axis, into: Axis) -> bool{\n        merge_axes(&mut self.dim, &mut self.strides, take, into)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::multi_slice_mut":["/// Return multiple disjoint, sliced, mutable views of the array.\n///\n/// See [*Slicing*](#slicing) for full documentation.\n/// See also [`SliceInfo`] and [`D::SliceArg`].\n///\n/// [`SliceInfo`]: struct.SliceInfo.html\n/// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n///\n/// **Panics** if any of the following occur:\n///\n/// * if any of the views would intersect (i.e. if any element would appear in multiple slices)\n/// * if an index is out of bounds or step size is zero\n/// * if `D` is `IxDyn` and `info` does not match the number of array axes\n///\n/// # Example\n///\n/// ```\n/// use ndarray::{arr2, s};\n///\n/// let mut a = arr2(&[[1, 2, 3], [4, 5, 6]]);\n/// let (mut edges, mut middle) = a.multi_slice_mut((s![.., ..;2], s![.., 1]));\n/// edges.fill(1);\n/// middle.fill(0);\n/// assert_eq!(a, arr2(&[[1, 0, 1], [1, 0, 1]]));\n/// ```\npub fn multi_slice_mut<'a, M>(&'a mut self, info: M) -> M::Output\n    where\n        M: MultiSlice<'a, A, D>,\n        S: DataMut,{\n        info.multi_slice_move(self.view_mut())\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::ndim":["/// Return the number of dimensions (axes) in the array\npub fn ndim(&self) -> usize{\n        self.dim.ndim()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::outer_iter":["/// Return an iterator that traverses over the outermost dimension\n/// and yields each subview.\n///\n/// This is equivalent to `.axis_iter(Axis(0))`.\n///\n/// Iterator element is `ArrayView<A, D::Smaller>` (read-only array view).\n#[allow(deprecated)]\npub fn outer_iter(&self) -> AxisIter<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,{\n        self.view().into_outer_iter()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::outer_iter_mut":["/// Return an iterator that traverses over the outermost dimension\n/// and yields each subview.\n///\n/// This is equivalent to `.axis_iter_mut(Axis(0))`.\n///\n/// Iterator element is `ArrayViewMut<A, D::Smaller>` (read-write array view).\n#[allow(deprecated)]\npub fn outer_iter_mut(&mut self) -> AxisIterMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,{\n        self.view_mut().into_outer_iter()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::permuted_axes":["/// Permute the axes.\n///\n/// This does not move any data, it just adjusts the arrays dimensions\n/// and strides.\n///\n/// *i* in the *j*-th place in the axes sequence means `self`'s *i*-th axis\n/// becomes `self.permuted_axes()`'s *j*-th axis\n///\n/// **Panics** if any of the axes are out of bounds, if an axis is missing,\n/// or if an axis is repeated more than once.\n///\n/// # Examples\n///\n/// ```\n/// use ndarray::{arr2, Array3};\n///\n/// let a = arr2(&[[0, 1], [2, 3]]);\n/// assert_eq!(a.view().permuted_axes([1, 0]), a.t());\n///\n/// let b = Array3::<u8>::zeros((1, 2, 3));\n/// assert_eq!(b.permuted_axes([1, 0, 2]).shape(), &[2, 1, 3]);\n/// ```\npub fn permuted_axes<T>(self, axes: T) -> ArrayBase<S, D>\n    where\n        T: IntoDimension<Dim = D>,{\n        let axes = axes.into_dimension();\n        // Ensure that each axis is used exactly once.\n        let mut usage_counts = D::zeros(self.ndim());\n        for axis in axes.slice() {\n            usage_counts[*axis] += 1;\n        }\n        for count in usage_counts.slice() {\n            assert_eq!(*count, 1, \"each axis must be listed exactly once\");\n        }\n        // Determine the new shape and strides.\n        let mut new_dim = usage_counts; // reuse to avoid an allocation\n        let mut new_strides = D::zeros(self.ndim());\n        {\n            let dim = self.dim.slice();\n            let strides = self.strides.slice();\n            for (new_axis, &axis) in axes.slice().iter().enumerate() {\n                new_dim[new_axis] = dim[axis];\n                new_strides[new_axis] = strides[axis];\n            }\n        }\n        ArrayBase {\n            dim: new_dim,\n            strides: new_strides,\n            ..self\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::pointer_is_inbounds":["fn pointer_is_inbounds(&self) -> bool{\n        match self.data._data_slice() {\n            None => {\n                // special case for non-owned views\n                true\n            }\n            Some(slc) => {\n                let ptr = slc.as_ptr() as *mut A;\n                let end = unsafe { ptr.add(slc.len()) };\n                self.ptr.as_ptr() >= ptr && self.ptr.as_ptr() <= end\n            }\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::raw_dim":["/// Return the shape of the array as it stored in the array.\n///\n/// This is primarily useful for passing to other `ArrayBase`\n/// functions, such as when creating another array of the same\n/// shape and dimensionality.\n///\n/// ```\n/// use ndarray::Array;\n///\n/// let a = Array::from_elem((2, 3), 5.);\n///\n/// // Create an array of zeros that's the same shape and dimensionality as `a`.\n/// let b = Array::<f64, _>::zeros(a.raw_dim());\n/// ```\npub fn raw_dim(&self) -> D{\n        self.dim.clone()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::raw_view":["/// Return a raw view of the array.\n#[inline]\npub fn raw_view(&self) -> RawArrayView<A, D>{\n        unsafe { RawArrayView::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::raw_view_mut":["/// Return a raw mutable view of the array.\n#[inline]\npub fn raw_view_mut(&mut self) -> RawArrayViewMut<A, D>\n    where\n        S: RawDataMut,{\n        self.try_ensure_unique(); // for RcArray\n        unsafe { RawArrayViewMut::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::remove_axis":["/// Remove array axis `axis` and return the result.\n///\n/// **Panics** if the axis is out of bounds or its length is zero.\n#[deprecated(note = \"use `.index_axis_move(Axis(_), 0)` instead\", since = \"0.12.1\")]\npub fn remove_axis(self, axis: Axis) -> ArrayBase<S, D::Smaller>\n    where\n        D: RemoveAxis,{\n        self.index_axis_move(axis, 0)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::reshape":["/// *Note: Reshape is for `ArcArray` only. Use `.into_shape()` for\n/// other arrays and array views.*\n///\n/// Transform the array into `shape`; any shape with the same number of\n/// elements is accepted.\n///\n/// May clone all elements if needed to arrange elements in standard\n/// layout (and break sharing).\n///\n/// **Panics** if shapes are incompatible.\n///\n/// ```\n/// use ndarray::{rcarr1, rcarr2};\n///\n/// assert!(\n///     rcarr1(&[1., 2., 3., 4.]).reshape((2, 2))\n///     == rcarr2(&[[1., 2.],\n///                 [3., 4.]])\n/// );\n/// ```\npub fn reshape<E>(&self, shape: E) -> ArrayBase<S, E::Dim>\n    where\n        S: DataShared + DataOwned,\n        A: Clone,\n        E: IntoDimension,{\n        let shape = shape.into_dimension();\n        if size_of_shape_checked(&shape) != Ok(self.dim.size()) {\n            panic!(\n                \"ndarray: incompatible shapes in reshape, attempted from: {:?}, to: {:?}\",\n                self.dim.slice(),\n                shape.slice()\n            )\n        }\n        // Check if contiguous, if not => copy all, else just adapt strides\n        if self.is_standard_layout() {\n            let cl = self.clone();\n            ArrayBase {\n                data: cl.data,\n                ptr: cl.ptr,\n                strides: shape.default_strides(),\n                dim: shape,\n            }\n        } else {\n            let v = self.iter().cloned().collect::<Vec<A>>();\n            unsafe { ArrayBase::from_shape_vec_unchecked(shape, v) }\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::reversed_axes":["/// Transpose the array by reversing axes.\n///\n/// Transposition reverses the order of the axes (dimensions and strides)\n/// while retaining the same data.\npub fn reversed_axes(mut self) -> ArrayBase<S, D>{\n        self.dim.slice_mut().reverse();\n        self.strides.slice_mut().reverse();\n        self\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::select":["/// Along `axis`, select arbitrary subviews corresponding to `indices`\n/// and and copy them into a new array.\n///\n/// **Panics** if `axis` or an element of `indices` is out of bounds.\n///\n/// ```\n/// use ndarray::{arr2, Axis};\n///\n/// let x = arr2(&[[0., 1.],\n///                [2., 3.],\n///                [4., 5.],\n///                [6., 7.],\n///                [8., 9.]]);\n///\n/// let r = x.select(Axis(0), &[0, 4, 3]);\n/// assert!(\n///         r == arr2(&[[0., 1.],\n///                     [8., 9.],\n///                     [6., 7.]])\n///);\n/// ```\npub fn select(&self, axis: Axis, indices: &[Ix]) -> Array<A, D>\n    where\n        A: Copy,\n        S: Data,\n        D: RemoveAxis,{\n        let mut subs = vec![self.view(); indices.len()];\n        for (&i, sub) in zip(indices, &mut subs[..]) {\n            sub.collapse_axis(axis, i);\n        }\n        if subs.is_empty() {\n            let mut dim = self.raw_dim();\n            dim.set_axis(axis, 0);\n            unsafe { Array::from_shape_vec_unchecked(dim, vec![]) }\n        } else {\n            stack(axis, &subs).unwrap()\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::shape":["/// Return the shape of the array as a slice.\n///\n/// Note that you probably don't want to use this to create an array of the\n/// same shape as another array because creating an array with e.g.\n/// [`Array::zeros()`](ArrayBase::zeros) using a shape of type `&[usize]`\n/// results in a dynamic-dimensional array. If you want to create an array\n/// that has the same shape and dimensionality as another array, use\n/// [`.raw_dim()`](ArrayBase::raw_dim) instead:\n///\n/// ```rust\n/// use ndarray::{Array, Array2};\n///\n/// let a = Array2::<i32>::zeros((3, 4));\n/// let shape = a.shape();\n/// assert_eq!(shape, &[3, 4]);\n///\n/// // Since `a.shape()` returned `&[usize]`, we get an `ArrayD` instance:\n/// let b = Array::zeros(shape);\n/// assert_eq!(a.clone().into_dyn(), b);\n///\n/// // To get the same dimension type, use `.raw_dim()` instead:\n/// let c = Array::zeros(a.raw_dim());\n/// assert_eq!(a, c);\n/// ```\npub fn shape(&self) -> &[usize]{\n        self.dim.slice()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice":["/// Return a sliced view of the array.\n///\n/// See [*Slicing*](#slicing) for full documentation.\n/// See also [`SliceInfo`] and [`D::SliceArg`].\n///\n/// [`SliceInfo`]: struct.SliceInfo.html\n/// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// (**Panics** if `D` is `IxDyn` and `info` does not match the number of array axes.)\npub fn slice<Do>(&self, info: &SliceInfo<D::SliceArg, Do>) -> ArrayView<'_, A, Do>\n    where\n        Do: Dimension,\n        S: Data,{\n        self.view().slice_move(info)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_axis":["/// Return a view of the array, sliced along the specified axis.\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// **Panics** if `axis` is out of bounds.\npub fn slice_axis(&self, axis: Axis, indices: Slice) -> ArrayView<'_, A, D>\n    where\n        S: Data,{\n        let mut view = self.view();\n        view.slice_axis_inplace(axis, indices);\n        view\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_axis_inplace":["/// Slice the array in place along the specified axis.\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// **Panics** if `axis` is out of bounds.\npub fn slice_axis_inplace(&mut self, axis: Axis, indices: Slice){\n        let offset = do_slice(\n            &mut self.dim.slice_mut()[axis.index()],\n            &mut self.strides.slice_mut()[axis.index()],\n            indices,\n        );\n        unsafe {\n            self.ptr = self.ptr.offset(offset);\n        }\n        debug_assert!(self.pointer_is_inbounds());\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_axis_mut":["/// Return a mutable view of the array, sliced along the specified axis.\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// **Panics** if `axis` is out of bounds.\npub fn slice_axis_mut(&mut self, axis: Axis, indices: Slice) -> ArrayViewMut<'_, A, D>\n    where\n        S: DataMut,{\n        let mut view_mut = self.view_mut();\n        view_mut.slice_axis_inplace(axis, indices);\n        view_mut\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_collapse":["/// Slice the array in place without changing the number of dimensions.\n///\n/// Note that [`&SliceInfo`](struct.SliceInfo.html) (produced by the\n/// [`s![]`](macro.s!.html) macro) will usually coerce into `&D::SliceArg`\n/// automatically, but in some cases (e.g. if `D` is `IxDyn`), you may need\n/// to call `.as_ref()`.\n///\n/// See [*Slicing*](#slicing) for full documentation.\n/// See also [`D::SliceArg`].\n///\n/// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// (**Panics** if `D` is `IxDyn` and `indices` does not match the number of array axes.)\npub fn slice_collapse(&mut self, indices: &D::SliceArg){\n        let indices: &[SliceOrIndex] = indices.as_ref();\n        assert_eq!(indices.len(), self.ndim());\n        indices\n            .iter()\n            .enumerate()\n            .for_each(|(axis, &slice_or_index)| match slice_or_index {\n                SliceOrIndex::Slice { start, end, step } => {\n                    self.slice_axis_inplace(Axis(axis), Slice { start, end, step })\n                }\n                SliceOrIndex::Index(index) => {\n                    let i_usize = abs_index(self.len_of(Axis(axis)), index);\n                    self.collapse_axis(Axis(axis), i_usize)\n                }\n            });\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_inplace":["/// Slice the array in place without changing the number of dimensions.\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// (**Panics** if `D` is `IxDyn` and `indices` does not match the number of array axes.)\n#[deprecated(note = \"renamed to `slice_collapse`\", since = \"0.12.1\")]\npub fn slice_inplace(&mut self, indices: &D::SliceArg){\n        self.slice_collapse(indices)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_move":["/// Slice the array, possibly changing the number of dimensions.\n///\n/// See [*Slicing*](#slicing) for full documentation.\n/// See also [`SliceInfo`] and [`D::SliceArg`].\n///\n/// [`SliceInfo`]: struct.SliceInfo.html\n/// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// (**Panics** if `D` is `IxDyn` and `info` does not match the number of array axes.)\npub fn slice_move<Do>(mut self, info: &SliceInfo<D::SliceArg, Do>) -> ArrayBase<S, Do>\n    where\n        Do: Dimension,{\n        // Slice and collapse in-place without changing the number of dimensions.\n        self.slice_collapse(&*info);\n\n        let indices: &[SliceOrIndex] = (**info).as_ref();\n\n        // Copy the dim and strides that remain after removing the subview axes.\n        let out_ndim = info.out_ndim();\n        let mut new_dim = Do::zeros(out_ndim);\n        let mut new_strides = Do::zeros(out_ndim);\n        izip!(self.dim.slice(), self.strides.slice(), indices)\n            .filter_map(|(d, s, slice_or_index)| match slice_or_index {\n                SliceOrIndex::Slice { .. } => Some((d, s)),\n                SliceOrIndex::Index(_) => None,\n            })\n            .zip(izip!(new_dim.slice_mut(), new_strides.slice_mut()))\n            .for_each(|((d, s), (new_d, new_s))| {\n                *new_d = *d;\n                *new_s = *s;\n            });\n\n        ArrayBase {\n            ptr: self.ptr,\n            data: self.data,\n            dim: new_dim,\n            strides: new_strides,\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::slice_mut":["/// Return a sliced read-write view of the array.\n///\n/// See [*Slicing*](#slicing) for full documentation.\n/// See also [`SliceInfo`] and [`D::SliceArg`].\n///\n/// [`SliceInfo`]: struct.SliceInfo.html\n/// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n///\n/// **Panics** if an index is out of bounds or step size is zero.<br>\n/// (**Panics** if `D` is `IxDyn` and `info` does not match the number of array axes.)\npub fn slice_mut<Do>(&mut self, info: &SliceInfo<D::SliceArg, Do>) -> ArrayViewMut<'_, A, Do>\n    where\n        Do: Dimension,\n        S: DataMut,{\n        self.view_mut().slice_move(info)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::stride_of":["/// Return the stride of `axis`.\n///\n/// The axis should be in the range `Axis(` 0 .. *n* `)` where *n* is the\n/// number of dimensions (axes) of the array.\n///\n/// ***Panics*** if the axis is out of bounds.\npub fn stride_of(&self, axis: Axis) -> isize{\n        // strides are reinterpreted as isize\n        self.strides[axis.index()] as isize\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::strides":["/// Return the strides of the array as a slice.\npub fn strides(&self) -> &[isize]{\n        let s = self.strides.slice();\n        // reinterpret unsigned integer as signed\n        unsafe { slice::from_raw_parts(s.as_ptr() as *const _, s.len()) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::subview":["/// Along `axis`, select the subview `index` and return a\n/// view with that axis removed.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\n#[deprecated(note = \"renamed to `index_axis`\", since = \"0.12.1\")]\npub fn subview(&self, axis: Axis, index: Ix) -> ArrayView<'_, A, D::Smaller>\n    where\n        S: Data,\n        D: RemoveAxis,{\n        self.index_axis(axis, index)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::subview_inplace":["/// Collapse dimension `axis` into length one,\n/// and select the subview of `index` along that axis.\n///\n/// **Panics** if `index` is past the length of the axis.\n#[deprecated(note = \"renamed to `collapse_axis`\", since = \"0.12.1\")]\npub fn subview_inplace(&mut self, axis: Axis, index: Ix){\n        self.collapse_axis(axis, index)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::subview_mut":["/// Along `axis`, select the subview `index` and return a read-write view\n/// with the axis removed.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\n#[deprecated(note = \"renamed to `index_axis_mut`\", since = \"0.12.1\")]\npub fn subview_mut(&mut self, axis: Axis, index: Ix) -> ArrayViewMut<'_, A, D::Smaller>\n    where\n        S: DataMut,\n        D: RemoveAxis,{\n        self.index_axis_mut(axis, index)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::swap":["/// Swap elements at indices `index1` and `index2`.\n///\n/// Indices may be equal.\n///\n/// ***Panics*** if an index is out of bounds.\npub fn swap<I>(&mut self, index1: I, index2: I)\n    where\n        S: DataMut,\n        I: NdIndex<D>,{\n        let ptr1: *mut _ = &mut self[index1];\n        let ptr2: *mut _ = &mut self[index2];\n        unsafe {\n            std_ptr::swap(ptr1, ptr2);\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::swap_axes":["/// Swap axes `ax` and `bx`.\n///\n/// This does not move any data, it just adjusts the arrays dimensions\n/// and strides.\n///\n/// **Panics** if the axes are out of bounds.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let mut a = arr2(&[[1., 2., 3.]]);\n/// a.swap_axes(0, 1);\n/// assert!(\n///     a == arr2(&[[1.], [2.], [3.]])\n/// );\n/// ```\npub fn swap_axes(&mut self, ax: usize, bx: usize){\n        self.dim.slice_mut().swap(ax, bx);\n        self.strides.slice_mut().swap(ax, bx);\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::t":["/// Return a transposed view of the array.\n///\n/// This is a shorthand for `self.view().reversed_axes()`.\n///\n/// See also the more general methods `.reversed_axes()` and `.swap_axes()`.\npub fn t(&self) -> ArrayView<'_, A, D>\n    where\n        S: Data,{\n        self.view().reversed_axes()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::to_owned":["/// Return an uniquely owned copy of the array.\n///\n/// If the input array is contiguous and its strides are positive, then the\n/// output array will have the same memory layout. Otherwise, the layout of\n/// the output array is unspecified. If you need a particular layout, you\n/// can allocate a new array with the desired memory layout and\n/// [`.assign()`](#method.assign) the data. Alternatively, you can collect\n/// an iterator, like this for a result in standard layout:\n///\n/// ```\n/// # use ndarray::prelude::*;\n/// # let arr = Array::from_shape_vec((2, 2).f(), vec![1, 2, 3, 4]).unwrap();\n/// # let owned = {\n/// Array::from_shape_vec(arr.raw_dim(), arr.iter().cloned().collect()).unwrap()\n/// # };\n/// # assert!(owned.is_standard_layout());\n/// # assert_eq!(arr, owned);\n/// ```\n///\n/// or this for a result in column-major (Fortran) layout:\n///\n/// ```\n/// # use ndarray::prelude::*;\n/// # let arr = Array::from_shape_vec((2, 2), vec![1, 2, 3, 4]).unwrap();\n/// # let owned = {\n/// Array::from_shape_vec(arr.raw_dim().f(), arr.t().iter().cloned().collect()).unwrap()\n/// # };\n/// # assert!(owned.t().is_standard_layout());\n/// # assert_eq!(arr, owned);\n/// ```\npub fn to_owned(&self) -> Array<A, D>\n    where\n        A: Clone,\n        S: Data,{\n        if let Some(slc) = self.as_slice_memory_order() {\n            unsafe {\n                Array::from_shape_vec_unchecked(\n                    self.dim.clone().strides(self.strides.clone()),\n                    slc.to_vec(),\n                )\n            }\n        } else {\n            self.map(|x| x.clone())\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::to_shared":["/// Return a shared ownership (copy on write) array.\npub fn to_shared(&self) -> ArcArray<A, D>\n    where\n        A: Clone,\n        S: Data,{\n        // FIXME: Avoid copying if its already an ArcArray.\n        self.to_owned().into_shared()\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::try_ensure_unique":["/// Try to make the array unshared.\n///\n/// This is equivalent to `.ensure_unique()` if `S: DataMut`.\n///\n/// This method is mostly only useful with unsafe code.\nfn try_ensure_unique(&mut self)\n    where\n        S: RawDataMut,{\n        debug_assert!(self.pointer_is_inbounds());\n        S::try_ensure_unique(self);\n        debug_assert!(self.pointer_is_inbounds());\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::uget":["/// Perform *unchecked* array indexing.\n///\n/// Return a reference to the element at `index`.\n///\n/// **Note:** only unchecked for non-debug builds of ndarray.\n///\n/// # Safety\n///\n/// The caller must ensure that the index is in-bounds.\n#[inline]\npub unsafe fn uget<I>(&self, index: I) -> &A\n    where\n        S: Data,\n        I: NdIndex<D>,{\n        arraytraits::debug_bounds_check(self, &index);\n        let off = index.index_unchecked(&self.strides);\n        &*self.ptr.as_ptr().offset(off)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::uget_mut":["/// Perform *unchecked* array indexing.\n///\n/// Return a mutable reference to the element at `index`.\n///\n/// **Note:** Only unchecked for non-debug builds of ndarray.\n///\n/// # Safety\n///\n/// The caller must ensure that:\n///\n/// 1. the index is in-bounds and\n///\n/// 2. the data is uniquely held by the array. (This property is guaranteed\n///    for `Array` and `ArrayViewMut`, but not for `ArcArray` or `CowArray`.)\n#[inline]\npub unsafe fn uget_mut<I>(&mut self, index: I) -> &mut A\n    where\n        S: DataMut,\n        I: NdIndex<D>,{\n        debug_assert!(self.data.is_unique());\n        arraytraits::debug_bounds_check(self, &index);\n        let off = index.index_unchecked(&self.strides);\n        &mut *self.ptr.as_ptr().offset(off)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::uswap":["/// Swap elements *unchecked* at indices `index1` and `index2`.\n///\n/// Indices may be equal.\n///\n/// **Note:** only unchecked for non-debug builds of ndarray.\n///\n/// # Safety\n///\n/// The caller must ensure that:\n///\n/// 1. both `index1 and `index2` are in-bounds and\n///\n/// 2. the data is uniquely held by the array. (This property is guaranteed\n///    for `Array` and `ArrayViewMut`, but not for `ArcArray` or `CowArray`.)\npub unsafe fn uswap<I>(&mut self, index1: I, index2: I)\n    where\n        S: DataMut,\n        I: NdIndex<D>,{\n        debug_assert!(self.data.is_unique());\n        arraytraits::debug_bounds_check(self, &index1);\n        arraytraits::debug_bounds_check(self, &index2);\n        let off1 = index1.index_unchecked(&self.strides);\n        let off2 = index2.index_unchecked(&self.strides);\n        std_ptr::swap(\n            self.ptr.as_ptr().offset(off1),\n            self.ptr.as_ptr().offset(off2),\n        );\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::view":["/// Return a read-only view of the array\npub fn view(&self) -> ArrayView<'_, A, D>\n    where\n        S: Data,{\n        debug_assert!(self.pointer_is_inbounds());\n        unsafe { ArrayView::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::view_mut":["/// Return a read-write view of the array\npub fn view_mut(&mut self) -> ArrayViewMut<'_, A, D>\n    where\n        S: DataMut,{\n        self.ensure_unique();\n        unsafe { ArrayViewMut::new(self.ptr, self.dim.clone(), self.strides.clone()) }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::visit":["/// Visit each element in the array by calling `f` by reference\n/// on each element.\n///\n/// Elements are visited in arbitrary order.\npub fn visit<'a, F>(&'a self, mut f: F)\n    where\n        F: FnMut(&'a A),\n        A: 'a,\n        S: Data,{\n        self.fold((), move |(), elt| f(elt))\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::windows":["/// Return a window producer and iterable.\n///\n/// The windows are all distinct overlapping views of size `window_size`\n/// that fit into the array's shape.\n///\n/// Will yield over no elements if window size is larger\n/// than the actual array size of any dimension.\n///\n/// The produced element is an `ArrayView<A, D>` with exactly the dimension\n/// `window_size`.\n///\n/// **Panics** if any dimension of `window_size` is zero.<br>\n/// (**Panics** if `D` is `IxDyn` and `window_size` does not match the\n/// number of array axes.)\n///\n/// This is an illustration of the 22 windows in a 34 array:\n///\n/// ```text\n///           Axis(1)\n///\n///               \n///          a  a                    a  a                    a  a \n/// Axis(0)        \n///           a  a                    a  a                    a  a \n///                \n///                                                                            \n///                \n///\n///                \n///                                                                            \n///                \n///           a  a                    a  a                    a  a \n///                \n///           a  a                    a  a                    a  a \n///                \n/// ```\npub fn windows<E>(&self, window_size: E) -> Windows<'_, A, D>\n    where\n        E: IntoDimension<Dim = D>,\n        S: Data,{\n        Windows::new(self.view(), window_size)\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with":["/// Traverse two arrays in unspecified order, in lock step,\n/// calling the closure `f` on each element pair.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// **Panics** if broadcasting isnt possible.\n#[inline]\npub fn zip_mut_with<B, S2, E, F>(&mut self, rhs: &ArrayBase<S2, E>, f: F)\n    where\n        S: DataMut,\n        S2: Data<Elem = B>,\n        E: Dimension,\n        F: FnMut(&mut A, &B),{\n        if rhs.dim.ndim() == 0 {\n            // Skip broadcast from 0-dim array\n            self.zip_mut_with_elem(rhs.get_0d(), f);\n        } else if self.dim.ndim() == rhs.dim.ndim() && self.shape() == rhs.shape() {\n            self.zip_mut_with_same_shape(rhs, f);\n        } else {\n            let rhs_broadcast = rhs.broadcast_unwrap(self.raw_dim());\n            self.zip_mut_with_by_rows(&rhs_broadcast, f);\n        }\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_by_rows":["#[inline(always)]\nfn zip_mut_with_by_rows<B, S2, E, F>(&mut self, rhs: &ArrayBase<S2, E>, mut f: F)\n    where\n        S: DataMut,\n        S2: Data<Elem = B>,\n        E: Dimension,\n        F: FnMut(&mut A, &B),{\n        debug_assert_eq!(self.shape(), rhs.shape());\n        debug_assert_ne!(self.ndim(), 0);\n\n        // break the arrays up into their inner rows\n        let n = self.ndim();\n        let dim = self.raw_dim();\n        Zip::from(LanesMut::new(self.view_mut(), Axis(n - 1)))\n            .and(Lanes::new(rhs.broadcast_assume(dim), Axis(n - 1)))\n            .apply(move |s_row, r_row| Zip::from(s_row).and(r_row).apply(|a, b| f(a, b)));\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_elem":["fn zip_mut_with_elem<B, F>(&mut self, rhs_elem: &B, mut f: F)\n    where\n        S: DataMut,\n        F: FnMut(&mut A, &B),{\n        self.unordered_foreach_mut(move |elt| f(elt, rhs_elem));\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_same_shape":["fn zip_mut_with_same_shape<B, S2, E, F>(&mut self, rhs: &ArrayBase<S2, E>, mut f: F)\n    where\n        S: DataMut,\n        S2: Data<Elem = B>,\n        E: Dimension,\n        F: FnMut(&mut A, &B),{\n        debug_assert_eq!(self.shape(), rhs.shape());\n\n        if self.dim.strides_equivalent(&self.strides, &rhs.strides) {\n            if let Some(self_s) = self.as_slice_memory_order_mut() {\n                if let Some(rhs_s) = rhs.as_slice_memory_order() {\n                    for (s, r) in self_s.iter_mut().zip(rhs_s) {\n                        f(s, &r);\n                    }\n                    return;\n                }\n            }\n        }\n\n        // Otherwise, fall back to the outer iter\n        self.zip_mut_with_by_rows(rhs, f);\n    }","Real(LocalPath(\"src/impl_methods.rs\"))"],"impl_ops::ScalarOperand":["/// Elements that can be used as direct operands in arithmetic with arrays.\n///\n/// For example, `f64` is a `ScalarOperand` which means that for an array `a`,\n/// arithmetic like `a + 1.0`, and, `a * 2.`, and `a += 3.` are allowed.\n///\n/// In the description below, let `A` be an array or array view,\n/// let `B` be an array with owned data,\n/// and let `C` be an array with mutable data.\n///\n/// `ScalarOperand` determines for which scalars `K` operations `&A @ K`, and `B @ K`,\n/// and `C @= K` are defined, as ***right hand side operands***, for applicable\n/// arithmetic operators (denoted `@`).\n///\n/// ***Left hand side*** scalar operands are not related to this trait\n/// (they need one `impl` per concrete scalar type); but they are still\n/// implemented for the same types, allowing operations\n/// `K @ &A`, and `K @ B` for primitive numeric types `K`.\n///\n/// This trait ***does not*** limit which elements can be stored in an array in general.\n/// Non-`ScalarOperand` types can still participate in arithmetic as array elements in\n/// in array-array operations.\npub trait ScalarOperand: 'static + Clone {}","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for f32>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for f64>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i128>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i16>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i32>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i64>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i8>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u128>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u16>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u32>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u64>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u8>::add":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::add":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::add":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for f32>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for f64>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i128>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i16>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i32>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i64>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i8>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for num_complex::Complex<f32>>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for num_complex::Complex<f64>>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u128>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u16>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u32>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u64>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u8>::add":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S2, E>> for ArrayBase<S, D>>::add":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<B> for &'a ArrayBase<S, D>>::add":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Add<B> for ArrayBase<S, D>>::add":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for bool>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i128>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i16>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i32>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i64>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i8>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u128>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u16>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u32>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u64>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u8>::bitand":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitand":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for bool>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i128>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i16>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i32>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i64>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i8>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u128>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u16>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u32>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u64>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u8>::bitand":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<B> for &'a ArrayBase<S, D>>::bitand":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<B> for ArrayBase<S, D>>::bitand":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for bool>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i128>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i16>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i32>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i64>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i8>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u128>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u16>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u32>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u64>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u8>::bitor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitor":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for bool>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i128>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i16>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i32>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i64>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i8>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u128>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u16>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u32>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u64>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u8>::bitor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<B> for &'a ArrayBase<S, D>>::bitor":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<B> for ArrayBase<S, D>>::bitor":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for bool>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i128>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i16>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i32>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i64>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i8>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u128>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u16>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u32>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u64>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u8>::bitxor":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitxor":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for bool>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i128>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i16>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i32>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i64>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i8>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u128>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u16>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u32>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u64>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u8>::bitxor":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<B> for &'a ArrayBase<S, D>>::bitxor":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<B> for ArrayBase<S, D>>::bitxor":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for f32>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for f64>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i128>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i16>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i32>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i64>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i8>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u128>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u16>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u32>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u64>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u8>::div":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::div":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::div":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for f32>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for f64>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i128>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i16>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i32>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i64>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i8>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for num_complex::Complex<f32>>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for num_complex::Complex<f64>>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u128>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u16>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u32>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u64>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u8>::div":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S2, E>> for ArrayBase<S, D>>::div":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<B> for &'a ArrayBase<S, D>>::div":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Div<B> for ArrayBase<S, D>>::div":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for f32>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for f64>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i128>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i16>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i32>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i64>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i8>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u128>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u16>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u32>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u64>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u8>::mul":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::mul":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::mul":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for f32>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for f64>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i128>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i16>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i32>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i64>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i8>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for num_complex::Complex<f32>>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for num_complex::Complex<f64>>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u128>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u16>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u32>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u64>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u8>::mul":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S2, E>> for ArrayBase<S, D>>::mul":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<B> for &'a ArrayBase<S, D>>::mul":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<B> for ArrayBase<S, D>>::mul":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Neg for &'a ArrayBase<S, D>>::neg":["/// Perform an elementwise negation of reference `self` and return the\n/// result as a new `Array`.\nfn neg(self) -> Array<A, D>{\n            self.map(Neg::neg)\n        }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Neg for ArrayBase<S, D>>::neg":["/// Perform an elementwise negation of `self` and return the result.\nfn neg(mut self) -> Self{\n            self.unordered_foreach_mut(|elt| {\n                *elt = -elt.clone();\n            });\n            self\n        }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Not for &'a ArrayBase<S, D>>::not":["/// Perform an elementwise unary not of reference `self` and return the\n/// result as a new `Array`.\nfn not(self) -> Array<A, D>{\n            self.map(Not::not)\n        }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Not for ArrayBase<S, D>>::not":["/// Perform an elementwise unary not of `self` and return the result.\nfn not(mut self) -> Self{\n            self.unordered_foreach_mut(|elt| {\n                *elt = !elt.clone();\n            });\n            self\n        }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for f32>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for f64>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i128>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i16>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i32>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i64>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i8>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u128>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u16>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u32>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u64>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u8>::rem":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::rem":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::rem":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for f32>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for f64>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i128>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i16>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i32>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i64>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i8>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u128>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u16>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u32>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u64>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u8>::rem":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S2, E>> for ArrayBase<S, D>>::rem":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<B> for &'a ArrayBase<S, D>>::rem":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<B> for ArrayBase<S, D>>::rem":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i128>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i16>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i32>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i64>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i8>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u128>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u16>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u32>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u64>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u8>::shl":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::shl":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shl":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i128>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i16>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i32>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i64>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i8>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u128>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u16>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u32>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u64>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u8>::shl":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S2, E>> for ArrayBase<S, D>>::shl":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<B> for &'a ArrayBase<S, D>>::shl":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<B> for ArrayBase<S, D>>::shl":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i128>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i16>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i32>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i64>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i8>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u128>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u16>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u32>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u64>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u8>::shr":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::shr":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shr":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i128>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i16>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i32>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i64>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i8>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u128>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u16>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u32>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u64>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u8>::shr":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S2, E>> for ArrayBase<S, D>>::shr":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<B> for &'a ArrayBase<S, D>>::shr":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<B> for ArrayBase<S, D>>::shr":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for f32>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for f64>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i128>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i16>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i32>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i64>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i8>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u128>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u16>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u32>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u64>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u8>::sub":["fn $mth(self, rhs: &ArrayBase<S, D>) -> Array<$scalar, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {\n            self.$mth(rhs.to_owned())\n        })\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::sub":["fn $mth(self, rhs: &'a ArrayBase<S2, E>) -> Array<A, D>{\n        // FIXME: Can we co-broadcast arrays here? And how?\n        self.to_owned().$mth(rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::sub":["fn $mth(mut self, rhs: &ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.zip_mut_with(rhs, |x, y| {\n            *x = x.clone() $operator y.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for f32>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for f64>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i128>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i16>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i32>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i64>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i8>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for num_complex::Complex<f32>>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for num_complex::Complex<f64>>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u128>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u16>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u32>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u64>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u8>::sub":["fn $mth(self, rhs: ArrayBase<S, D>) -> ArrayBase<S, D>{\n        if_commutative!($commutative {\n            rhs.$mth(self)\n        } or {{\n            let mut rhs = rhs;\n            rhs.unordered_foreach_mut(move |elt| {\n                *elt = self $operator *elt;\n            });\n            rhs\n        }})\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S2, E>> for ArrayBase<S, D>>::sub":["fn $mth(self, rhs: ArrayBase<S2, E>) -> ArrayBase<S, D>{\n        self.$mth(&rhs)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<B> for &'a ArrayBase<S, D>>::sub":["fn $mth(self, x: B) -> Array<A, D>{\n        self.to_owned().$mth(x)\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<B> for ArrayBase<S, D>>::sub":["fn $mth(mut self, x: B) -> ArrayBase<S, D>{\n        self.unordered_foreach_mut(move |elt| {\n            *elt = elt.clone() $operator x.clone();\n        });\n        self\n    }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::AddAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::add_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::AddAssign<A> for ArrayBase<S, D>>::add_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::BitAndAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::BitAndAssign<A> for ArrayBase<S, D>>::bitand_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::BitOrAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::BitOrAssign<A> for ArrayBase<S, D>>::bitor_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::BitXorAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::BitXorAssign<A> for ArrayBase<S, D>>::bitxor_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::DivAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::div_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::DivAssign<A> for ArrayBase<S, D>>::div_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::MulAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::mul_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::MulAssign<A> for ArrayBase<S, D>>::mul_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::RemAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::rem_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::RemAssign<A> for ArrayBase<S, D>>::rem_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::ShlAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shl_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::ShlAssign<A> for ArrayBase<S, D>>::shl_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::ShrAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shr_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::ShrAssign<A> for ArrayBase<S, D>>::shr_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::SubAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::sub_assign":["fn $method(&mut self, rhs: &ArrayBase<S2, E>){\n                    self.zip_mut_with(rhs, |x, y| {\n                        x.$method(y.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_ops::assign_ops::<impl std::ops::SubAssign<A> for ArrayBase<S, D>>::sub_assign":["fn $method(&mut self, rhs: A){\n                    self.unordered_foreach_mut(move |elt| {\n                        elt.$method(rhs.clone());\n                    });\n                }","Real(LocalPath(\"src/impl_ops.rs\"))"],"impl_owned_array::<impl ArrayBase<data_repr::OwnedRepr<A>, D>>::into_raw_vec":["/// Return a vector of the elements in the array, in the way they are\n/// stored internally.\n///\n/// If the array is in standard memory layout, the logical element order\n/// of the array (`.iter()` order) and of the returned vector will be the same.\npub fn into_raw_vec(self) -> Vec<A>{\n        self.data.into_vec()\n    }","Real(LocalPath(\"src/impl_owned_array.rs\"))"],"impl_owned_array::<impl ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["/// Returns the single element in the array without cloning it.\n///\n/// ```\n/// use ndarray::{arr0, Array0};\n///\n/// // `Foo` doesn't implement `Clone`.\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Foo;\n///\n/// let array: Array0<Foo> = arr0(Foo);\n/// let scalar: Foo = array.into_scalar();\n/// assert_eq!(scalar, Foo);\n/// ```\npub fn into_scalar(self) -> A{\n        let size = ::std::mem::size_of::<A>();\n        if size == 0 {\n            // Any index in the `Vec` is fine since all elements are identical.\n            self.data.into_vec().remove(0)\n        } else {\n            // Find the index in the `Vec` corresponding to `self.ptr`.\n            // (This is necessary because the element in the array might not be\n            // the first element in the `Vec`, such as if the array was created\n            // by `array![1, 2, 3, 4].slice_move(s![2])`.)\n            let first = self.ptr.as_ptr() as usize;\n            let base = self.data.as_ptr() as usize;\n            let index = (first - base) / size;\n            debug_assert_eq!((first - base) % size, 0);\n            // Remove the element at the index and return it.\n            self.data.into_vec().remove(index)\n        }\n    }","Real(LocalPath(\"src/impl_owned_array.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::cast":["/// Cast the raw pointer of the raw array view to a different type\n///\n/// **Panics** if element size is not compatible.\n///\n/// Lack of panic does not imply it is a valid cast. The cast works the same\n/// way as regular raw pointer casts.\n///\n/// While this method is safe, for the same reason as regular raw pointer\n/// casts are safe, access through the produced raw view is only possible\n/// in an unsafe block or function.\npub fn cast<B>(self) -> RawArrayView<B, D>{\n        assert_eq!(\n            mem::size_of::<B>(),\n            mem::size_of::<A>(),\n            \"size mismatch in raw view cast\"\n        );\n        let ptr = self.ptr.cast::<B>();\n        unsafe { RawArrayView::new(ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::deref_into_view":["/// Converts to a read-only view of the array.\n///\n/// # Safety\n///\n/// From a safety standpoint, this is equivalent to dereferencing a raw\n/// pointer for every element in the array. You must ensure that all of the\n/// data is valid, ensure that the pointer is aligned, and choose the\n/// correct lifetime.\n#[inline]\npub unsafe fn deref_into_view<'a>(self) -> ArrayView<'a, A, D>{\n        debug_assert!(\n            is_aligned(self.ptr.as_ptr()),\n            \"The pointer must be aligned.\"\n        );\n        ArrayView::new(self.ptr, self.dim, self.strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::from_shape_ptr":["/// Create an `RawArrayView<A, D>` from shape information and a raw pointer\n/// to the elements.\n///\n/// # Safety\n///\n/// The caller is responsible for ensuring all of the following:\n///\n/// * `ptr` must be non-null, and it must be safe to [`.offset()`] `ptr` by\n///   zero.\n///\n/// * It must be safe to [`.offset()`] the pointer repeatedly along all\n///   axes and calculate the `count`s for the `.offset()` calls without\n///   overflow, even if the array is empty or the elements are zero-sized.\n///\n///   In other words,\n///\n///   * All possible pointers generated by moving along all axes must be in\n///     bounds or one byte past the end of a single allocation with element\n///     type `A`. The only exceptions are if the array is empty or the element\n///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n///     still be safe to [`.offset()`] the pointer along the axes.\n///\n///   * The offset in units of bytes between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents the computed offset, in bytes, from overflowing\n///     `isize` regardless of the starting point due to past offsets.\n///\n///   * The offset in units of `A` between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents overflow when calculating the `count` parameter to\n///     [`.offset()`] regardless of the starting point due to past offsets.\n///\n/// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\npub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *const A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,{\n        let shape = shape.into();\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if cfg!(debug_assertions) {\n            assert!(!ptr.is_null(), \"The pointer must be non-null.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        RawArrayView::new_(ptr, dim, strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::new":["/// Create a new `RawArrayView`.\n///\n/// Unsafe because caller is responsible for ensuring that the array will\n/// meet all of the invariants of the `ArrayBase` type.\n#[inline]\npub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self{\n        RawArrayView {\n            data: RawViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::new_":["unsafe fn new_(ptr: *const A, dim: D, strides: D) -> Self{\n        Self::new(nonnull_debug_checked_from_ptr(ptr as *mut A), dim, strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::split_at":["/// Split the array view along `axis` and return one array pointer strictly\n/// before the split and one array pointer after the split.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\npub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n        assert!(index <= self.len_of(axis));\n        let left_ptr = self.ptr.as_ptr();\n        let right_ptr = if index == self.len_of(axis) {\n            self.ptr.as_ptr()\n        } else {\n            let offset = stride_offset(index, self.strides.axis(axis));\n            // The `.offset()` is safe due to the guarantees of `RawData`.\n            unsafe { self.ptr.as_ptr().offset(offset) }\n        };\n\n        let mut dim_left = self.dim.clone();\n        dim_left.set_axis(axis, index);\n        let left = unsafe { Self::new_(left_ptr, dim_left, self.strides.clone()) };\n\n        let mut dim_right = self.dim;\n        let right_len = dim_right.axis(axis) - index;\n        dim_right.set_axis(axis, right_len);\n        let right = unsafe { Self::new_(right_ptr, dim_right, self.strides) };\n\n        (left, right)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::cast":["/// Cast the raw pointer of the raw array view to a different type\n///\n/// **Panics** if element size is not compatible.\n///\n/// Lack of panic does not imply it is a valid cast. The cast works the same\n/// way as regular raw pointer casts.\n///\n/// While this method is safe, for the same reason as regular raw pointer\n/// casts are safe, access through the produced raw view is only possible\n/// in an unsafe block or function.\npub fn cast<B>(self) -> RawArrayViewMut<B, D>{\n        assert_eq!(\n            mem::size_of::<B>(),\n            mem::size_of::<A>(),\n            \"size mismatch in raw view cast\"\n        );\n        let ptr = self.ptr.cast::<B>();\n        unsafe { RawArrayViewMut::new(ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::deref_into_view":["/// Converts to a read-only view of the array.\n///\n/// # Safety\n///\n/// From a safety standpoint, this is equivalent to dereferencing a raw\n/// pointer for every element in the array. You must ensure that all of the\n/// data is valid, ensure that the pointer is aligned, and choose the\n/// correct lifetime.\n#[inline]\npub unsafe fn deref_into_view<'a>(self) -> ArrayView<'a, A, D>{\n        debug_assert!(\n            is_aligned(self.ptr.as_ptr()),\n            \"The pointer must be aligned.\"\n        );\n        ArrayView::new(self.ptr, self.dim, self.strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::deref_into_view_mut":["/// Converts to a mutable view of the array.\n///\n/// # Safety\n///\n/// From a safety standpoint, this is equivalent to dereferencing a raw\n/// pointer for every element in the array. You must ensure that all of the\n/// data is valid, ensure that the pointer is aligned, and choose the\n/// correct lifetime.\n#[inline]\npub unsafe fn deref_into_view_mut<'a>(self) -> ArrayViewMut<'a, A, D>{\n        debug_assert!(\n            is_aligned(self.ptr.as_ptr()),\n            \"The pointer must be aligned.\"\n        );\n        ArrayViewMut::new(self.ptr, self.dim, self.strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::from_shape_ptr":["/// Create an `RawArrayViewMut<A, D>` from shape information and a raw\n/// pointer to the elements.\n///\n/// # Safety\n///\n/// The caller is responsible for ensuring all of the following:\n///\n/// * `ptr` must be non-null, and it must be safe to [`.offset()`] `ptr` by\n///   zero.\n///\n/// * It must be safe to [`.offset()`] the pointer repeatedly along all\n///   axes and calculate the `count`s for the `.offset()` calls without\n///   overflow, even if the array is empty or the elements are zero-sized.\n///\n///   In other words,\n///\n///   * All possible pointers generated by moving along all axes must be in\n///     bounds or one byte past the end of a single allocation with element\n///     type `A`. The only exceptions are if the array is empty or the element\n///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n///     still be safe to [`.offset()`] the pointer along the axes.\n///\n///   * The offset in units of bytes between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents the computed offset, in bytes, from overflowing\n///     `isize` regardless of the starting point due to past offsets.\n///\n///   * The offset in units of `A` between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents overflow when calculating the `count` parameter to\n///     [`.offset()`] regardless of the starting point due to past offsets.\n///\n/// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\npub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *mut A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,{\n        let shape = shape.into();\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if cfg!(debug_assertions) {\n            assert!(!ptr.is_null(), \"The pointer must be non-null.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        RawArrayViewMut::new_(ptr, dim, strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::into_raw_view":["/// Converts to a non-mutable `RawArrayView`.\n#[inline]\npub(crate) fn into_raw_view(self) -> RawArrayView<A, D>{\n        unsafe { RawArrayView::new(self.ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::new":["/// Create a new `RawArrayViewMut`.\n///\n/// Unsafe because caller is responsible for ensuring that the array will\n/// meet all of the invariants of the `ArrayBase` type.\n#[inline]\npub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self{\n        RawArrayViewMut {\n            data: RawViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::new_":["unsafe fn new_(ptr: *mut A, dim: D, strides: D) -> Self{\n        Self::new(nonnull_debug_checked_from_ptr(ptr), dim, strides)\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::split_at":["/// Split the array view along `axis` and return one array pointer strictly\n/// before the split and one array pointer after the split.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\npub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n        let (left, right) = self.into_raw_view().split_at(axis, index);\n        unsafe {\n            (\n                Self::new(left.ptr, left.dim, left.strides),\n                Self::new(right.ptr, right.dim, right.strides),\n            )\n        }\n    }","Real(LocalPath(\"src/impl_raw_views.rs\"))"],"impl_special_element_types::<impl ArrayBase<S, D>>::assume_init":["/// **Promise** that the array's elements are all fully initialized, and convert\n/// the array from element type `MaybeUninit<A>` to `A`.\n///\n/// For example, it can convert an `Array<MaybeUninit<f64>, D>` to `Array<f64, D>`.\n///\n/// ## Safety\n///\n/// Safe to use if all the array's elements have been initialized.\n///\n/// Note that for owned and shared ownership arrays, the promise must include all of the\n/// array's storage; it is for example possible to slice these in place, but that must\n/// only be done after all elements have been initialized.\npub unsafe fn assume_init(self) -> ArrayBase<<S as RawDataSubst<A>>::Output, D>{\n        // NOTE: Fully initialized includes elements not reachable in current slicing/view.\n\n        let ArrayBase { data, ptr, dim, strides } = self;\n\n        // transmute from storage of MaybeUninit<A> to storage of A\n        let data = unlimited_transmute::<S, S::Output>(data);\n        let ptr = ptr.cast::<A>();\n\n        ArrayBase {\n            data,\n            ptr,\n            dim,\n            strides,\n        }\n    }","Real(LocalPath(\"src/impl_special_element_types.rs\"))"],"impl_special_element_types::unlimited_transmute":["/// Transmute from A to B.\n///\n/// Like transmute, but does not have the compile-time size check which blocks\n/// using regular transmute for \"S to S::Output\".\n///\n/// **Panics** if the size of A and B are different.\nunsafe fn unlimited_transmute<A, B>(data: A) -> B{\n    assert_eq!(size_of::<A>(), size_of::<B>());\n    let old_data = ManuallyDrop::new(data);\n    (&*old_data as *const A as *const B).read()\n}","Real(LocalPath(\"src/impl_special_element_types.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape":["/// Create a read-only array view borrowing its data from a slice.\n///\n/// Checks whether `shape` are compatible with the slice's\n/// length, returning an `Err` if not compatible.\n///\n/// ```\n/// use ndarray::ArrayView;\n/// use ndarray::arr3;\n/// use ndarray::ShapeBuilder;\n///\n/// let s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n/// let a = ArrayView::from_shape((2, 3, 2).strides((1, 4, 2)),\n///                               &s).unwrap();\n///\n/// assert!(\n///     a == arr3(&[[[0, 2],\n///                  [4, 6],\n///                  [8, 10]],\n///                 [[1, 3],\n///                  [5, 7],\n///                  [9, 11]]])\n/// );\n/// assert!(a.strides() == &[1, 4, 2]);\n/// ```\npub fn from_shape<Sh>(shape: Sh, xs: &'a [A]) -> Result<Self, ShapeError>\n    where\n        Sh: Into<StrideShape<D>>,{\n        // eliminate the type parameter Sh as soon as possible\n        Self::from_shape_impl(shape.into(), xs)\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape_impl":["fn from_shape_impl(shape: StrideShape<D>, xs: &'a [A]) -> Result<Self, ShapeError>{\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if shape.custom {\n            dimension::can_index_slice(xs, &dim, &strides)?;\n        } else {\n            dimension::can_index_slice_not_custom::<A, _>(xs, &dim)?;\n        }\n        unsafe { Ok(Self::new_(xs.as_ptr(), dim, strides)) }\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape_ptr":["/// Create an `ArrayView<A, D>` from shape information and a raw pointer to\n/// the elements.\n///\n/// # Safety\n///\n/// The caller is responsible for ensuring all of the following:\n///\n/// * The elements seen by moving `ptr` according to the shape and strides\n///   must live at least as long as `'a` and must not be not mutably\n///   aliased for the duration of `'a`.\n///\n/// * `ptr` must be non-null and aligned, and it must be safe to\n///   [`.offset()`] `ptr` by zero.\n///\n/// * It must be safe to [`.offset()`] the pointer repeatedly along all\n///   axes and calculate the `count`s for the `.offset()` calls without\n///   overflow, even if the array is empty or the elements are zero-sized.\n///\n///   In other words,\n///\n///   * All possible pointers generated by moving along all axes must be in\n///     bounds or one byte past the end of a single allocation with element\n///     type `A`. The only exceptions are if the array is empty or the element\n///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n///     still be safe to [`.offset()`] the pointer along the axes.\n///\n///   * The offset in units of bytes between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents the computed offset, in bytes, from overflowing\n///     `isize` regardless of the starting point due to past offsets.\n///\n///   * The offset in units of `A` between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents overflow when calculating the `count` parameter to\n///     [`.offset()`] regardless of the starting point due to past offsets.\n///\n/// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\npub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *const A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,{\n        RawArrayView::from_shape_ptr(shape, ptr).deref_into_view()\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::new":["/// Create a new `ArrayView`\n///\n/// Unsafe because: `ptr` must be valid for the given dimension and strides.\n#[inline(always)]\npub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self{\n        if cfg!(debug_assertions) {\n            assert!(is_aligned(ptr.as_ptr()), \"The pointer must be aligned.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        ArrayView {\n            data: ViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::new_":["/// Unsafe because: `ptr` must be valid for the given dimension and strides.\n#[inline]\npub(crate) unsafe fn new_(ptr: *const A, dim: D, strides: D) -> Self{\n        Self::new(nonnull_debug_checked_from_ptr(ptr as *mut A), dim, strides)\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape":["/// Create a read-write array view borrowing its data from a slice.\n///\n/// Checks whether `dim` and `strides` are compatible with the slice's\n/// length, returning an `Err` if not compatible.\n///\n/// ```\n/// use ndarray::ArrayViewMut;\n/// use ndarray::arr3;\n/// use ndarray::ShapeBuilder;\n///\n/// let mut s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n/// let mut a = ArrayViewMut::from_shape((2, 3, 2).strides((1, 4, 2)),\n///                                      &mut s).unwrap();\n///\n/// a[[0, 0, 0]] = 1;\n/// assert!(\n///     a == arr3(&[[[1, 2],\n///                  [4, 6],\n///                  [8, 10]],\n///                 [[1, 3],\n///                  [5, 7],\n///                  [9, 11]]])\n/// );\n/// assert!(a.strides() == &[1, 4, 2]);\n/// ```\npub fn from_shape<Sh>(shape: Sh, xs: &'a mut [A]) -> Result<Self, ShapeError>\n    where\n        Sh: Into<StrideShape<D>>,{\n        // eliminate the type parameter Sh as soon as possible\n        Self::from_shape_impl(shape.into(), xs)\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape_impl":["fn from_shape_impl(shape: StrideShape<D>, xs: &'a mut [A]) -> Result<Self, ShapeError>{\n        let dim = shape.dim;\n        let strides = shape.strides;\n        if shape.custom {\n            dimension::can_index_slice(xs, &dim, &strides)?;\n        } else {\n            dimension::can_index_slice_not_custom::<A, _>(xs, &dim)?;\n        }\n        unsafe { Ok(Self::new_(xs.as_mut_ptr(), dim, strides)) }\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape_ptr":["/// Create an `ArrayViewMut<A, D>` from shape information and a\n/// raw pointer to the elements.\n///\n/// # Safety\n///\n/// The caller is responsible for ensuring all of the following:\n///\n/// * The elements seen by moving `ptr` according to the shape and strides\n///   must live at least as long as `'a` and must not be aliased for the\n///   duration of `'a`.\n///\n/// * `ptr` must be non-null and aligned, and it must be safe to\n///   [`.offset()`] `ptr` by zero.\n///\n/// * It must be safe to [`.offset()`] the pointer repeatedly along all\n///   axes and calculate the `count`s for the `.offset()` calls without\n///   overflow, even if the array is empty or the elements are zero-sized.\n///\n///   In other words,\n///\n///   * All possible pointers generated by moving along all axes must be in\n///     bounds or one byte past the end of a single allocation with element\n///     type `A`. The only exceptions are if the array is empty or the element\n///     type is zero-sized. In these cases, `ptr` may be dangling, but it must\n///     still be safe to [`.offset()`] the pointer along the axes.\n///\n///   * The offset in units of bytes between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents the computed offset, in bytes, from overflowing\n///     `isize` regardless of the starting point due to past offsets.\n///\n///   * The offset in units of `A` between the least address and greatest\n///     address by moving along all axes must not exceed `isize::MAX`. This\n///     constraint prevents overflow when calculating the `count` parameter to\n///     [`.offset()`] regardless of the starting point due to past offsets.\n///\n/// * The product of non-zero axis lengths must not exceed `isize::MAX`.\n///\n/// [`.offset()`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset\npub unsafe fn from_shape_ptr<Sh>(shape: Sh, ptr: *mut A) -> Self\n    where\n        Sh: Into<StrideShape<D>>,{\n        RawArrayViewMut::from_shape_ptr(shape, ptr).deref_into_view_mut()\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::new":["/// Create a new `ArrayView`\n///\n/// Unsafe because: `ptr` must be valid for the given dimension and strides.\n#[inline(always)]\npub(crate) unsafe fn new(ptr: NonNull<A>, dim: D, strides: D) -> Self{\n        if cfg!(debug_assertions) {\n            assert!(is_aligned(ptr.as_ptr()), \"The pointer must be aligned.\");\n            dimension::max_abs_offset_check_overflow::<A, _>(&dim, &strides).unwrap();\n        }\n        ArrayViewMut {\n            data: ViewRepr::new(),\n            ptr,\n            dim,\n            strides,\n        }\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::new_":["/// Create a new `ArrayView`\n///\n/// Unsafe because: `ptr` must be valid for the given dimension and strides.\n#[inline(always)]\npub(crate) unsafe fn new_(ptr: *mut A, dim: D, strides: D) -> Self{\n        Self::new(nonnull_debug_checked_from_ptr(ptr), dim, strides)\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::reborrow":["/// Convert the view into an `ArrayViewMut<'b, A, D>` where `'b` is a lifetime\n/// outlived by `'a'`.\npub fn reborrow<'b>(self) -> ArrayViewMut<'b, A, D>\n    where\n        'a: 'b,{\n        unsafe { ArrayViewMut::new(self.ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/constructors.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_base_iter":["#[inline]\npub(crate) fn into_base_iter(self) -> Baseiter<A, D>{\n        unsafe { Baseiter::new(self.ptr.as_ptr(), self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_elements_base":["#[inline]\npub(crate) fn into_elements_base(self) -> ElementsBase<'a, A, D>{\n        ElementsBase::new(self)\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_iter_":["pub(crate) fn into_iter_(self) -> Iter<'a, A, D>{\n        Iter::new(self)\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_outer_iter":["/// Return an outer iterator for this view.\n#[doc(hidden)]\n#[deprecated(note = \"This method will be replaced.\")]\npub fn into_outer_iter(self) -> iter::AxisIter<'a, A, D::Smaller>\n    where\n        D: RemoveAxis,{\n        AxisIter::new(self, Axis(0))\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_raw_view":["/// Converts to a raw array view.\npub(crate) fn into_raw_view(self) -> RawArrayView<A, D>{\n        unsafe { RawArrayView::new(self.ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_slice":["/// Return the arrays data as a slice, if it is contiguous and in standard order.\n/// Return `None` otherwise.\n#[deprecated(note = \"`into_slice` has been renamed to `to_slice`\", since = \"0.13.0\")]\n#[allow(clippy::wrong_self_convention)]\npub fn into_slice(&self) -> Option<&'a [A]>{\n        if self.is_standard_layout() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::reborrow":["/// Convert the view into an `ArrayView<'b, A, D>` where `'b` is a lifetime\n/// outlived by `'a'`.\npub fn reborrow<'b>(self) -> ArrayView<'b, A, D>\n    where\n        'a: 'b,{\n        unsafe { ArrayView::new(self.ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::to_slice":["/// Return the arrays data as a slice, if it is contiguous and in standard order.\n/// Return `None` otherwise.\npub fn to_slice(&self) -> Option<&'a [A]>{\n        if self.is_standard_layout() {\n            unsafe { Some(slice::from_raw_parts(self.ptr.as_ptr(), self.len())) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["/// Consume the view and return a reference to the single element in the array.\n///\n/// The lifetime of the returned reference matches the lifetime of the data\n/// the array view was pointing to.\n///\n/// ```\n/// use ndarray::{arr0, Array0};\n///\n/// // `Foo` doesn't implement `Clone`.\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Foo;\n///\n/// let array: Array0<Foo> = arr0(Foo);\n/// let view = array.view();\n/// let scalar: &Foo = view.into_scalar();\n/// assert_eq!(scalar, &Foo);\n/// ```\npub fn into_scalar(self) -> &'a A{\n        self.index(Ix0())\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_base_iter":["#[inline]\npub(crate) fn into_base_iter(self) -> Baseiter<A, D>{\n        unsafe { Baseiter::new(self.ptr.as_ptr(), self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_elements_base":["#[inline]\npub(crate) fn into_elements_base(self) -> ElementsBaseMut<'a, A, D>{\n        ElementsBaseMut::new(self)\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_iter_":["pub(crate) fn into_iter_(self) -> IterMut<'a, A, D>{\n        IterMut::new(self)\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_outer_iter":["/// Return an outer iterator for this view.\n#[doc(hidden)]\n#[deprecated(note = \"This method will be replaced.\")]\npub fn into_outer_iter(self) -> iter::AxisIterMut<'a, A, D::Smaller>\n    where\n        D: RemoveAxis,{\n        AxisIterMut::new(self, Axis(0))\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_raw_view_mut":["/// Converts to a mutable raw array view.\npub(crate) fn into_raw_view_mut(self) -> RawArrayViewMut<A, D>{\n        unsafe { RawArrayViewMut::new(self.ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_slice":["/// Return the arrays data as a slice, if it is contiguous and in standard order.\n/// Return `None` otherwise.\npub fn into_slice(self) -> Option<&'a mut [A]>{\n        self.into_slice_().ok()\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_slice_":["pub(crate) fn into_slice_(self) -> Result<&'a mut [A], Self>{\n        if self.is_standard_layout() {\n            unsafe { Ok(slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())) }\n        } else {\n            Err(self)\n        }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_view":["pub(crate) fn into_view(self) -> ArrayView<'a, A, D>{\n        unsafe { ArrayView::new(self.ptr, self.dim, self.strides) }\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["/// Consume the mutable view and return a mutable reference to the single element in the array.\n///\n/// The lifetime of the returned reference matches the lifetime of the data\n/// the array view was pointing to.\n///\n/// ```\n/// use ndarray::{arr0, Array0};\n///\n/// let mut array: Array0<f64> = arr0(5.);\n/// let view = array.view_mut();\n/// let mut scalar = view.into_scalar();\n/// *scalar = 7.;\n/// assert_eq!(scalar, &7.);\n/// assert_eq!(array[()], 7.);\n/// ```\npub fn into_scalar(self) -> &'a mut A{\n        self.index(Ix0())\n    }","Real(LocalPath(\"src/impl_views/conversions.rs\"))"],"impl_views::indexing::IndexLonger":["/// Extra indexing methods for array views\n///\n/// These methods are very similar to regular indexing or calling of the\n/// `get`/`get_mut` methods that we can use on any array or array view. The\n/// difference here is in the length of lifetime in the resulting reference.\n///\n/// **Note** that the `ArrayView` (read-only) and `ArrayViewMut` (read-write) differ\n/// in how they are allowed implement this trait -- `ArrayView`'s implementation\n/// is usual. If you put in a `ArrayView<'a, T, D>` here, you get references\n/// `&'a T` out.\n///\n/// For `ArrayViewMut` to obey the borrowing rules we have to consume the\n/// view if we call any of these methods. (The equivalent of reborrow is\n/// `.view_mut()` for read-write array views, but if you can use that,\n/// then the regular indexing / `get_mut` should suffice, too.)\n///\n/// ```\n/// use ndarray::IndexLonger;\n/// use ndarray::ArrayView;\n///\n/// let data = [0.; 256];\n/// let long_life_ref = {\n///     // make a 16  16 array view\n///     let view = ArrayView::from(&data[..]).into_shape((16, 16)).unwrap();\n///\n///     // index the view and with `IndexLonger`.\n///     // Note here that we get a reference with a life that is derived from\n///     // `data`, the base data, instead of being derived from the view\n///     IndexLonger::index(&view, [0, 1])\n/// };\n///\n/// // view goes out of scope\n///\n/// assert_eq!(long_life_ref, &0.);\n///\n/// ```\npub trait IndexLonger<I> {\n    /// The type of the reference to the element that is produced, including\n    /// its lifetime.\n    type Output;\n    /// Get a reference of a element through the view.\n    ///\n    /// This method is like `Index::index` but with a longer lifetime (matching\n    /// the array view); which we can only do for the array view and not in the\n    /// `Index` trait.\n    ///\n    /// See also [the `get` method][1] which works for all arrays and array\n    /// views.\n    ///\n    /// [1]: struct.ArrayBase.html#method.get\n    ///\n    /// **Panics** if index is out of bounds.\n    fn index(self, index: I) -> Self::Output;\n\n    /// Get a reference of a element through the view.\n    ///\n    /// This method is like `ArrayBase::get` but with a longer lifetime (matching\n    /// the array view); which we can only do for the array view and not in the\n    /// `Index` trait.\n    ///\n    /// See also [the `get` method][1] (and [`get_mut`][2]) which works for all arrays and array\n    /// views.\n    ///\n    /// [1]: struct.ArrayBase.html#method.get\n    /// [2]: struct.ArrayBase.html#method.get_mut\n    ///\n    /// **Panics** if index is out of bounds.\n    fn get(self, index: I) -> Option<Self::Output>;\n\n    /// Get a reference of a element through the view without boundary check\n    ///\n    /// This method is like `elem` with a longer lifetime (matching the array\n    /// view); which we can't do for general arrays.\n    ///\n    /// See also [the `uget` method][1] which works for all arrays and array\n    /// views.\n    ///\n    /// [1]: struct.ArrayBase.html#method.uget\n    ///\n    /// **Note:** only unchecked for non-debug builds of ndarray.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that the index is in-bounds.\n    unsafe fn uget(self, index: I) -> Self::Output;\n}","Real(LocalPath(\"src/impl_views/indexing.rs\"))"],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a A>, D>>::split_at":["/// Split the array view along `axis` and return one view strictly before the\n/// split and one view after the split.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\n///\n/// **Examples:**\n/// ```rust\n/// # use ndarray::prelude::*;\n/// let a = aview2(&[[0, 1, 2, 3],\n///                  [4, 5, 6, 7],\n///                  [8, 9, 0, 1]]);\n///\n/// ```\n/// The array view `a` has two axes and shape 3  4:\n/// ```text\n///           Axis(1)\n///          0\n///         a  a  a  a \n///         1\n///  Axis(0) a  a  a  a \n///          2\n///          a  a  a  a \n///          3 \n///         0     1     2     3     4  possible split_at indices.\n/// ```\n///\n/// Row indices increase along `Axis(0)`, and column indices increase along\n/// `Axis(1)`. Note that we split before an element index, and that\n/// both 0 and the endpoint are valid split indices.\n///\n/// **Example 1**: Split `a` along the first axis, in this case the rows, at\n/// index 2.<br>\n/// This produces views v1 and v2 of shapes 2  4 and 1  4:\n///\n/// ```rust\n/// # use ndarray::prelude::*;\n/// # let a = aview2(&[[0; 4]; 3]);\n/// let (v1, v2) = a.split_at(Axis(0), 1);\n/// ```\n/// ```text\n///                0   indices\n///          a  a  a  a             along Axis(0)\n///          v1    1\n///          a  a  a  a \n///         \n///                2\n///         \n///          a  a  a  a  v2\n///                3\n/// ```\n///\n/// **Example 2**: Split `a` along the second axis, in this case the\n/// columns, at index 2.<br>\n/// This produces views u1 and u2 of shapes 3 2 and 3  2:\n///\n/// ```rust\n/// # use ndarray::prelude::*;\n/// # let a = aview2(&[[0; 4]; 3]);\n/// let (u1, u2) = a.split_at(Axis(1), 2);\n///\n/// ```\n/// ```text\n///              u1             u2\n///         \n///          a  a  a  a \n///         \n///          a  a  a  a \n///         \n///          a  a  a  a \n///         \n///         0     1      2      3     4  indices \n///                                      along Axis(1)\n/// ```\npub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n        unsafe {\n            let (left, right) = self.into_raw_view().split_at(axis, index);\n            (left.deref_into_view(), right.deref_into_view())\n        }\n    }","Real(LocalPath(\"src/impl_views/splitting.rs\"))"],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::multi_slice_move":["/// Split the view into multiple disjoint slices.\n///\n/// This is similar to [`.multi_slice_mut()`], but `.multi_slice_move()`\n/// consumes `self` and produces views with lifetimes matching that of\n/// `self`.\n///\n/// See [*Slicing*](#slicing) for full documentation.\n/// See also [`SliceInfo`] and [`D::SliceArg`].\n///\n/// [`.multi_slice_mut()`]: struct.ArrayBase.html#method.multi_slice_mut\n/// [`SliceInfo`]: struct.SliceInfo.html\n/// [`D::SliceArg`]: trait.Dimension.html#associatedtype.SliceArg\n///\n/// **Panics** if any of the following occur:\n///\n/// * if any of the views would intersect (i.e. if any element would appear in multiple slices)\n/// * if an index is out of bounds or step size is zero\n/// * if `D` is `IxDyn` and `info` does not match the number of array axes\npub fn multi_slice_move<M>(self, info: M) -> M::Output\n    where\n        M: MultiSlice<'a, A, D>,{\n        info.multi_slice_move(self)\n    }","Real(LocalPath(\"src/impl_views/splitting.rs\"))"],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::split_at":["/// Split the array view along `axis` and return one mutable view strictly\n/// before the split and one mutable view after the split.\n///\n/// **Panics** if `axis` or `index` is out of bounds.\npub fn split_at(self, axis: Axis, index: Ix) -> (Self, Self){\n        unsafe {\n            let (left, right) = self.into_raw_view_mut().split_at(axis, index);\n            (left.deref_into_view_mut(), right.deref_into_view_mut())\n        }\n    }","Real(LocalPath(\"src/impl_views/splitting.rs\"))"],"indexes::IndexPtr":["pub struct IndexPtr<D> {\n    index: D,\n}","Real(LocalPath(\"src/indexes.rs\"))"],"indexes::Indices":["/// Indices producer and iterable.\n///\n/// `Indices` is an `NdProducer` that produces the indices of an array shape.\npub struct Indices<D>\nwhere\n    D: Dimension,\n{\n    start: D,\n    dim: D,\n}","Real(LocalPath(\"src/indexes.rs\"))"],"indexes::IndicesIter":["/// An iterator over the indexes of an array shape.\n///\n/// Iterator element type is `D`.\npub struct IndicesIter<D> {\n    dim: D,\n    index: Option<D>,\n}","Real(LocalPath(\"src/indexes.rs\"))"],"indexes::IndicesIterF":["/// An iterator over the indexes of an array shape.\n///\n/// Iterator element type is `D`.\npub struct IndicesIterF<D> {\n    dim: D,\n    index: D,\n    has_remaining: bool,\n}","Real(LocalPath(\"src/indexes.rs\"))"],"indexes::indices":["/// Create an iterable of the array shape `shape`.\n///\n/// *Note:* prefer higher order methods, arithmetic operations and\n/// non-indexed iteration before using indices.\npub fn indices<E>(shape: E) -> Indices<E::Dim>\nwhere\n    E: IntoDimension,{\n    let dim = shape.into_dimension();\n    Indices {\n        start: E::Dim::zeros(dim.ndim()),\n        dim,\n    }\n}","Real(LocalPath(\"src/indexes.rs\"))"],"indexes::indices_iter_f":["pub fn indices_iter_f<E>(shape: E) -> IndicesIterF<E::Dim>\nwhere\n    E: IntoDimension,{\n    let dim = shape.into_dimension();\n    let zero = E::Dim::zeros(dim.ndim());\n    IndicesIterF {\n        has_remaining: dim.size_checked() != Some(0),\n        index: zero,\n        dim,\n    }\n}","Real(LocalPath(\"src/indexes.rs\"))"],"indexes::indices_of":["/// Return an iterable of the indices of the passed-in array.\n///\n/// *Note:* prefer higher order methods, arithmetic operations and\n/// non-indexed iteration before using indices.\npub fn indices_of<S, D>(array: &ArrayBase<S, D>) -> Indices<D>\nwhere\n    S: Data,\n    D: Dimension,{\n    indices(array.dim())\n}","Real(LocalPath(\"src/indexes.rs\"))"],"is_aligned":["/// Returns `true` if the pointer is aligned.\npub(crate) fn is_aligned<T>(ptr: *const T) -> bool{\n    (ptr as usize) % ::std::mem::align_of::<T>() == 0\n}","Real(LocalPath(\"src/lib.rs\"))"],"iterators::AxisChunksIter":["/// An iterator that traverses over the specified axis\n/// and yields views of the specified size on this axis.\n///\n/// For example, in a 2  8  3 array, if the axis of iteration\n/// is 1 and the chunk size is 2, the yielded elements\n/// are 2  2  3 views (and there are 4 in total).\n///\n/// Iterator element type is `ArrayView<'a, A, D>`.\n///\n/// See [`.axis_chunks_iter()`](../struct.ArrayBase.html#method.axis_chunks_iter) for more information.\npub struct AxisChunksIter<'a, A, D> {\n    iter: AxisIterCore<A, D>,\n    /// Index of the partial chunk (the chunk smaller than the specified chunk\n    /// size due to the axis length not being evenly divisible). If the axis\n    /// length is evenly divisible by the chunk size, this index is larger than\n    /// the maximum valid index.\n    partial_chunk_index: usize,\n    /// Dimension of the partial chunk.\n    partial_chunk_dim: D,\n    life: PhantomData<&'a A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIter::<'a, A, D>::get_subview":["fn get_subview(&self, index: usize, ptr: *mut A) -> $array<'a, A, D>{\n                if index != self.partial_chunk_index {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.iter.inner_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                } else {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.partial_chunk_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                }\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIter::<'a, A, D>::new":["pub(crate) fn new(v: ArrayView<'a, A, D>, axis: Axis, size: usize) -> Self{\n        let (iter, partial_chunk_index, partial_chunk_dim) = chunk_iter_parts(v, axis, size);\n        AxisChunksIter {\n            iter,\n            partial_chunk_index,\n            partial_chunk_dim,\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIter::<'a, A, D>::split_at":["/// Splits the iterator at index, yielding two disjoint iterators.\n///\n/// `index` is relative to the current state of the iterator (which is not\n/// necessarily the start of the axis).\n///\n/// **Panics** if `index` is strictly greater than the iterator's remaining\n/// length.\npub fn split_at(self, index: usize) -> (Self, Self){\n                let (left, right) = self.iter.split_at(index);\n                (\n                    Self {\n                        iter: left,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim.clone(),\n                        life: self.life,\n                    },\n                    Self {\n                        iter: right,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim,\n                        life: self.life,\n                    },\n                )\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIterMut":["/// An iterator that traverses over the specified axis\n/// and yields mutable views of the specified size on this axis.\n///\n/// For example, in a 2  8  3 array, if the axis of iteration\n/// is 1 and the chunk size is 2, the yielded elements\n/// are 2  2  3 views (and there are 4 in total).\n///\n/// Iterator element type is `ArrayViewMut<'a, A, D>`.\n///\n/// See [`.axis_chunks_iter_mut()`](../struct.ArrayBase.html#method.axis_chunks_iter_mut)\n/// for more information.\npub struct AxisChunksIterMut<'a, A, D> {\n    iter: AxisIterCore<A, D>,\n    partial_chunk_index: usize,\n    partial_chunk_dim: D,\n    life: PhantomData<&'a mut A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIterMut::<'a, A, D>::get_subview":["fn get_subview(&self, index: usize, ptr: *mut A) -> $array<'a, A, D>{\n                if index != self.partial_chunk_index {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.iter.inner_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                } else {\n                    unsafe {\n                        $array::new_(\n                            ptr,\n                            self.partial_chunk_dim.clone(),\n                            self.iter.inner_strides.clone(),\n                        )\n                    }\n                }\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIterMut::<'a, A, D>::new":["pub(crate) fn new(v: ArrayViewMut<'a, A, D>, axis: Axis, size: usize) -> Self{\n        let (iter, partial_chunk_index, partial_chunk_dim) =\n            chunk_iter_parts(v.into_view(), axis, size);\n        AxisChunksIterMut {\n            iter,\n            partial_chunk_index,\n            partial_chunk_dim,\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisChunksIterMut::<'a, A, D>::split_at":["/// Splits the iterator at index, yielding two disjoint iterators.\n///\n/// `index` is relative to the current state of the iterator (which is not\n/// necessarily the start of the axis).\n///\n/// **Panics** if `index` is strictly greater than the iterator's remaining\n/// length.\npub fn split_at(self, index: usize) -> (Self, Self){\n                let (left, right) = self.iter.split_at(index);\n                (\n                    Self {\n                        iter: left,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim.clone(),\n                        life: self.life,\n                    },\n                    Self {\n                        iter: right,\n                        partial_chunk_index: self.partial_chunk_index,\n                        partial_chunk_dim: self.partial_chunk_dim,\n                        life: self.life,\n                    },\n                )\n            }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIter":["/// An iterator that traverses over an axis and\n/// and yields each subview.\n///\n/// The outermost dimension is `Axis(0)`, created with `.outer_iter()`,\n/// but you can traverse arbitrary dimension with `.axis_iter()`.\n///\n/// For example, in a 3  5  5 array, with `axis` equal to `Axis(2)`,\n/// the iterator element is a 3  5 subview (and there are 5 in total).\n///\n/// Iterator element type is `ArrayView<'a, A, D>`.\n///\n/// See [`.outer_iter()`](../struct.ArrayBase.html#method.outer_iter)\n/// or [`.axis_iter()`](../struct.ArrayBase.html#method.axis_iter)\n/// for more information.\npub struct AxisIter<'a, A, D> {\n    iter: AxisIterCore<A, D>,\n    life: PhantomData<&'a A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIter::<'a, A, D>::new":["/// Creates a new iterator over the specified axis.\npub(crate) fn new<Di>(v: ArrayView<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: RemoveAxis<Smaller = D>,{\n        AxisIter {\n            iter: AxisIterCore::new(v, axis),\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIter::<'a, A, D>::split_at":["/// Splits the iterator at `index`, yielding two disjoint iterators.\n///\n/// `index` is relative to the current state of the iterator (which is not\n/// necessarily the start of the axis).\n///\n/// **Panics** if `index` is strictly greater than the iterator's remaining\n/// length.\npub fn split_at(self, index: usize) -> (Self, Self){\n        let (left, right) = self.iter.split_at(index);\n        (\n            AxisIter {\n                iter: left,\n                life: self.life,\n            },\n            AxisIter {\n                iter: right,\n                life: self.life,\n            },\n        )\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterCore":["pub struct AxisIterCore<A, D> {\n    /// Index along the axis of the value of `.next()`, relative to the start\n    /// of the axis.\n    index: Ix,\n    /// (Exclusive) upper bound on `index`. Initially, this is equal to the\n    /// length of the axis.\n    end: Ix,\n    /// Stride along the axis (offset between consecutive pointers).\n    stride: Ixs,\n    /// Shape of the iterator's items.\n    inner_dim: D,\n    /// Strides of the iterator's items.\n    inner_strides: D,\n    /// Pointer corresponding to `index == 0`.\n    ptr: *mut A,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterCore::<A, D>::new":["/// Constructs a new iterator over the specified axis.\nfn new<S, Di>(v: ArrayBase<S, Di>, axis: Axis) -> Self\n    where\n        Di: RemoveAxis<Smaller = D>,\n        S: Data<Elem = A>,{\n        AxisIterCore {\n            index: 0,\n            end: v.len_of(axis),\n            stride: v.stride_of(axis),\n            inner_dim: v.dim.remove_axis(axis),\n            inner_strides: v.strides.remove_axis(axis),\n            ptr: v.ptr.as_ptr(),\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterCore::<A, D>::next_back_with_index":["/// Does the same thing as `.next_back()` but also returns the index of the\n/// item relative to the start of the axis.\nfn next_back_with_index(&mut self) -> Option<(usize, *mut A)>{\n        self.next_back().map(|ptr| (self.end, ptr))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterCore::<A, D>::next_with_index":["/// Does the same thing as `.next()` but also returns the index of the item\n/// relative to the start of the axis.\nfn next_with_index(&mut self) -> Option<(usize, *mut A)>{\n        let index = self.index;\n        self.next().map(|ptr| (index, ptr))\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterCore::<A, D>::offset":["#[inline]\nunsafe fn offset(&self, index: usize) -> *mut A{\n        debug_assert!(\n            index < self.end,\n            \"index={}, end={}, stride={}\",\n            index,\n            self.end,\n            self.stride\n        );\n        self.ptr.offset(index as isize * self.stride)\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterCore::<A, D>::split_at":["/// Splits the iterator at `index`, yielding two disjoint iterators.\n///\n/// `index` is relative to the current state of the iterator (which is not\n/// necessarily the start of the axis).\n///\n/// **Panics** if `index` is strictly greater than the iterator's remaining\n/// length.\nfn split_at(self, index: usize) -> (Self, Self){\n        assert!(index <= self.len());\n        let mid = self.index + index;\n        let left = AxisIterCore {\n            index: self.index,\n            end: mid,\n            stride: self.stride,\n            inner_dim: self.inner_dim.clone(),\n            inner_strides: self.inner_strides.clone(),\n            ptr: self.ptr,\n        };\n        let right = AxisIterCore {\n            index: mid,\n            end: self.end,\n            stride: self.stride,\n            inner_dim: self.inner_dim,\n            inner_strides: self.inner_strides,\n            ptr: self.ptr,\n        };\n        (left, right)\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterMut":["/// An iterator that traverses over an axis and\n/// and yields each subview (mutable)\n///\n/// The outermost dimension is `Axis(0)`, created with `.outer_iter()`,\n/// but you can traverse arbitrary dimension with `.axis_iter()`.\n///\n/// For example, in a 3  5  5 array, with `axis` equal to `Axis(2)`,\n/// the iterator element is a 3  5 subview (and there are 5 in total).\n///\n/// Iterator element type is `ArrayViewMut<'a, A, D>`.\n///\n/// See [`.outer_iter_mut()`](../struct.ArrayBase.html#method.outer_iter_mut)\n/// or [`.axis_iter_mut()`](../struct.ArrayBase.html#method.axis_iter_mut)\n/// for more information.\npub struct AxisIterMut<'a, A, D> {\n    iter: AxisIterCore<A, D>,\n    life: PhantomData<&'a mut A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterMut::<'a, A, D>::new":["/// Creates a new iterator over the specified axis.\npub(crate) fn new<Di>(v: ArrayViewMut<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: RemoveAxis<Smaller = D>,{\n        AxisIterMut {\n            iter: AxisIterCore::new(v, axis),\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::AxisIterMut::<'a, A, D>::split_at":["/// Splits the iterator at `index`, yielding two disjoint iterators.\n///\n/// `index` is relative to the current state of the iterator (which is not\n/// necessarily the start of the axis).\n///\n/// **Panics** if `index` is strictly greater than the iterator's remaining\n/// length.\npub fn split_at(self, index: usize) -> (Self, Self){\n        let (left, right) = self.iter.split_at(index);\n        (\n            AxisIterMut {\n                iter: left,\n                life: self.life,\n            },\n            AxisIterMut {\n                iter: right,\n                life: self.life,\n            },\n        )\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::Baseiter":["/// Base for iterators over all axes.\n///\n/// Iterator element type is `*mut A`.\npub struct Baseiter<A, D> {\n    ptr: *mut A,\n    dim: D,\n    strides: D,\n    index: Option<D>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::Baseiter::<A, D>::new":["/// Creating a Baseiter is unsafe because shape and stride parameters need\n/// to be correct to avoid performing an unsafe pointer offset while\n/// iterating.\n#[inline]\npub unsafe fn new(ptr: *mut A, len: D, stride: D) -> Baseiter<A, D>{\n        Baseiter {\n            ptr,\n            index: len.first_index(),\n            dim: len,\n            strides: stride,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::ElementsBase":["/// Counted read only iterator\npub struct ElementsBase<'a, A, D> {\n    inner: Baseiter<A, D>,\n    life: PhantomData<&'a A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::ElementsBase::<'a, A, D>::new":["pub fn new(v: ArrayView<'a, A, D>) -> Self{\n        ElementsBase {\n            inner: v.into_base_iter(),\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::ElementsBaseMut":["/// An iterator over the elements of an array.\n///\n/// Iterator element type is `&'a mut A`.\npub struct ElementsBaseMut<'a, A, D> {\n    inner: Baseiter<A, D>,\n    life: PhantomData<&'a mut A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::ElementsBaseMut::<'a, A, D>::new":["pub fn new(v: ArrayViewMut<'a, A, D>) -> Self{\n        ElementsBaseMut {\n            inner: v.into_base_iter(),\n            life: PhantomData,\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::ElementsRepr":["pub enum ElementsRepr<S, C> {\n    Slice(S),\n    Counted(C),\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::IndexedIter":["/// An iterator over the indexes and elements of an array.\n///\n/// See [`.indexed_iter()`](../struct.ArrayBase.html#method.indexed_iter) for more information.\npub struct IndexedIter<'a, A, D>(ElementsBase<'a, A, D>);","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::IndexedIter::<'a, A, D>::new":["pub(crate) fn new(x: ElementsBase<'a, A, D>) -> Self{\n        IndexedIter(x)\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::IndexedIterMut":["/// An iterator over the indexes and elements of an array (mutable).\n///\n/// See [`.indexed_iter_mut()`](../struct.ArrayBase.html#method.indexed_iter_mut) for more information.\npub struct IndexedIterMut<'a, A, D>(ElementsBaseMut<'a, A, D>);","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::IndexedIterMut::<'a, A, D>::new":["pub(crate) fn new(x: ElementsBaseMut<'a, A, D>) -> Self{\n        IndexedIterMut(x)\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::Iter":["/// An iterator over the elements of an array.\n///\n/// Iterator element type is `&'a A`.\n///\n/// See [`.iter()`](../struct.ArrayBase.html#method.iter) for more information.\npub struct Iter<'a, A, D> {\n    inner: ElementsRepr<SliceIter<'a, A>, ElementsBase<'a, A, D>>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::Iter::<'a, A, D>::new":["pub(crate) fn new(self_: ArrayView<'a, A, D>) -> Self{\n        Iter {\n            inner: if let Some(slc) = self_.to_slice() {\n                ElementsRepr::Slice(slc.iter())\n            } else {\n                ElementsRepr::Counted(self_.into_elements_base())\n            },\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::IterMut":["/// An iterator over the elements of an array (mutable).\n///\n/// Iterator element type is `&'a mut A`.\n///\n/// See [`.iter_mut()`](../struct.ArrayBase.html#method.iter_mut) for more information.\npub struct IterMut<'a, A, D> {\n    inner: ElementsRepr<SliceIterMut<'a, A>, ElementsBaseMut<'a, A, D>>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::IterMut::<'a, A, D>::new":["pub(crate) fn new(self_: ArrayViewMut<'a, A, D>) -> Self{\n        IterMut {\n            inner: match self_.into_slice_() {\n                Ok(x) => ElementsRepr::Slice(x.iter_mut()),\n                Err(self_) => ElementsRepr::Counted(self_.into_elements_base()),\n            },\n        }\n    }","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::LanesIter":["/// An iterator that traverses over all axes but one, and yields a view for\n/// each lane along that axis.\n///\n/// See [`.lanes()`](../struct.ArrayBase.html#method.lanes) for more information.\npub struct LanesIter<'a, A, D> {\n    inner_len: Ix,\n    inner_stride: Ixs,\n    iter: Baseiter<A, D>,\n    life: PhantomData<&'a A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::LanesIterMut":["/// An iterator that traverses over all dimensions but the innermost,\n/// and yields each inner row (mutable).\n///\n/// See [`.lanes_mut()`](../struct.ArrayBase.html#method.lanes_mut)\n/// for more information.\npub struct LanesIterMut<'a, A, D> {\n    inner_len: Ix,\n    inner_stride: Ixs,\n    iter: Baseiter<A, D>,\n    life: PhantomData<&'a mut A>,\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::TrustedIterator":["/// (Trait used internally) An iterator that we trust\n/// to deliver exactly as many items as it said it would.\n///\n/// The iterator must produce exactly the number of elements it reported or\n/// diverge before reaching the end.\npub unsafe trait TrustedIterator {}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::chunk_iter_parts":["/// Computes the information necessary to construct an iterator over chunks\n/// along an axis, given a `view` of the array, the `axis` to iterate over, and\n/// the chunk `size`.\n///\n/// Returns an axis iterator with the correct stride to move between chunks,\n/// the number of chunks, and the shape of the last chunk.\n///\n/// **Panics** if `size == 0`.\nfn chunk_iter_parts<A, D: Dimension>(\n    v: ArrayView<'_, A, D>,\n    axis: Axis,\n    size: usize,\n) -> (AxisIterCore<A, D>, usize, D){\n    assert_ne!(size, 0, \"Chunk size must be nonzero.\");\n    let axis_len = v.len_of(axis);\n    let n_whole_chunks = axis_len / size;\n    let chunk_remainder = axis_len % size;\n    let iter_len = if chunk_remainder == 0 {\n        n_whole_chunks\n    } else {\n        n_whole_chunks + 1\n    };\n    let stride = if n_whole_chunks == 0 {\n        // This case avoids potential overflow when `size > axis_len`.\n        0\n    } else {\n        v.stride_of(axis) * size as isize\n    };\n\n    let axis = axis.index();\n    let mut inner_dim = v.dim.clone();\n    inner_dim[axis] = size;\n\n    let mut partial_chunk_dim = v.dim;\n    partial_chunk_dim[axis] = chunk_remainder;\n    let partial_chunk_index = n_whole_chunks;\n\n    let iter = AxisIterCore {\n        index: 0,\n        end: iter_len,\n        stride,\n        inner_dim,\n        inner_strides: v.strides,\n        ptr: v.ptr.as_ptr(),\n    };\n\n    (iter, partial_chunk_index, partial_chunk_dim)\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::chunks::ExactChunks":["/// Exact chunks producer and iterable.\n///\n/// See [`.exact_chunks()`](../struct.ArrayBase.html#method.exact_chunks) for more\n/// information.\npub struct ExactChunks<'a, A, D> {\n    base: BaseProducerRef<'a, A, D>,\n    chunk: D,\n    inner_strides: D,\n}","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"iterators::chunks::ExactChunks::<'a, A, D>::new":["/// Creates a new exact chunks producer.\n///\n/// **Panics** if any chunk dimension is zero\npub(crate) fn new<E>(mut a: ArrayView<'a, A, D>, chunk: E) -> Self\n    where\n        E: IntoDimension<Dim = D>,{\n        let chunk = chunk.into_dimension();\n        ndassert!(\n            a.ndim() == chunk.ndim(),\n            concat!(\n                \"Chunk dimension {} does not match array dimension {} \",\n                \"(with array of shape {:?})\"\n            ),\n            chunk.ndim(),\n            a.ndim(),\n            a.shape()\n        );\n        for i in 0..a.ndim() {\n            a.dim[i] /= chunk[i];\n        }\n        let inner_strides = a.raw_strides();\n        a.strides *= &chunk;\n\n        ExactChunks {\n            base: a,\n            chunk,\n            inner_strides,\n        }\n    }","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"iterators::chunks::ExactChunksIter":["/// Exact chunks iterator.\n///\n/// See [`.exact_chunks()`](../struct.ArrayBase.html#method.exact_chunks) for more\n/// information.\npub struct ExactChunksIter<'a, A, D> {\n    iter: ElementsBase<'a, A, D>,\n    chunk: D,\n    inner_strides: D,\n}","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"iterators::chunks::ExactChunksIterMut":["/// Exact chunks iterator.\n///\n/// See [`.exact_chunks_mut()`](../struct.ArrayBase.html#method.exact_chunks_mut)\n/// for more information.\npub struct ExactChunksIterMut<'a, A, D> {\n    iter: ElementsBaseMut<'a, A, D>,\n    chunk: D,\n    inner_strides: D,\n}","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"iterators::chunks::ExactChunksMut":["/// Exact chunks producer and iterable.\n///\n/// See [`.exact_chunks_mut()`](../struct.ArrayBase.html#method.exact_chunks_mut)\n/// for more information.\npub struct ExactChunksMut<'a, A, D> {\n    base: BaseProducerMut<'a, A, D>,\n    chunk: D,\n    inner_strides: D,\n}","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"iterators::chunks::ExactChunksMut::<'a, A, D>::new":["/// Creates a new exact chunks producer.\n///\n/// **Panics** if any chunk dimension is zero\npub(crate) fn new<E>(mut a: ArrayViewMut<'a, A, D>, chunk: E) -> Self\n    where\n        E: IntoDimension<Dim = D>,{\n        let chunk = chunk.into_dimension();\n        ndassert!(\n            a.ndim() == chunk.ndim(),\n            concat!(\n                \"Chunk dimension {} does not match array dimension {} \",\n                \"(with array of shape {:?})\"\n            ),\n            chunk.ndim(),\n            a.ndim(),\n            a.shape()\n        );\n        for i in 0..a.ndim() {\n            a.dim[i] /= chunk[i];\n        }\n        let inner_strides = a.raw_strides();\n        a.strides *= &chunk;\n\n        ExactChunksMut {\n            base: a,\n            chunk,\n            inner_strides,\n        }\n    }","Real(LocalPath(\"src/iterators/chunks.rs\"))"],"iterators::lanes::Lanes":["/// See [`.lanes()`](../struct.ArrayBase.html#method.lanes)\n/// for more information.\npub struct Lanes<'a, A, D> {\n    base: ArrayView<'a, A, D>,\n    inner_len: Ix,\n    inner_stride: Ixs,\n}","Real(LocalPath(\"src/iterators/lanes.rs\"))"],"iterators::lanes::Lanes::<'a, A, D>::new":["pub(crate) fn new<Di>(v: ArrayView<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: Dimension<Smaller = D>,{\n        let ndim = v.ndim();\n        let len;\n        let stride;\n        let iter_v;\n        if ndim == 0 {\n            len = 1;\n            stride = 1;\n            iter_v = v.try_remove_axis(Axis(0))\n        } else {\n            let i = axis.index();\n            len = v.dim[i];\n            stride = v.strides[i] as isize;\n            iter_v = v.try_remove_axis(axis)\n        }\n        Lanes {\n            inner_len: len,\n            inner_stride: stride,\n            base: iter_v,\n        }\n    }","Real(LocalPath(\"src/iterators/lanes.rs\"))"],"iterators::lanes::LanesMut":["/// See [`.lanes_mut()`](../struct.ArrayBase.html#method.lanes_mut)\n/// for more information.\npub struct LanesMut<'a, A, D> {\n    base: ArrayViewMut<'a, A, D>,\n    inner_len: Ix,\n    inner_stride: Ixs,\n}","Real(LocalPath(\"src/iterators/lanes.rs\"))"],"iterators::lanes::LanesMut::<'a, A, D>::new":["pub(crate) fn new<Di>(v: ArrayViewMut<'a, A, Di>, axis: Axis) -> Self\n    where\n        Di: Dimension<Smaller = D>,{\n        let ndim = v.ndim();\n        let len;\n        let stride;\n        let iter_v;\n        if ndim == 0 {\n            len = 1;\n            stride = 1;\n            iter_v = v.try_remove_axis(Axis(0))\n        } else {\n            let i = axis.index();\n            len = v.dim[i];\n            stride = v.strides[i] as isize;\n            iter_v = v.try_remove_axis(axis)\n        }\n        LanesMut {\n            inner_len: len,\n            inner_stride: stride,\n            base: iter_v,\n        }\n    }","Real(LocalPath(\"src/iterators/lanes.rs\"))"],"iterators::to_vec":["/// Like Iterator::collect, but only for trusted length iterators\npub fn to_vec<I>(iter: I) -> Vec<I::Item>\nwhere\n    I: TrustedIterator + ExactSizeIterator,{\n    to_vec_mapped(iter, |x| x)\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::to_vec_mapped":["/// Like Iterator::collect, but only for trusted length iterators\npub fn to_vec_mapped<I, F, B>(iter: I, mut f: F) -> Vec<B>\nwhere\n    I: TrustedIterator + ExactSizeIterator,\n    F: FnMut(I::Item) -> B,{\n    // Use an `unsafe` block to do this efficiently.\n    // We know that iter will produce exactly .size() elements,\n    // and the loop can vectorize if it's clean (without branch to grow the vector).\n    let (size, _) = iter.size_hint();\n    let mut result = Vec::with_capacity(size);\n    let mut out_ptr = result.as_mut_ptr();\n    let mut len = 0;\n    iter.fold((), |(), elt| unsafe {\n        ptr::write(out_ptr, f(elt));\n        len += 1;\n        result.set_len(len);\n        out_ptr = out_ptr.offset(1);\n    });\n    debug_assert_eq!(size, result.len());\n    result\n}","Real(LocalPath(\"src/iterators/mod.rs\"))"],"iterators::windows::Windows":["/// Window producer and iterable\n///\n/// See [`.windows()`](../struct.ArrayBase.html#method.windows) for more\n/// information.\npub struct Windows<'a, A, D> {\n    base: ArrayView<'a, A, D>,\n    window: D,\n    strides: D,\n}","Real(LocalPath(\"src/iterators/windows.rs\"))"],"iterators::windows::Windows::<'a, A, D>::new":["pub(crate) fn new<E>(a: ArrayView<'a, A, D>, window_size: E) -> Self\n    where\n        E: IntoDimension<Dim = D>,{\n        let window = window_size.into_dimension();\n        ndassert!(\n            a.ndim() == window.ndim(),\n            concat!(\n                \"Window dimension {} does not match array dimension {} \",\n                \"(with array of shape {:?})\"\n            ),\n            window.ndim(),\n            a.ndim(),\n            a.shape()\n        );\n        let mut size = a.dim;\n        for (sz, &ws) in size.slice_mut().iter_mut().zip(window.slice()) {\n            assert_ne!(ws, 0, \"window-size must not be zero!\");\n            // cannot use std::cmp::max(0, ..) since arithmetic underflow panics\n            *sz = if *sz < ws { 0 } else { *sz - ws + 1 };\n        }\n\n        let window_strides = a.strides.clone();\n\n        unsafe {\n            Windows {\n                base: ArrayView::from_shape_ptr(size.strides(a.strides), a.ptr.as_ptr()),\n                window,\n                strides: window_strides,\n            }\n        }\n    }","Real(LocalPath(\"src/iterators/windows.rs\"))"],"iterators::windows::WindowsIter":["/// Window iterator.\n///\n/// See [`.windows()`](../struct.ArrayBase.html#method.windows) for more\n/// information.\npub struct WindowsIter<'a, A, D> {\n    iter: ElementsBase<'a, A, D>,\n    window: D,\n    strides: D,\n}","Real(LocalPath(\"src/iterators/windows.rs\"))"],"itertools::enumerate":["/// Iterate `iterable` with a running index.\n///\n/// `IntoIterator` enabled version of `.enumerate()`.\n///\n/// ```\n/// use itertools::enumerate;\n///\n/// for (i, elt) in enumerate(&[1, 2, 3]) {\n///     /* loop body */\n/// }\n/// ```\npub(crate) fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\nwhere\n    I: IntoIterator,{\n    iterable.into_iter().enumerate()\n}","Real(LocalPath(\"src/itertools.rs\"))"],"itertools::zip":["/// Iterate `i` and `j` in lock step.\n///\n/// `IntoIterator` enabled version of `i.zip(j)`.\n///\n/// ```\n/// use itertools::zip;\n///\n/// let data = [1, 2, 3, 4, 5];\n/// for (a, b) in zip(&data, &data[1..]) {\n///     /* loop body */\n/// }\n/// ```\npub(crate) fn zip<I, J>(i: I, j: J) -> iter::Zip<I::IntoIter, J::IntoIter>\nwhere\n    I: IntoIterator,\n    J: IntoIterator,{\n    i.into_iter().zip(j)\n}","Real(LocalPath(\"src/itertools.rs\"))"],"layout::Layout":["#[doc(hidden)]\n/// Memory layout description\npub struct Layout(u32);","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::and":["#[inline(always)]\npub(crate) fn and(self, flag: Layout) -> Layout{\n        Layout(self.0 & flag.0)\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::c":["#[doc(hidden)]\n#[inline(always)]\npub fn c() -> Layout{\n        Layout(CORDER)\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::f":["#[doc(hidden)]\n#[inline(always)]\npub fn f() -> Layout{\n        Layout(FORDER)\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::flag":["#[inline(always)]\npub(crate) fn flag(self) -> u32{\n        self.0\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::is":["#[inline(always)]\npub(crate) fn is(self, flag: u32) -> bool{\n        self.0 & flag != 0\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::new":["#[inline(always)]\npub(crate) fn new(x: u32) -> Self{\n        Layout(x)\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::none":["#[inline(always)]\n#[doc(hidden)]\npub fn none() -> Layout{\n        Layout(0)\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::Layout::one_dimensional":["#[doc(hidden)]\n#[inline(always)]\npub fn one_dimensional() -> Layout{\n        Layout(CORDER | FORDER)\n    }","Real(LocalPath(\"src/layout/mod.rs\"))"],"layout::layoutfmt::<impl std::fmt::Debug for layout::Layout>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if self.0 == 0 {\n            write!(f, \"Custom\")?\n        } else {\n            (0..32).filter(|&i| self.is(1 << i)).try_fold((), |_, i| {\n                if let Some(name) = LAYOUT_NAMES.get(i) {\n                    write!(f, \"{}\", name)\n                } else {\n                    write!(f, \"{:#x}\", i)\n                }\n            })?;\n        };\n        write!(f, \" ({:#x})\", self.0)\n    }","Real(LocalPath(\"src/layout/layoutfmt.rs\"))"],"linalg::impl_linalg::<impl ArrayBase<S, D>>::scaled_add":["/// Perform the operation `self += alpha * rhs` efficiently, where\n/// `alpha` is a scalar and `rhs` is another array. This operation is\n/// also known as `axpy` in BLAS.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// **Panics** if broadcasting isnt possible.\npub fn scaled_add<S2, E>(&mut self, alpha: A, rhs: &ArrayBase<S2, E>)\n    where\n        S: DataMut,\n        S2: Data<Elem = A>,\n        A: LinalgScalar,\n        E: Dimension,{\n        self.zip_mut_with(rhs, move |y, &x| *y = *y + (alpha * x));\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot":["/// Perform dot product or matrix multiplication of arrays `self` and `rhs`.\n///\n/// `Rhs` may be either a one-dimensional or a two-dimensional array.\n///\n/// If `Rhs` is one-dimensional, then the operation is a vector dot\n/// product, which is the sum of the elementwise products (no conjugation\n/// of complex operands, and thus not their inner product). In this case,\n/// `self` and `rhs` must be the same length.\n///\n/// If `Rhs` is two-dimensional, then the operation is matrix\n/// multiplication, where `self` is treated as a row vector. In this case,\n/// if `self` is shape *M*, then `rhs` is shape *M*  *N* and the result is\n/// shape *N*.\n///\n/// **Panics** if the array shapes are incompatible.<br>\n/// *Note:* If enabled, uses blas `dot` for elements of `f32, f64` when memory\n/// layout allows.\npub fn dot<Rhs>(&self, rhs: &Rhs) -> <Self as Dot<Rhs>>::Output\n    where\n        Self: Dot<Rhs>,{\n        Dot::dot(self, rhs)\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot_generic":["fn dot_generic<S2>(&self, rhs: &ArrayBase<S2, Ix1>) -> A\n    where\n        S2: Data<Elem = A>,\n        A: LinalgScalar,{\n        debug_assert_eq!(self.len(), rhs.len());\n        assert!(self.len() == rhs.len());\n        if let Some(self_s) = self.as_slice() {\n            if let Some(rhs_s) = rhs.as_slice() {\n                return numeric_util::unrolled_dot(self_s, rhs_s);\n            }\n        }\n        let mut sum = A::zero();\n        for i in 0..self.len() {\n            unsafe {\n                sum = sum + *self.uget(i) * *rhs.uget(i);\n            }\n        }\n        sum\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot_impl":["#[cfg(not(feature = \"blas\"))]\nfn dot_impl<S2>(&self, rhs: &ArrayBase<S2, Ix1>) -> A\n    where\n        S2: Data<Elem = A>,\n        A: LinalgScalar,{\n        self.dot_generic(rhs)\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::dot":["/// Perform matrix multiplication of rectangular arrays `self` and `rhs`.\n///\n/// `Rhs` may be either a one-dimensional or a two-dimensional array.\n///\n/// If Rhs is two-dimensional, they array shapes must agree in the way that\n/// if `self` is *M*  *N*, then `rhs` is *N*  *K*.\n///\n/// Return a result array with shape *M*  *K*.\n///\n/// **Panics** if shapes are incompatible or the number of elements in the\n/// result would overflow `isize`.\n///\n/// *Note:* If enabled, uses blas `gemv/gemm` for elements of `f32, f64`\n/// when memory layout allows. The default matrixmultiply backend\n/// is otherwise used for `f32, f64` for all memory layouts.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[1., 2.],\n///                [0., 1.]]);\n/// let b = arr2(&[[1., 2.],\n///                [2., 3.]]);\n///\n/// assert!(\n///     a.dot(&b) == arr2(&[[5., 8.],\n///                         [2., 3.]])\n/// );\n/// ```\npub fn dot<Rhs>(&self, rhs: &Rhs) -> <Self as Dot<Rhs>>::Output\n    where\n        Self: Dot<Rhs>,{\n        Dot::dot(self, rhs)\n    }","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::Dot":["/// Matrix Multiplication\n///\n/// For two-dimensional arrays, the dot method computes the matrix\n/// multiplication.\npub trait Dot<Rhs> {\n    /// The result of the operation.\n    ///\n    /// For two-dimensional arrays: a rectangular array.\n    type Output;\n    fn dot(&self, rhs: &Rhs) -> Self::Output;\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::cast_as":["fn cast_as<A: 'static + Copy, B: 'static + Copy>(a: &A) -> B{\n    assert!(same_type::<A, B>());\n    unsafe { ::std::ptr::read(a as *const _ as *const B) }\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::dot_shape_error":["/// Assumes that `m` and `n` are  `isize::MAX`.\n#[cold]\n#[inline(never)]\nfn dot_shape_error(m: usize, k: usize, k2: usize, n: usize) -> !{\n    match m.checked_mul(n) {\n        Some(len) if len <= ::std::isize::MAX as usize => {}\n        _ => panic!(\"ndarray: shape {}  {} overflows isize\", m, n),\n    }\n    panic!(\n        \"ndarray: inputs {}  {} and {}  {} are not compatible for matrix multiplication\",\n        m, k, k2, n\n    );\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::general_dot_shape_error":["#[cold]\n#[inline(never)]\nfn general_dot_shape_error(m: usize, k: usize, k2: usize, n: usize, c1: usize, c2: usize) -> !{\n    panic!(\"ndarray: inputs {}  {}, {}  {}, and output {}  {} are not compatible for matrix multiplication\",\n           m, k, k2, n, c1, c2);\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::general_mat_mul":["/// General matrix-matrix multiplication.\n///\n/// Compute C   A B +  C\n///\n/// The array shapes must agree in the way that\n/// if `a` is *M*  *N*, then `b` is *N*  *K* and `c` is *M*  *K*.\n///\n/// ***Panics*** if array shapes are not compatible<br>\n/// *Note:* If enabled, uses blas `gemm` for elements of `f32, f64` when memory\n/// layout allows.  The default matrixmultiply backend is otherwise used for\n/// `f32, f64` for all memory layouts.\npub fn general_mat_mul<A, S1, S2, S3>(\n    alpha: A,\n    a: &ArrayBase<S1, Ix2>,\n    b: &ArrayBase<S2, Ix2>,\n    beta: A,\n    c: &mut ArrayBase<S3, Ix2>,\n) where\n    S1: Data<Elem = A>,\n    S2: Data<Elem = A>,\n    S3: DataMut<Elem = A>,\n    A: LinalgScalar,{\n    let ((m, k), (k2, n)) = (a.dim(), b.dim());\n    let (m2, n2) = c.dim();\n    if k != k2 || m != m2 || n != n2 {\n        general_dot_shape_error(m, k, k2, n, m2, n2);\n    } else {\n        mat_mul_impl(alpha, &a.view(), &b.view(), beta, &mut c.view_mut());\n    }\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::general_mat_vec_mul":["/// General matrix-vector multiplication.\n///\n/// Compute y   A x +  y\n///\n/// where A is a *M*  *N* matrix and x is an *N*-element column vector and\n/// y an *M*-element column vector (one dimensional arrays).\n///\n/// ***Panics*** if array shapes are not compatible<br>\n/// *Note:* If enabled, uses blas `gemv` for elements of `f32, f64` when memory\n/// layout allows.\n#[allow(clippy::collapsible_if)]\npub fn general_mat_vec_mul<A, S1, S2, S3>(\n    alpha: A,\n    a: &ArrayBase<S1, Ix2>,\n    x: &ArrayBase<S2, Ix1>,\n    beta: A,\n    y: &mut ArrayBase<S3, Ix1>,\n) where\n    S1: Data<Elem = A>,\n    S2: Data<Elem = A>,\n    S3: DataMut<Elem = A>,\n    A: LinalgScalar,{\n    let ((m, k), k2) = (a.dim(), x.dim());\n    let m2 = y.dim();\n    if k != k2 || m != m2 {\n        general_dot_shape_error(m, k, k2, 1, m2, 1);\n    } else {\n        #[cfg(feature = \"blas\")]\n        macro_rules! gemv {\n            ($ty:ty, $gemv:ident) => {\n                if let Some(layout) = blas_layout::<$ty, _>(&a) {\n                    if blas_compat_1d::<$ty, _>(&x) && blas_compat_1d::<$ty, _>(&y) {\n                        // Determine stride between rows or columns. Note that the stride is\n                        // adjusted to at least `k` or `m` to handle the case of a matrix with a\n                        // trivial (length 1) dimension, since the stride for the trivial dimension\n                        // may be arbitrary.\n                        let a_trans = CblasNoTrans;\n                        let a_stride = match layout {\n                            CBLAS_LAYOUT::CblasRowMajor => {\n                                a.strides()[0].max(k as isize) as blas_index\n                            }\n                            CBLAS_LAYOUT::CblasColMajor => {\n                                a.strides()[1].max(m as isize) as blas_index\n                            }\n                        };\n\n                        let x_stride = x.strides()[0] as blas_index;\n                        let y_stride = y.strides()[0] as blas_index;\n\n                        unsafe {\n                            blas_sys::$gemv(\n                                layout,\n                                a_trans,\n                                m as blas_index,            // m, rows of Op(a)\n                                k as blas_index,            // n, cols of Op(a)\n                                cast_as(&alpha),            // alpha\n                                a.ptr.as_ptr() as *const _, // a\n                                a_stride,                   // lda\n                                x.ptr.as_ptr() as *const _, // x\n                                x_stride,\n                                cast_as(&beta),           // beta\n                                y.ptr.as_ptr() as *mut _, // x\n                                y_stride,\n                            );\n                        }\n                        return;\n                    }\n                }\n            };\n        }\n        #[cfg(feature = \"blas\")]\n        gemv!(f32, cblas_sgemv);\n        #[cfg(feature = \"blas\")]\n        gemv!(f64, cblas_dgemv);\n\n        /* general */\n\n        if beta.is_zero() {\n            Zip::from(a.outer_iter()).and(y).apply(|row, elt| {\n                *elt = row.dot(x) * alpha;\n            });\n        } else {\n            Zip::from(a.outer_iter()).and(y).apply(|row, elt| {\n                *elt = *elt * beta + row.dot(x) * alpha;\n            });\n        }\n    }\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::mat_mul_general":["/// C   A B +  C\nfn mat_mul_general<A>(\n    alpha: A,\n    lhs: &ArrayView2<'_, A>,\n    rhs: &ArrayView2<'_, A>,\n    beta: A,\n    c: &mut ArrayViewMut2<'_, A>,\n) where\n    A: LinalgScalar,{\n    let ((m, k), (_, n)) = (lhs.dim(), rhs.dim());\n\n    // common parameters for gemm\n    let ap = lhs.as_ptr();\n    let bp = rhs.as_ptr();\n    let cp = c.as_mut_ptr();\n    let (rsc, csc) = (c.strides()[0], c.strides()[1]);\n    if same_type::<A, f32>() {\n        unsafe {\n            ::matrixmultiply::sgemm(\n                m,\n                k,\n                n,\n                cast_as(&alpha),\n                ap as *const _,\n                lhs.strides()[0],\n                lhs.strides()[1],\n                bp as *const _,\n                rhs.strides()[0],\n                rhs.strides()[1],\n                cast_as(&beta),\n                cp as *mut _,\n                rsc,\n                csc,\n            );\n        }\n    } else if same_type::<A, f64>() {\n        unsafe {\n            ::matrixmultiply::dgemm(\n                m,\n                k,\n                n,\n                cast_as(&alpha),\n                ap as *const _,\n                lhs.strides()[0],\n                lhs.strides()[1],\n                bp as *const _,\n                rhs.strides()[0],\n                rhs.strides()[1],\n                cast_as(&beta),\n                cp as *mut _,\n                rsc,\n                csc,\n            );\n        }\n    } else {\n        // It's a no-op if `c` has zero length.\n        if c.is_empty() {\n            return;\n        }\n\n        // initialize memory if beta is zero\n        if beta.is_zero() {\n            c.fill(beta);\n        }\n\n        let mut i = 0;\n        let mut j = 0;\n        loop {\n            unsafe {\n                let elt = c.uget_mut((i, j));\n                *elt = *elt * beta\n                    + alpha\n                        * (0..k).fold(A::zero(), move |s, x| {\n                            s + *lhs.uget((i, x)) * *rhs.uget((x, j))\n                        });\n            }\n            j += 1;\n            if j == n {\n                j = 0;\n                i += 1;\n                if i == m {\n                    break;\n                }\n            }\n        }\n    }\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg::impl_linalg::same_type":["#[inline(always)]\n/// Return `true` if `A` and `B` are the same type\nfn same_type<A: 'static, B: 'static>() -> bool{\n    TypeId::of::<A>() == TypeId::of::<B>()\n}","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))"],"linalg_traits::LinalgScalar":["/// Elements that support linear algebra operations.\n///\n/// `'static` for type-based specialization, `Copy` so that they don't need move\n/// semantics or destructors, and the rest are numerical traits.\npub trait LinalgScalar:\n    'static\n    + Copy\n    + Zero\n    + One\n    + Add<Output = Self>\n    + Sub<Output = Self>\n    + Mul<Output = Self>\n    + Div<Output = Self>\n{\n}","Real(LocalPath(\"src/linalg_traits.rs\"))"],"linalg_traits::NdFloat":["/// Floating-point element types `f32` and `f64`.\n///\n/// Trait `NdFloat` is only implemented for `f32` and `f64` but encompasses as\n/// much float-relevant ndarray functionality as possible, including the traits\n/// needed for linear algebra and for *right hand side* scalar\n/// operations (`ScalarOperand`).\n///\n/// This trait can only be implemented by `f32` and `f64`.\npub trait NdFloat:\n    Float\n    + AddAssign\n    + SubAssign\n    + MulAssign\n    + DivAssign\n    + RemAssign\n    + fmt::Display\n    + fmt::Debug\n    + fmt::LowerExp\n    + fmt::UpperExp\n    + ScalarOperand\n    + LinalgScalar\n    + Send\n    + Sync\n{\n}","Real(LocalPath(\"src/linalg_traits.rs\"))"],"linspace::Linspace":["/// An iterator of a sequence of evenly spaced floats.\n///\n/// Iterator element type is `F`.\npub struct Linspace<F> {\n    start: F,\n    step: F,\n    index: usize,\n    len: usize,\n}","Real(LocalPath(\"src/linspace.rs\"))"],"linspace::linspace":["/// Return an iterator of evenly spaced floats.\n///\n/// The `Linspace` has `n` elements from `a` to `b` (inclusive).\n///\n/// The iterator element type is `F`, where `F` must implement `Float`, e.g.\n/// `f32` or `f64`.\n///\n/// **Panics** if converting `n - 1` to type `F` fails.\n#[inline]\npub fn linspace<F>(a: F, b: F, n: usize) -> Linspace<F>\nwhere\n    F: Float,{\n    let step = if n > 1 {\n        let num_steps = F::from(n - 1).expect(\"Converting number of steps to `A` must not fail.\");\n        (b - a) / num_steps\n    } else {\n        F::zero()\n    };\n    Linspace {\n        start: a,\n        step,\n        index: 0,\n        len: n,\n    }\n}","Real(LocalPath(\"src/linspace.rs\"))"],"linspace::range":["/// Return an iterator of floats from `start` to `end` (exclusive),\n/// incrementing by `step`.\n///\n/// Numerical reasons can result in `b` being included in the result.\n///\n/// The iterator element type is `F`, where `F` must implement `Float`, e.g.\n/// `f32` or `f64`.\n///\n/// **Panics** if converting `((b - a) / step).ceil()` to type `F` fails.\n#[inline]\npub fn range<F>(a: F, b: F, step: F) -> Linspace<F>\nwhere\n    F: Float,{\n    let len = b - a;\n    let steps = F::ceil(len / step);\n    Linspace {\n        start: a,\n        step,\n        len: steps.to_usize().expect(\n            \"Converting the length to `usize` must not fail. The most likely \\\n             cause of this failure is if the sign of `end - start` is \\\n             different from the sign of `step`.\",\n        ),\n        index: 0,\n    }\n}","Real(LocalPath(\"src/linspace.rs\"))"],"logspace::Logspace":["/// An iterator of a sequence of logarithmically spaced number.\n///\n/// Iterator element type is `F`.\npub struct Logspace<F> {\n    sign: F,\n    base: F,\n    start: F,\n    step: F,\n    index: usize,\n    len: usize,\n}","Real(LocalPath(\"src/logspace.rs\"))"],"logspace::logspace":["/// An iterator of a sequence of logarithmically spaced numbers.\n///\n/// The `Logspace` has `n` elements, where the first element is `base.powf(a)`\n/// and the last element is `base.powf(b)`.  If `base` is negative, this\n/// iterator will return all negative values.\n///\n/// The iterator element type is `F`, where `F` must implement `Float`, e.g.\n/// `f32` or `f64`.\n///\n/// **Panics** if converting `n - 1` to type `F` fails.\n#[inline]\npub fn logspace<F>(base: F, a: F, b: F, n: usize) -> Logspace<F>\nwhere\n    F: Float,{\n    let step = if n > 1 {\n        let num_steps = F::from(n - 1).expect(\"Converting number of steps to `A` must not fail.\");\n        (b - a) / num_steps\n    } else {\n        F::zero()\n    };\n    Logspace {\n        sign: base.signum(),\n        base: base.abs(),\n        start: a,\n        step,\n        index: 0,\n        len: n,\n    }\n}","Real(LocalPath(\"src/logspace.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::all_close":["/// Return `true` if the arrays' elementwise differences are all within\n/// the given absolute tolerance, `false` otherwise.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// **Panics** if broadcasting to the same shape isnt possible.\n#[deprecated(\n        note = \"Use `abs_diff_eq` - it requires the `approx` crate feature\",\n        since = \"0.13.0\"\n    )]\npub fn all_close<S2, E>(&self, rhs: &ArrayBase<S2, E>, tol: A) -> bool\n    where\n        A: Float,\n        S2: Data<Elem = A>,\n        E: Dimension,{\n        !Zip::from(self)\n            .and(rhs.broadcast_unwrap(self.raw_dim()))\n            .fold_while((), |_, x, y| {\n                if (*x - *y).abs() <= tol {\n                    FoldWhile::Continue(())\n                } else {\n                    FoldWhile::Done(())\n                }\n            })\n            .is_done()\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::mean":["/// Returns the [arithmetic mean] x of all elements in the array:\n///\n/// ```text\n///     1   n\n/// x =     x\n///     n  i=1\n/// ```\n///\n/// If the array is empty, `None` is returned.\n///\n/// **Panics** if `A::from_usize()` fails to convert the number of elements in the array.\n///\n/// [arithmetic mean]: https://en.wikipedia.org/wiki/Arithmetic_mean\npub fn mean(&self) -> Option<A>\n    where\n        A: Clone + FromPrimitive + Add<Output = A> + Div<Output = A> + Zero,{\n        let n_elements = self.len();\n        if n_elements == 0 {\n            None\n        } else {\n            let n_elements = A::from_usize(n_elements)\n                .expect(\"Converting number of elements to `A` must not fail.\");\n            Some(self.sum() / n_elements)\n        }\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::mean_axis":["/// Return mean along `axis`.\n///\n/// Return `None` if the length of the axis is zero.\n///\n/// **Panics** if `axis` is out of bounds or if `A::from_usize()`\n/// fails for the axis length.\n///\n/// ```\n/// use ndarray::{aview0, aview1, arr2, Axis};\n///\n/// let a = arr2(&[[1., 2., 3.],\n///                [4., 5., 6.]]);\n/// assert!(\n///     a.mean_axis(Axis(0)).unwrap() == aview1(&[2.5, 3.5, 4.5]) &&\n///     a.mean_axis(Axis(1)).unwrap() == aview1(&[2., 5.]) &&\n///\n///     a.mean_axis(Axis(0)).unwrap().mean_axis(Axis(0)).unwrap() == aview0(&3.5)\n/// );\n/// ```\npub fn mean_axis(&self, axis: Axis) -> Option<Array<A, D::Smaller>>\n    where\n        A: Clone + Zero + FromPrimitive + Add<Output = A> + Div<Output = A>,\n        D: RemoveAxis,{\n        let axis_length = self.len_of(axis);\n        if axis_length == 0 {\n            None\n        } else {\n            let axis_length =\n                A::from_usize(axis_length).expect(\"Converting axis length to `A` must not fail.\");\n            let sum = self.sum_axis(axis);\n            Some(sum / aview0(&axis_length))\n        }\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::product":["/// Return the product of all elements in the array.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[1., 2.],\n///                [3., 4.]]);\n/// assert_eq!(a.product(), 24.);\n/// ```\npub fn product(&self) -> A\n    where\n        A: Clone + Mul<Output = A> + num_traits::One,{\n        if let Some(slc) = self.as_slice_memory_order() {\n            return numeric_util::unrolled_fold(slc, A::one, A::mul);\n        }\n        let mut sum = A::one();\n        for row in self.inner_rows() {\n            if let Some(slc) = row.as_slice() {\n                sum = sum * numeric_util::unrolled_fold(slc, A::one, A::mul);\n            } else {\n                sum = sum * row.iter().fold(A::one(), |acc, elt| acc * elt.clone());\n            }\n        }\n        sum\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::scalar_sum":["/// Return the sum of all elements in the array.\n///\n/// *This method has been renamed to `.sum()` and will be deprecated in the\n/// next version.*\npub fn scalar_sum(&self) -> A\n    where\n        A: Clone + Add<Output = A> + num_traits::Zero,{\n        self.sum()\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::std_axis":["/// Return standard deviation along `axis`.\n///\n/// The standard deviation is computed from the variance using\n/// the [Welford one-pass algorithm](https://www.jstor.org/stable/1266577).\n///\n/// The parameter `ddof` specifies the \"delta degrees of freedom\". For\n/// example, to calculate the population standard deviation, use `ddof = 0`,\n/// or to calculate the sample standard deviation, use `ddof = 1`.\n///\n/// The standard deviation is defined as:\n///\n/// ```text\n///                   1       n          \n/// stddev = sqrt      (x - x)\n///                n - ddof  i=1         \n/// ```\n///\n/// where\n///\n/// ```text\n///     1   n\n/// x =     x\n///     n  i=1\n/// ```\n///\n/// and `n` is the length of the axis.\n///\n/// **Panics** if `ddof` is less than zero or greater than `n`, if `axis`\n/// is out of bounds, or if `A::from_usize()` fails for any any of the\n/// numbers in the range `0..=n`.\n///\n/// # Example\n///\n/// ```\n/// use ndarray::{aview1, arr2, Axis};\n///\n/// let a = arr2(&[[1., 2.],\n///                [3., 4.],\n///                [5., 6.]]);\n/// let stddev = a.std_axis(Axis(0), 1.);\n/// assert_eq!(stddev, aview1(&[2., 2.]));\n/// ```\npub fn std_axis(&self, axis: Axis, ddof: A) -> Array<A, D::Smaller>\n    where\n        A: Float + FromPrimitive,\n        D: RemoveAxis,{\n        self.var_axis(axis, ddof).mapv_into(|x| x.sqrt())\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::sum":["/// Return the sum of all elements in the array.\n///\n/// ```\n/// use ndarray::arr2;\n///\n/// let a = arr2(&[[1., 2.],\n///                [3., 4.]]);\n/// assert_eq!(a.sum(), 10.);\n/// ```\npub fn sum(&self) -> A\n    where\n        A: Clone + Add<Output = A> + num_traits::Zero,{\n        if let Some(slc) = self.as_slice_memory_order() {\n            return numeric_util::unrolled_fold(slc, A::zero, A::add);\n        }\n        let mut sum = A::zero();\n        for row in self.inner_rows() {\n            if let Some(slc) = row.as_slice() {\n                sum = sum + numeric_util::unrolled_fold(slc, A::zero, A::add);\n            } else {\n                sum = sum + row.iter().fold(A::zero(), |acc, elt| acc + elt.clone());\n            }\n        }\n        sum\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::sum_axis":["/// Return sum along `axis`.\n///\n/// ```\n/// use ndarray::{aview0, aview1, arr2, Axis};\n///\n/// let a = arr2(&[[1., 2., 3.],\n///                [4., 5., 6.]]);\n/// assert!(\n///     a.sum_axis(Axis(0)) == aview1(&[5., 7., 9.]) &&\n///     a.sum_axis(Axis(1)) == aview1(&[6., 15.]) &&\n///\n///     a.sum_axis(Axis(0)).sum_axis(Axis(0)) == aview0(&21.)\n/// );\n/// ```\n///\n/// **Panics** if `axis` is out of bounds.\npub fn sum_axis(&self, axis: Axis) -> Array<A, D::Smaller>\n    where\n        A: Clone + Zero + Add<Output = A>,\n        D: RemoveAxis,{\n        let n = self.len_of(axis);\n        let mut res = Array::zeros(self.raw_dim().remove_axis(axis));\n        let stride = self.strides()[axis.index()];\n        if self.ndim() == 2 && stride == 1 {\n            // contiguous along the axis we are summing\n            let ax = axis.index();\n            for (i, elt) in enumerate(&mut res) {\n                *elt = self.index_axis(Axis(1 - ax), i).sum();\n            }\n        } else {\n            for i in 0..n {\n                let view = self.index_axis(axis, i);\n                res = res + &view;\n            }\n        }\n        res\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric::impl_numeric::<impl ArrayBase<S, D>>::var_axis":["/// Return variance along `axis`.\n///\n/// The variance is computed using the [Welford one-pass\n/// algorithm](https://www.jstor.org/stable/1266577).\n///\n/// The parameter `ddof` specifies the \"delta degrees of freedom\". For\n/// example, to calculate the population variance, use `ddof = 0`, or to\n/// calculate the sample variance, use `ddof = 1`.\n///\n/// The variance is defined as:\n///\n/// ```text\n///               1       n\n/// variance =     (x - x)\n///            n - ddof  i=1\n/// ```\n///\n/// where\n///\n/// ```text\n///     1   n\n/// x =     x\n///     n  i=1\n/// ```\n///\n/// and `n` is the length of the axis.\n///\n/// **Panics** if `ddof` is less than zero or greater than `n`, if `axis`\n/// is out of bounds, or if `A::from_usize()` fails for any any of the\n/// numbers in the range `0..=n`.\n///\n/// # Example\n///\n/// ```\n/// use ndarray::{aview1, arr2, Axis};\n///\n/// let a = arr2(&[[1., 2.],\n///                [3., 4.],\n///                [5., 6.]]);\n/// let var = a.var_axis(Axis(0), 1.);\n/// assert_eq!(var, aview1(&[4., 4.]));\n/// ```\npub fn var_axis(&self, axis: Axis, ddof: A) -> Array<A, D::Smaller>\n    where\n        A: Float + FromPrimitive,\n        D: RemoveAxis,{\n        let zero = A::from_usize(0).expect(\"Converting 0 to `A` must not fail.\");\n        let n = A::from_usize(self.len_of(axis)).expect(\"Converting length to `A` must not fail.\");\n        assert!(\n            !(ddof < zero || ddof > n),\n            \"`ddof` must not be less than zero or greater than the length of \\\n             the axis\",\n        );\n        let dof = n - ddof;\n        let mut mean = Array::<A, _>::zeros(self.dim.remove_axis(axis));\n        let mut sum_sq = Array::<A, _>::zeros(self.dim.remove_axis(axis));\n        for (i, subview) in self.axis_iter(axis).enumerate() {\n            let count = A::from_usize(i + 1).expect(\"Converting index to `A` must not fail.\");\n            azip!((mean in &mut mean, sum_sq in &mut sum_sq, &x in &subview) {\n                let delta = x - *mean;\n                *mean = *mean + delta / count;\n                *sum_sq = (x - *mean).mul_add(delta, *sum_sq);\n            });\n        }\n        sum_sq.mapv_into(|s| s / dof)\n    }","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))"],"numeric_util::unrolled_dot":["/// Compute the dot product.\n///\n/// `xs` and `ys` must be the same length\npub fn unrolled_dot<A>(xs: &[A], ys: &[A]) -> A\nwhere\n    A: LinalgScalar,{\n    debug_assert_eq!(xs.len(), ys.len());\n    // eightfold unrolled so that floating point can be vectorized\n    // (even with strict floating point accuracy semantics)\n    let len = cmp::min(xs.len(), ys.len());\n    let mut xs = &xs[..len];\n    let mut ys = &ys[..len];\n    let mut sum = A::zero();\n    let (mut p0, mut p1, mut p2, mut p3, mut p4, mut p5, mut p6, mut p7) = (\n        A::zero(),\n        A::zero(),\n        A::zero(),\n        A::zero(),\n        A::zero(),\n        A::zero(),\n        A::zero(),\n        A::zero(),\n    );\n    while xs.len() >= 8 {\n        p0 = p0 + xs[0] * ys[0];\n        p1 = p1 + xs[1] * ys[1];\n        p2 = p2 + xs[2] * ys[2];\n        p3 = p3 + xs[3] * ys[3];\n        p4 = p4 + xs[4] * ys[4];\n        p5 = p5 + xs[5] * ys[5];\n        p6 = p6 + xs[6] * ys[6];\n        p7 = p7 + xs[7] * ys[7];\n\n        xs = &xs[8..];\n        ys = &ys[8..];\n    }\n    sum = sum + (p0 + p4);\n    sum = sum + (p1 + p5);\n    sum = sum + (p2 + p6);\n    sum = sum + (p3 + p7);\n\n    for (i, (&x, &y)) in xs.iter().zip(ys).enumerate() {\n        if i >= 7 {\n            break;\n        }\n        sum = sum + x * y;\n    }\n    sum\n}","Real(LocalPath(\"src/numeric_util.rs\"))"],"numeric_util::unrolled_eq":["/// Compute pairwise equality\n///\n/// `xs` and `ys` must be the same length\npub fn unrolled_eq<A, B>(xs: &[A], ys: &[B]) -> bool\nwhere\n    A: PartialEq<B>,{\n    debug_assert_eq!(xs.len(), ys.len());\n    // eightfold unrolled for performance (this is not done by llvm automatically)\n    let len = cmp::min(xs.len(), ys.len());\n    let mut xs = &xs[..len];\n    let mut ys = &ys[..len];\n\n    while xs.len() >= 8 {\n        if (xs[0] != ys[0])\n            | (xs[1] != ys[1])\n            | (xs[2] != ys[2])\n            | (xs[3] != ys[3])\n            | (xs[4] != ys[4])\n            | (xs[5] != ys[5])\n            | (xs[6] != ys[6])\n            | (xs[7] != ys[7])\n        {\n            return false;\n        }\n        xs = &xs[8..];\n        ys = &ys[8..];\n    }\n\n    for i in 0..xs.len() {\n        if xs[i] != ys[i] {\n            return false;\n        }\n    }\n\n    true\n}","Real(LocalPath(\"src/numeric_util.rs\"))"],"numeric_util::unrolled_fold":["/// Fold over the manually unrolled `xs` with `f`\npub fn unrolled_fold<A, I, F>(mut xs: &[A], init: I, f: F) -> A\nwhere\n    A: Clone,\n    I: Fn() -> A,\n    F: Fn(A, A) -> A,{\n    // eightfold unrolled so that floating point can be vectorized\n    // (even with strict floating point accuracy semantics)\n    let mut acc = init();\n    let (mut p0, mut p1, mut p2, mut p3, mut p4, mut p5, mut p6, mut p7) = (\n        init(),\n        init(),\n        init(),\n        init(),\n        init(),\n        init(),\n        init(),\n        init(),\n    );\n    while xs.len() >= 8 {\n        p0 = f(p0, xs[0].clone());\n        p1 = f(p1, xs[1].clone());\n        p2 = f(p2, xs[2].clone());\n        p3 = f(p3, xs[3].clone());\n        p4 = f(p4, xs[4].clone());\n        p5 = f(p5, xs[5].clone());\n        p6 = f(p6, xs[6].clone());\n        p7 = f(p7, xs[7].clone());\n\n        xs = &xs[8..];\n    }\n    acc = f(acc.clone(), f(p0, p4));\n    acc = f(acc.clone(), f(p1, p5));\n    acc = f(acc.clone(), f(p2, p6));\n    acc = f(acc.clone(), f(p3, p7));\n\n    // make it clear to the optimizer that this loop is short\n    // and can not be autovectorized.\n    for (i, x) in xs.iter().enumerate() {\n        if i >= 7 {\n            break;\n        }\n        acc = f(acc.clone(), x.clone())\n    }\n    acc\n}","Real(LocalPath(\"src/numeric_util.rs\"))"],"private::PrivateMarker":["/// If this type is pub but not publicly reachable, third parties\n/// can't name it and can't implement traits using it.\npub struct PrivateMarker;","Real(LocalPath(\"src/private.rs\"))"],"shape_builder::<impl Shape<D>>::size":["/// Return the size of the shape in number of elements\npub fn size(&self) -> usize{\n        self.dim.size()\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"shape_builder::<impl std::convert::From<D> for Shape<D>>::from":["/// Create a `Shape` from `dimension`, using the default memory layout.\nfn from(dimension: D) -> Shape<D>{\n        dimension.into_shape()\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"shape_builder::<impl std::convert::From<T> for StrideShape<D>>::from":["fn from(value: T) -> Self{\n        let shape = value.into_shape();\n        let d = shape.dim;\n        let st = if shape.is_c {\n            d.default_strides()\n        } else {\n            d.fortran_strides()\n        };\n        StrideShape {\n            strides: st,\n            dim: d,\n            custom: false,\n        }\n    }","Real(LocalPath(\"src/shape_builder.rs\"))"],"shape_builder::ShapeBuilder":["/// A trait for `Shape` and `D where D: Dimension` that allows\n/// customizing the memory layout (strides) of an array shape.\n///\n/// This trait is used together with array constructor methods like\n/// `Array::from_shape_vec`.\npub trait ShapeBuilder {\n    type Dim: Dimension;\n    type Strides;\n\n    fn into_shape(self) -> Shape<Self::Dim>;\n    fn f(self) -> Shape<Self::Dim>;\n    fn set_f(self, is_f: bool) -> Shape<Self::Dim>;\n    fn strides(self, strides: Self::Strides) -> StrideShape<Self::Dim>;\n}","Real(LocalPath(\"src/shape_builder.rs\"))"],"slice::MultiSlice":["/// Slicing information describing multiple mutable, disjoint slices.\n///\n/// It's unfortunate that we need `'a` and `A` to be parameters of the trait,\n/// but they're necessary until Rust supports generic associated types.\npub trait MultiSlice<'a, A, D>\nwhere\n    A: 'a,\n    D: Dimension,\n{\n    /// The type of the slices created by `.multi_slice_move()`.\n    type Output;\n\n    /// Split the view into multiple disjoint slices.\n    ///\n    /// **Panics** if performing any individual slice panics or if the slices\n    /// are not disjoint (i.e. if they intersect).\n    fn multi_slice_move(&self, view: ArrayViewMut<'a, A, D>) -> Self::Output;\n}","Real(LocalPath(\"src/slice.rs\"))"],"slice::Slice":["/// A slice (range with step size).\n///\n/// `end` is an exclusive index. Negative `begin` or `end` indexes are counted\n/// from the back of the axis. If `end` is `None`, the slice extends to the end\n/// of the axis.\n///\n/// See also the [`s![]`](macro.s.html) macro.\n///\n/// ## Examples\n///\n/// `Slice::new(0, None, 1)` is the full range of an axis. It can also be\n/// created with `Slice::from(..)`. The Python equivalent is `[:]`.\n///\n/// `Slice::new(a, b, 2)` is every second element from `a` until `b`. It can\n/// also be created with `Slice::from(a..b).step_by(2)`. The Python equivalent\n/// is `[a:b:2]`.\n///\n/// `Slice::new(a, None, -1)` is every element, from `a` until the end, in\n/// reverse order. It can also be created with `Slice::from(a..).step_by(-1)`.\n/// The Python equivalent is `[a::-1]`.\npub struct Slice {\n    pub start: isize,\n    pub end: Option<isize>,\n    pub step: isize,\n}","Real(LocalPath(\"src/slice.rs\"))"],"slice::Slice::new":["/// Create a new `Slice` with the given extents.\n///\n/// See also the `From` impls, converting from ranges; for example\n/// `Slice::from(i..)` or `Slice::from(j..k)`.\n///\n/// `step` must be nonzero.\n/// (This method checks with a debug assertion that `step` is not zero.)\npub fn new(start: isize, end: Option<isize>, step: isize) -> Slice{\n        debug_assert_ne!(step, 0, \"Slice::new: step must be nonzero\");\n        Slice { start, end, step }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::Slice::step_by":["/// Create a new `Slice` with the given step size (multiplied with the\n/// previous step size).\n///\n/// `step` must be nonzero.\n/// (This method checks with a debug assertion that `step` is not zero.)\n#[inline]\npub fn step_by(self, step: isize) -> Self{\n        debug_assert_ne!(step, 0, \"Slice::step_by: step must be nonzero\");\n        Slice {\n            step: self.step * step,\n            ..self\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceInfo":["/// Represents all of the necessary information to perform a slice.\n///\n/// The type `T` is typically `[SliceOrIndex; n]`, `[SliceOrIndex]`, or\n/// `Vec<SliceOrIndex>`. The type `D` is the output dimension after calling\n/// [`.slice()`].\n///\n/// [`.slice()`]: struct.ArrayBase.html#method.slice\n#[repr(C)]\npub struct SliceInfo<T: ?Sized, D: Dimension> {\n    out_dim: PhantomData<D>,\n    indices: T,\n}","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceInfo::<T, D>::new":["/// Returns a new `SliceInfo` instance.\n///\n/// Errors if `D` is not consistent with `indices`.\npub fn new(indices: T) -> Result<SliceInfo<T, D>, ShapeError>{\n        if let Some(ndim) = D::NDIM {\n            if ndim != indices.as_ref().iter().filter(|s| s.is_slice()).count() {\n                return Err(ShapeError::from_kind(ErrorKind::IncompatibleShape));\n            }\n        }\n        Ok(SliceInfo {\n            out_dim: PhantomData,\n            indices,\n        })\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceInfo::<T, D>::new_unchecked":["/// Returns a new `SliceInfo` instance.\n///\n/// If you call this method, you are guaranteeing that `out_dim` is\n/// consistent with `indices`.\n#[doc(hidden)]\npub unsafe fn new_unchecked(indices: T, out_dim: PhantomData<D>) -> SliceInfo<T, D>{\n        SliceInfo { out_dim, indices }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceInfo::<T, D>::out_ndim":["/// Returns the number of dimensions after calling\n/// [`.slice()`](struct.ArrayBase.html#method.slice) (including taking\n/// subviews).\n///\n/// If `D` is a fixed-size dimension type, then this is equivalent to\n/// `D::NDIM.unwrap()`. Otherwise, the value is calculated by iterating\n/// over the ranges/indices.\npub fn out_ndim(&self) -> usize{\n        D::NDIM.unwrap_or_else(|| {\n            self.indices\n                .as_ref()\n                .iter()\n                .filter(|s| s.is_slice())\n                .count()\n        })\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceNextDim":["#[doc(hidden)]\npub trait SliceNextDim<D1, D2> {\n    fn next_dim(&self, _: PhantomData<D1>) -> PhantomData<D2>;\n}","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceOrIndex":["/// A slice (range with step) or an index.\n///\n/// See also the [`s![]`](macro.s!.html) macro for a convenient way to create a\n/// `&SliceInfo<[SliceOrIndex; n], D>`.\n///\n/// ## Examples\n///\n/// `SliceOrIndex::Index(a)` is the index `a`. It can also be created with\n/// `SliceOrIndex::from(a)`. The Python equivalent is `[a]`. The macro\n/// equivalent is `s![a]`.\n///\n/// `SliceOrIndex::Slice { start: 0, end: None, step: 1 }` is the full range of\n/// an axis. It can also be created with `SliceOrIndex::from(..)`. The Python\n/// equivalent is `[:]`. The macro equivalent is `s![..]`.\n///\n/// `SliceOrIndex::Slice { start: a, end: Some(b), step: 2 }` is every second\n/// element from `a` until `b`. It can also be created with\n/// `SliceOrIndex::from(a..b).step_by(2)`. The Python equivalent is `[a:b:2]`.\n/// The macro equivalent is `s![a..b;2]`.\n///\n/// `SliceOrIndex::Slice { start: a, end: None, step: -1 }` is every element,\n/// from `a` until the end, in reverse order. It can also be created with\n/// `SliceOrIndex::from(a..).step_by(-1)`. The Python equivalent is `[a::-1]`.\n/// The macro equivalent is `s![a..;-1]`.\npub enum SliceOrIndex {\n    /// A range with step size. `end` is an exclusive index. Negative `begin`\n    /// or `end` indexes are counted from the back of the axis. If `end` is\n    /// `None`, the slice extends to the end of the axis.\n    Slice {\n        start: isize,\n        end: Option<isize>,\n        step: isize,\n    },\n    /// A single index.\n    Index(isize),\n}","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceOrIndex::is_index":["/// Returns `true` if `self` is an `Index` value.\npub fn is_index(&self) -> bool{\n        match self {\n            SliceOrIndex::Index(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceOrIndex::is_slice":["/// Returns `true` if `self` is a `Slice` value.\npub fn is_slice(&self) -> bool{\n        match self {\n            SliceOrIndex::Slice { .. } => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"slice::SliceOrIndex::step_by":["/// Returns a new `SliceOrIndex` with the given step size (multiplied with\n/// the previous step size).\n///\n/// `step` must be nonzero.\n/// (This method checks with a debug assertion that `step` is not zero.)\n#[inline]\npub fn step_by(self, step: isize) -> Self{\n        debug_assert_ne!(step, 0, \"SliceOrIndex::step_by: step must be nonzero\");\n        match self {\n            SliceOrIndex::Slice {\n                start,\n                end,\n                step: orig_step,\n            } => SliceOrIndex::Slice {\n                start,\n                end,\n                step: orig_step * step,\n            },\n            SliceOrIndex::Index(s) => SliceOrIndex::Index(s),\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"stacking::stack":["/// Stack arrays along the given axis.\n///\n/// ***Errors*** if the arrays have mismatching shapes, apart from along `axis`.\n/// (may be made more flexible in the future).<br>\n/// ***Errors*** if `arrays` is empty, if `axis` is out of bounds,\n/// if the result is larger than is possible to represent.\n///\n/// ```\n/// use ndarray::{arr2, Axis, stack};\n///\n/// let a = arr2(&[[2., 2.],\n///                [3., 3.]]);\n/// assert!(\n///     stack(Axis(0), &[a.view(), a.view()])\n///     == Ok(arr2(&[[2., 2.],\n///                  [3., 3.],\n///                  [2., 2.],\n///                  [3., 3.]]))\n/// );\n/// ```\npub fn stack<'a, A, D>(\n    axis: Axis,\n    arrays: &[ArrayView<'a, A, D>],\n) -> Result<Array<A, D>, ShapeError>\nwhere\n    A: Copy,\n    D: RemoveAxis,{\n    if arrays.is_empty() {\n        return Err(from_kind(ErrorKind::Unsupported));\n    }\n    let mut res_dim = arrays[0].raw_dim();\n    if axis.index() >= res_dim.ndim() {\n        return Err(from_kind(ErrorKind::OutOfBounds));\n    }\n    let common_dim = res_dim.remove_axis(axis);\n    if arrays\n        .iter()\n        .any(|a| a.raw_dim().remove_axis(axis) != common_dim)\n    {\n        return Err(from_kind(ErrorKind::IncompatibleShape));\n    }\n\n    let stacked_dim = arrays.iter().fold(0, |acc, a| acc + a.len_of(axis));\n    res_dim.set_axis(axis, stacked_dim);\n\n    // we can safely use uninitialized values here because they are Copy\n    // and we will only ever write to them\n    let size = res_dim.size();\n    let mut v = Vec::with_capacity(size);\n    unsafe {\n        v.set_len(size);\n    }\n    let mut res = Array::from_shape_vec(res_dim, v)?;\n\n    {\n        let mut assign_view = res.view_mut();\n        for array in arrays {\n            let len = array.len_of(axis);\n            let (mut front, rest) = assign_view.split_at(axis, len);\n            front.assign(array);\n            assign_view = rest;\n        }\n    }\n    Ok(res)\n}","Real(LocalPath(\"src/stacking.rs\"))"],"zip::<impl ArrayBase<S, D>>::layout_impl":["pub(crate) fn layout_impl(&self) -> Layout{\n        Layout::new(if self.is_standard_layout() {\n            if self.ndim() <= 1 {\n                FORDER | CORDER\n            } else {\n                CORDER\n            }\n        } else if self.ndim() > 1 && self.raw_view().reversed_axes().is_standard_layout() {\n            FORDER\n        } else {\n            0\n        })\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Broadcast":["/// Broadcast an array so that it acts like a larger size and/or shape array.\n///\n/// See [broadcasting][1] for more information.\n///\n/// [1]: struct.ArrayBase.html#broadcasting\ntrait Broadcast<E>\nwhere\n    E: IntoDimension,\n{\n    type Output: NdProducer<Dim = E::Dim>;\n    /// Broadcast the array to the new dimensions `shape`.\n    ///\n    /// ***Panics*** if broadcasting isnt possible.\n    fn broadcast_unwrap(self, shape: E) -> Self::Output;\n    private_decl! {}\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::FoldWhile":["/// Value controlling the execution of `.fold_while` on `Zip`.\npub enum FoldWhile<T> {\n    /// Continue folding with this value\n    Continue(T),\n    /// Fold is complete and will return this value\n    Done(T),\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::FoldWhile::<T>::into_inner":["/// Return the inner value\npub fn into_inner(self) -> T{\n        match self {\n            FoldWhile::Continue(x) | FoldWhile::Done(x) => x,\n        }\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::FoldWhile::<T>::is_done":["/// Return true if it is `Done`, false if `Continue`\npub fn is_done(&self) -> bool{\n        match *self {\n            FoldWhile::Continue(_) => false,\n            FoldWhile::Done(_) => true,\n        }\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::IntoNdProducer":["/// Argument conversion into a producer.\n///\n/// Slices and vectors can be used (equivalent to 1-dimensional array views).\n///\n/// This trait is like `IntoIterator` for `NdProducers` instead of iterators.\npub trait IntoNdProducer {\n    /// The element produced per iteration.\n    type Item;\n    /// Dimension type of the producer\n    type Dim: Dimension;\n    type Output: NdProducer<Dim = Self::Dim, Item = Self::Item>;\n    /// Convert the value into an `NdProducer`.\n    fn into_producer(self) -> Self::Output;\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::NdProducer":["/// A producer of an n-dimensional set of elements;\n/// for example an array view, mutable array view or an iterator\n/// that yields chunks.\n///\n/// Producers are used as a arguments to [`Zip`](struct.Zip.html) and\n/// [`azip!()`](macro.azip.html).\n///\n/// # Comparison to `IntoIterator`\n///\n/// Most `NdProducers` are *iterable* (implement `IntoIterator`) but not directly\n/// iterators. This separation is needed because the producer represents\n/// a multidimensional set of items, it can be split along a particular axis for\n/// parallelization, and it has no fixed correspondance to a sequence.\n///\n/// The natural exception is one dimensional producers, like `AxisIter`, which\n/// implement `Iterator` directly\n/// (`AxisIter` traverses a one dimensional sequence, along an axis, while\n/// *producing* multidimensional items).\n///\n/// See also [`IntoNdProducer`](trait.IntoNdProducer.html)\npub trait NdProducer {\n    /// The element produced per iteration.\n    type Item;\n    // Internal use / Pointee type\n    /// Dimension type\n    type Dim: Dimension;\n\n    // The pointer Ptr is used by an array view to simply point to the\n    // current element. It doesn't have to be a pointer (see Indices).\n    // Its main function is that it can be incremented with a particular\n    // stride (= along a particular axis)\n    #[doc(hidden)]\n    /// Pointer or stand-in for pointer\n    type Ptr: Offset<Stride = Self::Stride>;\n    #[doc(hidden)]\n    /// Pointer stride\n    type Stride: Copy;\n\n    #[doc(hidden)]\n    fn layout(&self) -> Layout;\n    #[doc(hidden)]\n    fn raw_dim(&self) -> Self::Dim;\n    #[doc(hidden)]\n    fn equal_dim(&self, dim: &Self::Dim) -> bool {\n        self.raw_dim() == *dim\n    }\n    #[doc(hidden)]\n    fn as_ptr(&self) -> Self::Ptr;\n    #[doc(hidden)]\n    unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item;\n    #[doc(hidden)]\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr;\n    #[doc(hidden)]\n    fn stride_of(&self, axis: Axis) -> <Self::Ptr as Offset>::Stride;\n    #[doc(hidden)]\n    fn contiguous_stride(&self) -> Self::Stride;\n    #[doc(hidden)]\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self)\n    where\n        Self: Sized;\n    private_decl! {}\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::NdProducer::equal_dim":["#[doc(hidden)]\nfn equal_dim(&self, dim: &Self::Dim) -> bool{\n        self.raw_dim() == *dim\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Offset":["pub trait Offset: Copy {\n    type Stride: Copy;\n    unsafe fn stride_offset(self, s: Self::Stride, index: usize) -> Self;\n    private_decl! {}\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::OffsetTuple":["trait OffsetTuple {\n    type Args;\n    unsafe fn stride_offset(self, stride: Self::Args, index: usize) -> Self;\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Splittable":["pub trait Splittable: Sized {\n    fn split_at(self, axis: Axis, index: Ix) -> (Self, Self);\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip":["/// Lock step function application across several arrays or other producers.\n///\n/// Zip allows matching several producers to each other elementwise and applying\n/// a function over all tuples of elements (one item from each input at\n/// a time).\n///\n/// In general, the zip uses a tuple of producers\n/// ([`NdProducer`](trait.NdProducer.html) trait) that all have to be of the\n/// same shape. The NdProducer implementation defines what its item type is\n/// (for example if it's a shared reference, mutable reference or an array\n/// view etc).\n///\n/// If all the input arrays are of the same memory layout the zip performs much\n/// better and the compiler can usually vectorize the loop (if applicable).\n///\n/// The order elements are visited is not specified. The producers dont have to\n/// have the same item type.\n///\n/// The `Zip` has two methods for function application: `apply` and\n/// `fold_while`. The zip object can be split, which allows parallelization.\n/// A read-only zip object (no mutable producers) can be cloned.\n///\n/// See also the [`azip!()` macro][az] which offers a convenient shorthand\n/// to common ways to use `Zip`.\n///\n/// [az]: macro.azip.html\n///\n/// ```\n/// use ndarray::Zip;\n/// use ndarray::Array2;\n///\n/// type M = Array2<f64>;\n///\n/// // Create four 2d arrays of the same size\n/// let mut a = M::zeros((64, 32));\n/// let b = M::from_elem(a.dim(), 1.);\n/// let c = M::from_elem(a.dim(), 2.);\n/// let d = M::from_elem(a.dim(), 3.);\n///\n/// // Example 1: Perform an elementwise arithmetic operation across\n/// // the four arrays a, b, c, d.\n///\n/// Zip::from(&mut a)\n///     .and(&b)\n///     .and(&c)\n///     .and(&d)\n///     .apply(|w, &x, &y, &z| {\n///         *w += x + y * z;\n///     });\n///\n/// // Example 2: Create a new array `totals` with one entry per row of `a`.\n/// //  Use Zip to traverse the rows of `a` and assign to the corresponding\n/// //  entry in `totals` with the sum across each row.\n/// //  This is possible because the producer for `totals` and the row producer\n/// //  for `a` have the same shape and dimensionality.\n/// //  The rows producer yields one array view (`row`) per iteration.\n///\n/// use ndarray::{Array1, Axis};\n///\n/// let mut totals = Array1::zeros(a.nrows());\n///\n/// Zip::from(&mut totals)\n///     .and(a.genrows())\n///     .apply(|totals, row| *totals = row.sum());\n///\n/// // Check the result against the built in `.sum_axis()` along axis 1.\n/// assert_eq!(totals, a.sum_axis(Axis(1)));\n///\n///\n/// // Example 3: Recreate Example 2 using apply_collect to make a new array\n///\n/// let mut totals2 = Zip::from(a.genrows()).apply_collect(|row| row.sum());\n///\n/// // Check the result against the previous example.\n/// assert_eq!(totals, totals2);\n/// ```\npub struct Zip<Parts, D> {\n    parts: Parts,\n    dimension: D,\n    layout: Layout,\n}","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P,), D>::from":["/// Create a new `Zip` from the input array or other producer `p`.\n///\n/// The Zip will take the exact dimension of `p` and all inputs\n/// must have the same dimensions (or be broadcast to them).\npub fn from<IP>(p: IP) -> Self\n    where\n        IP: IntoNdProducer<Dim = D, Output = P, Item = P::Item>,{\n        let array = p.into_producer();\n        let dim = array.raw_dim();\n        Zip {\n            dimension: dim,\n            layout: array.layout(),\n            parts: (array,),\n        }\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::all":["/// Tests if every element of the iterator matches a predicate.\n///\n/// Returns `true` if `predicate` evaluates to `true` for all elements.\n/// Returns `true` if the input arrays are empty.\n///\n/// Example:\n///\n/// ```\n/// use ndarray::{array, Zip};\n/// let a = array![1, 2, 3];\n/// let b = array![1, 4, 9];\n/// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n/// ```\npub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool{\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::and":["/// Include the producer `p` in the Zip.\n///\n/// ***Panics*** if `p`s shape doesnt match the Zips exactly.\npub fn and<P>(self, p: P) -> Zip<($($p,)* P::Output, ), D>\n                where P: IntoNdProducer<Dim=D>,{\n                let array = p.into_producer();\n                self.check(&array);\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::and_broadcast":["/// Include the producer `p` in the Zip, broadcasting if needed.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// ***Panics*** if broadcasting isnt possible.\npub fn and_broadcast<'a, P, D2, Elem>(self, p: P)\n                -> Zip<($($p,)* ArrayView<'a, Elem, D>, ), D>\n                where P: IntoNdProducer<Dim=D2, Output=ArrayView<'a, Elem, D2>, Item=&'a Elem>,\n                      D2: Dimension,{\n                let array = p.into_producer().broadcast_unwrap(self.dimension.clone());\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::apply":["/// Apply a function to all elements of the input arrays,\n/// visiting elements in lock step.\npub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*){\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::apply_assign_into":["/// Apply and assign the results into the producer `into`, which should have the same\n/// size as the other inputs.\n///\n/// The producer should have assignable items as dictated by the `AssignElem` trait,\n/// for example `&mut R`.\npub fn apply_assign_into<R, Q>(self, into: Q, mut f: impl FnMut($($p::Item,)* ) -> R)\n                where Q: IntoNdProducer<Dim=D>,\n                      Q::Item: AssignElem<R>{\n                self.and(into)\n                    .apply(move |$($p, )* output_| {\n                        output_.assign_elem(f($($p ),*));\n                    });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::apply_collect":["/// Apply and collect the results into a new array, which has the same size as the\n/// inputs.\n///\n/// If all inputs are c- or f-order respectively, that is preserved in the output.\n///\n/// Restricted to functions that produce copyable results for technical reasons; other\n/// cases are not yet implemented.\npub fn apply_collect<R>(self, f: impl FnMut($($p::Item,)* ) -> R) -> Array<R, D>\n                where R: Copy,{\n                // To support non-Copy elements, implementation of dropping partial array (on\n                // panic) is needed\n                let mut output = self.uninitalized_for_current_layout::<R>();\n                self.apply_assign_into(&mut output, f);\n                unsafe {\n                    output.assume_init()\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::fold":["/// Apply a fold function to all elements of the input arrays,\n/// visiting elements in lock step.\n///\n/// # Example\n///\n/// The expression `tr(AB)` can be more efficiently computed as\n/// the equivalent expression `(AB)` (i.e. the sum of the\n/// elements of the entry-wise product). It would be possible to\n/// evaluate this expression by first computing the entry-wise\n/// product, `AB`, and then computing the elementwise sum of that\n/// product, but it's possible to do this in a single loop (and\n/// avoid an extra heap allocation if `A` and `B` can't be\n/// consumed) by using `Zip`:\n///\n/// ```\n/// use ndarray::{array, Zip};\n///\n/// let a = array![[1, 5], [3, 7]];\n/// let b = array![[2, 4], [8, 6]];\n///\n/// // Without using `Zip`. This involves two loops and an extra\n/// // heap allocation for the result of `&a * &b`.\n/// let sum_prod_nonzip = (&a * &b).sum();\n/// // Using `Zip`. This is a single loop without any heap allocations.\n/// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n///\n/// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n/// ```\npub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::fold_while":["/// Apply a fold function to the input arrays while the return\n/// value is `FoldWhile::Continue`, visiting elements in lock step.\n///\npub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2), D>::split":["/// Split the `Zip` evenly in two.\n///\n/// It will be split in the way that best preserves element locality.\npub fn split(self) -> (Self, Self){\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::all":["/// Tests if every element of the iterator matches a predicate.\n///\n/// Returns `true` if `predicate` evaluates to `true` for all elements.\n/// Returns `true` if the input arrays are empty.\n///\n/// Example:\n///\n/// ```\n/// use ndarray::{array, Zip};\n/// let a = array![1, 2, 3];\n/// let b = array![1, 4, 9];\n/// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n/// ```\npub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool{\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::and":["/// Include the producer `p` in the Zip.\n///\n/// ***Panics*** if `p`s shape doesnt match the Zips exactly.\npub fn and<P>(self, p: P) -> Zip<($($p,)* P::Output, ), D>\n                where P: IntoNdProducer<Dim=D>,{\n                let array = p.into_producer();\n                self.check(&array);\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::and_broadcast":["/// Include the producer `p` in the Zip, broadcasting if needed.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// ***Panics*** if broadcasting isnt possible.\npub fn and_broadcast<'a, P, D2, Elem>(self, p: P)\n                -> Zip<($($p,)* ArrayView<'a, Elem, D>, ), D>\n                where P: IntoNdProducer<Dim=D2, Output=ArrayView<'a, Elem, D2>, Item=&'a Elem>,\n                      D2: Dimension,{\n                let array = p.into_producer().broadcast_unwrap(self.dimension.clone());\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::apply":["/// Apply a function to all elements of the input arrays,\n/// visiting elements in lock step.\npub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*){\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::apply_assign_into":["/// Apply and assign the results into the producer `into`, which should have the same\n/// size as the other inputs.\n///\n/// The producer should have assignable items as dictated by the `AssignElem` trait,\n/// for example `&mut R`.\npub fn apply_assign_into<R, Q>(self, into: Q, mut f: impl FnMut($($p::Item,)* ) -> R)\n                where Q: IntoNdProducer<Dim=D>,\n                      Q::Item: AssignElem<R>{\n                self.and(into)\n                    .apply(move |$($p, )* output_| {\n                        output_.assign_elem(f($($p ),*));\n                    });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::apply_collect":["/// Apply and collect the results into a new array, which has the same size as the\n/// inputs.\n///\n/// If all inputs are c- or f-order respectively, that is preserved in the output.\n///\n/// Restricted to functions that produce copyable results for technical reasons; other\n/// cases are not yet implemented.\npub fn apply_collect<R>(self, f: impl FnMut($($p::Item,)* ) -> R) -> Array<R, D>\n                where R: Copy,{\n                // To support non-Copy elements, implementation of dropping partial array (on\n                // panic) is needed\n                let mut output = self.uninitalized_for_current_layout::<R>();\n                self.apply_assign_into(&mut output, f);\n                unsafe {\n                    output.assume_init()\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::fold":["/// Apply a fold function to all elements of the input arrays,\n/// visiting elements in lock step.\n///\n/// # Example\n///\n/// The expression `tr(AB)` can be more efficiently computed as\n/// the equivalent expression `(AB)` (i.e. the sum of the\n/// elements of the entry-wise product). It would be possible to\n/// evaluate this expression by first computing the entry-wise\n/// product, `AB`, and then computing the elementwise sum of that\n/// product, but it's possible to do this in a single loop (and\n/// avoid an extra heap allocation if `A` and `B` can't be\n/// consumed) by using `Zip`:\n///\n/// ```\n/// use ndarray::{array, Zip};\n///\n/// let a = array![[1, 5], [3, 7]];\n/// let b = array![[2, 4], [8, 6]];\n///\n/// // Without using `Zip`. This involves two loops and an extra\n/// // heap allocation for the result of `&a * &b`.\n/// let sum_prod_nonzip = (&a * &b).sum();\n/// // Using `Zip`. This is a single loop without any heap allocations.\n/// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n///\n/// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n/// ```\npub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::fold_while":["/// Apply a fold function to the input arrays while the return\n/// value is `FoldWhile::Continue`, visiting elements in lock step.\n///\npub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3), D>::split":["/// Split the `Zip` evenly in two.\n///\n/// It will be split in the way that best preserves element locality.\npub fn split(self) -> (Self, Self){\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::all":["/// Tests if every element of the iterator matches a predicate.\n///\n/// Returns `true` if `predicate` evaluates to `true` for all elements.\n/// Returns `true` if the input arrays are empty.\n///\n/// Example:\n///\n/// ```\n/// use ndarray::{array, Zip};\n/// let a = array![1, 2, 3];\n/// let b = array![1, 4, 9];\n/// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n/// ```\npub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool{\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::and":["/// Include the producer `p` in the Zip.\n///\n/// ***Panics*** if `p`s shape doesnt match the Zips exactly.\npub fn and<P>(self, p: P) -> Zip<($($p,)* P::Output, ), D>\n                where P: IntoNdProducer<Dim=D>,{\n                let array = p.into_producer();\n                self.check(&array);\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::and_broadcast":["/// Include the producer `p` in the Zip, broadcasting if needed.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// ***Panics*** if broadcasting isnt possible.\npub fn and_broadcast<'a, P, D2, Elem>(self, p: P)\n                -> Zip<($($p,)* ArrayView<'a, Elem, D>, ), D>\n                where P: IntoNdProducer<Dim=D2, Output=ArrayView<'a, Elem, D2>, Item=&'a Elem>,\n                      D2: Dimension,{\n                let array = p.into_producer().broadcast_unwrap(self.dimension.clone());\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::apply":["/// Apply a function to all elements of the input arrays,\n/// visiting elements in lock step.\npub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*){\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::apply_assign_into":["/// Apply and assign the results into the producer `into`, which should have the same\n/// size as the other inputs.\n///\n/// The producer should have assignable items as dictated by the `AssignElem` trait,\n/// for example `&mut R`.\npub fn apply_assign_into<R, Q>(self, into: Q, mut f: impl FnMut($($p::Item,)* ) -> R)\n                where Q: IntoNdProducer<Dim=D>,\n                      Q::Item: AssignElem<R>{\n                self.and(into)\n                    .apply(move |$($p, )* output_| {\n                        output_.assign_elem(f($($p ),*));\n                    });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::apply_collect":["/// Apply and collect the results into a new array, which has the same size as the\n/// inputs.\n///\n/// If all inputs are c- or f-order respectively, that is preserved in the output.\n///\n/// Restricted to functions that produce copyable results for technical reasons; other\n/// cases are not yet implemented.\npub fn apply_collect<R>(self, f: impl FnMut($($p::Item,)* ) -> R) -> Array<R, D>\n                where R: Copy,{\n                // To support non-Copy elements, implementation of dropping partial array (on\n                // panic) is needed\n                let mut output = self.uninitalized_for_current_layout::<R>();\n                self.apply_assign_into(&mut output, f);\n                unsafe {\n                    output.assume_init()\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::fold":["/// Apply a fold function to all elements of the input arrays,\n/// visiting elements in lock step.\n///\n/// # Example\n///\n/// The expression `tr(AB)` can be more efficiently computed as\n/// the equivalent expression `(AB)` (i.e. the sum of the\n/// elements of the entry-wise product). It would be possible to\n/// evaluate this expression by first computing the entry-wise\n/// product, `AB`, and then computing the elementwise sum of that\n/// product, but it's possible to do this in a single loop (and\n/// avoid an extra heap allocation if `A` and `B` can't be\n/// consumed) by using `Zip`:\n///\n/// ```\n/// use ndarray::{array, Zip};\n///\n/// let a = array![[1, 5], [3, 7]];\n/// let b = array![[2, 4], [8, 6]];\n///\n/// // Without using `Zip`. This involves two loops and an extra\n/// // heap allocation for the result of `&a * &b`.\n/// let sum_prod_nonzip = (&a * &b).sum();\n/// // Using `Zip`. This is a single loop without any heap allocations.\n/// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n///\n/// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n/// ```\npub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::fold_while":["/// Apply a fold function to the input arrays while the return\n/// value is `FoldWhile::Continue`, visiting elements in lock step.\n///\npub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4), D>::split":["/// Split the `Zip` evenly in two.\n///\n/// It will be split in the way that best preserves element locality.\npub fn split(self) -> (Self, Self){\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::all":["/// Tests if every element of the iterator matches a predicate.\n///\n/// Returns `true` if `predicate` evaluates to `true` for all elements.\n/// Returns `true` if the input arrays are empty.\n///\n/// Example:\n///\n/// ```\n/// use ndarray::{array, Zip};\n/// let a = array![1, 2, 3];\n/// let b = array![1, 4, 9];\n/// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n/// ```\npub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool{\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::and":["/// Include the producer `p` in the Zip.\n///\n/// ***Panics*** if `p`s shape doesnt match the Zips exactly.\npub fn and<P>(self, p: P) -> Zip<($($p,)* P::Output, ), D>\n                where P: IntoNdProducer<Dim=D>,{\n                let array = p.into_producer();\n                self.check(&array);\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::and_broadcast":["/// Include the producer `p` in the Zip, broadcasting if needed.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// ***Panics*** if broadcasting isnt possible.\npub fn and_broadcast<'a, P, D2, Elem>(self, p: P)\n                -> Zip<($($p,)* ArrayView<'a, Elem, D>, ), D>\n                where P: IntoNdProducer<Dim=D2, Output=ArrayView<'a, Elem, D2>, Item=&'a Elem>,\n                      D2: Dimension,{\n                let array = p.into_producer().broadcast_unwrap(self.dimension.clone());\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply":["/// Apply a function to all elements of the input arrays,\n/// visiting elements in lock step.\npub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*){\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply_assign_into":["/// Apply and assign the results into the producer `into`, which should have the same\n/// size as the other inputs.\n///\n/// The producer should have assignable items as dictated by the `AssignElem` trait,\n/// for example `&mut R`.\npub fn apply_assign_into<R, Q>(self, into: Q, mut f: impl FnMut($($p::Item,)* ) -> R)\n                where Q: IntoNdProducer<Dim=D>,\n                      Q::Item: AssignElem<R>{\n                self.and(into)\n                    .apply(move |$($p, )* output_| {\n                        output_.assign_elem(f($($p ),*));\n                    });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply_collect":["/// Apply and collect the results into a new array, which has the same size as the\n/// inputs.\n///\n/// If all inputs are c- or f-order respectively, that is preserved in the output.\n///\n/// Restricted to functions that produce copyable results for technical reasons; other\n/// cases are not yet implemented.\npub fn apply_collect<R>(self, f: impl FnMut($($p::Item,)* ) -> R) -> Array<R, D>\n                where R: Copy,{\n                // To support non-Copy elements, implementation of dropping partial array (on\n                // panic) is needed\n                let mut output = self.uninitalized_for_current_layout::<R>();\n                self.apply_assign_into(&mut output, f);\n                unsafe {\n                    output.assume_init()\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::fold":["/// Apply a fold function to all elements of the input arrays,\n/// visiting elements in lock step.\n///\n/// # Example\n///\n/// The expression `tr(AB)` can be more efficiently computed as\n/// the equivalent expression `(AB)` (i.e. the sum of the\n/// elements of the entry-wise product). It would be possible to\n/// evaluate this expression by first computing the entry-wise\n/// product, `AB`, and then computing the elementwise sum of that\n/// product, but it's possible to do this in a single loop (and\n/// avoid an extra heap allocation if `A` and `B` can't be\n/// consumed) by using `Zip`:\n///\n/// ```\n/// use ndarray::{array, Zip};\n///\n/// let a = array![[1, 5], [3, 7]];\n/// let b = array![[2, 4], [8, 6]];\n///\n/// // Without using `Zip`. This involves two loops and an extra\n/// // heap allocation for the result of `&a * &b`.\n/// let sum_prod_nonzip = (&a * &b).sum();\n/// // Using `Zip`. This is a single loop without any heap allocations.\n/// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n///\n/// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n/// ```\npub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::fold_while":["/// Apply a fold function to the input arrays while the return\n/// value is `FoldWhile::Continue`, visiting elements in lock step.\n///\npub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5), D>::split":["/// Split the `Zip` evenly in two.\n///\n/// It will be split in the way that best preserves element locality.\npub fn split(self) -> (Self, Self){\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::all":["/// Tests if every element of the iterator matches a predicate.\n///\n/// Returns `true` if `predicate` evaluates to `true` for all elements.\n/// Returns `true` if the input arrays are empty.\n///\n/// Example:\n///\n/// ```\n/// use ndarray::{array, Zip};\n/// let a = array![1, 2, 3];\n/// let b = array![1, 4, 9];\n/// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n/// ```\npub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool{\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::apply":["/// Apply a function to all elements of the input arrays,\n/// visiting elements in lock step.\npub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*){\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::fold":["/// Apply a fold function to all elements of the input arrays,\n/// visiting elements in lock step.\n///\n/// # Example\n///\n/// The expression `tr(AB)` can be more efficiently computed as\n/// the equivalent expression `(AB)` (i.e. the sum of the\n/// elements of the entry-wise product). It would be possible to\n/// evaluate this expression by first computing the entry-wise\n/// product, `AB`, and then computing the elementwise sum of that\n/// product, but it's possible to do this in a single loop (and\n/// avoid an extra heap allocation if `A` and `B` can't be\n/// consumed) by using `Zip`:\n///\n/// ```\n/// use ndarray::{array, Zip};\n///\n/// let a = array![[1, 5], [3, 7]];\n/// let b = array![[2, 4], [8, 6]];\n///\n/// // Without using `Zip`. This involves two loops and an extra\n/// // heap allocation for the result of `&a * &b`.\n/// let sum_prod_nonzip = (&a * &b).sum();\n/// // Using `Zip`. This is a single loop without any heap allocations.\n/// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n///\n/// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n/// ```\npub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::fold_while":["/// Apply a fold function to the input arrays while the return\n/// value is `FoldWhile::Continue`, visiting elements in lock step.\n///\npub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::split":["/// Split the `Zip` evenly in two.\n///\n/// It will be split in the way that best preserves element locality.\npub fn split(self) -> (Self, Self){\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::all":["/// Tests if every element of the iterator matches a predicate.\n///\n/// Returns `true` if `predicate` evaluates to `true` for all elements.\n/// Returns `true` if the input arrays are empty.\n///\n/// Example:\n///\n/// ```\n/// use ndarray::{array, Zip};\n/// let a = array![1, 2, 3];\n/// let b = array![1, 4, 9];\n/// assert!(Zip::from(&a).and(&b).all(|&a, &b| a * a == b));\n/// ```\npub fn all<F>(mut self, mut predicate: F) -> bool\n                where F: FnMut($($p::Item),*) -> bool{\n                !self.apply_core((), move |_, args| {\n                    let ($($p,)*) = args;\n                    if predicate($($p),*) {\n                        FoldWhile::Continue(())\n                    } else {\n                        FoldWhile::Done(())\n                    }\n                }).is_done()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::and":["/// Include the producer `p` in the Zip.\n///\n/// ***Panics*** if `p`s shape doesnt match the Zips exactly.\npub fn and<P>(self, p: P) -> Zip<($($p,)* P::Output, ), D>\n                where P: IntoNdProducer<Dim=D>,{\n                let array = p.into_producer();\n                self.check(&array);\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::and_broadcast":["/// Include the producer `p` in the Zip, broadcasting if needed.\n///\n/// If their shapes disagree, `rhs` is broadcast to the shape of `self`.\n///\n/// ***Panics*** if broadcasting isnt possible.\npub fn and_broadcast<'a, P, D2, Elem>(self, p: P)\n                -> Zip<($($p,)* ArrayView<'a, Elem, D>, ), D>\n                where P: IntoNdProducer<Dim=D2, Output=ArrayView<'a, Elem, D2>, Item=&'a Elem>,\n                      D2: Dimension,{\n                let array = p.into_producer().broadcast_unwrap(self.dimension.clone());\n                let part_layout = array.layout();\n                let ($($p,)*) = self.parts;\n                Zip {\n                    parts: ($($p,)* array, ),\n                    layout: self.layout.and(part_layout),\n                    dimension: self.dimension,\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::apply":["/// Apply a function to all elements of the input arrays,\n/// visiting elements in lock step.\npub fn apply<F>(mut self, mut function: F)\n                where F: FnMut($($p::Item),*){\n                self.apply_core((), move |(), args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function($($p),*))\n                });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::apply_assign_into":["/// Apply and assign the results into the producer `into`, which should have the same\n/// size as the other inputs.\n///\n/// The producer should have assignable items as dictated by the `AssignElem` trait,\n/// for example `&mut R`.\npub fn apply_assign_into<R, Q>(self, into: Q, mut f: impl FnMut($($p::Item,)* ) -> R)\n                where Q: IntoNdProducer<Dim=D>,\n                      Q::Item: AssignElem<R>{\n                self.and(into)\n                    .apply(move |$($p, )* output_| {\n                        output_.assign_elem(f($($p ),*));\n                    });\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::apply_collect":["/// Apply and collect the results into a new array, which has the same size as the\n/// inputs.\n///\n/// If all inputs are c- or f-order respectively, that is preserved in the output.\n///\n/// Restricted to functions that produce copyable results for technical reasons; other\n/// cases are not yet implemented.\npub fn apply_collect<R>(self, f: impl FnMut($($p::Item,)* ) -> R) -> Array<R, D>\n                where R: Copy,{\n                // To support non-Copy elements, implementation of dropping partial array (on\n                // panic) is needed\n                let mut output = self.uninitalized_for_current_layout::<R>();\n                self.apply_assign_into(&mut output, f);\n                unsafe {\n                    output.assume_init()\n                }\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::fold":["/// Apply a fold function to all elements of the input arrays,\n/// visiting elements in lock step.\n///\n/// # Example\n///\n/// The expression `tr(AB)` can be more efficiently computed as\n/// the equivalent expression `(AB)` (i.e. the sum of the\n/// elements of the entry-wise product). It would be possible to\n/// evaluate this expression by first computing the entry-wise\n/// product, `AB`, and then computing the elementwise sum of that\n/// product, but it's possible to do this in a single loop (and\n/// avoid an extra heap allocation if `A` and `B` can't be\n/// consumed) by using `Zip`:\n///\n/// ```\n/// use ndarray::{array, Zip};\n///\n/// let a = array![[1, 5], [3, 7]];\n/// let b = array![[2, 4], [8, 6]];\n///\n/// // Without using `Zip`. This involves two loops and an extra\n/// // heap allocation for the result of `&a * &b`.\n/// let sum_prod_nonzip = (&a * &b).sum();\n/// // Using `Zip`. This is a single loop without any heap allocations.\n/// let sum_prod_zip = Zip::from(&a).and(&b).fold(0, |acc, a, b| acc + a * b);\n///\n/// assert_eq!(sum_prod_nonzip, sum_prod_zip);\n/// ```\npub fn fold<F, Acc>(mut self, acc: Acc, mut function: F) -> Acc\n            where\n                F: FnMut(Acc, $($p::Item),*) -> Acc,{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    FoldWhile::Continue(function(acc, $($p),*))\n                }).into_inner()\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::fold_while":["/// Apply a fold function to the input arrays while the return\n/// value is `FoldWhile::Continue`, visiting elements in lock step.\n///\npub fn fold_while<F, Acc>(mut self, acc: Acc, mut function: F)\n                -> FoldWhile<Acc>\n                where F: FnMut(Acc, $($p::Item),*) -> FoldWhile<Acc>{\n                self.apply_core(acc, move |acc, args| {\n                    let ($($p,)*) = args;\n                    function(acc, $($p),*)\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(P1,), D>::split":["/// Split the `Zip` evenly in two.\n///\n/// It will be split in the way that best preserves element locality.\npub fn split(self) -> (Self, Self){\n                debug_assert_ne!(self.size(), 0, \"Attempt to split empty zip\");\n                debug_assert_ne!(self.size(), 1, \"Attempt to split zip with 1 elem\");\n                // Always split in a way that preserves layout (if any)\n                let axis = self.max_stride_axis();\n                let index = self.len_of(axis) / 2;\n                let (p1, p2) = self.parts.split_at(axis, index);\n                let (d1, d2) = self.dimension.split_at(axis, index);\n                (Zip {\n                    dimension: d1,\n                    layout: self.layout,\n                    parts: p1,\n                },\n                Zip {\n                    dimension: d2,\n                    layout: self.layout,\n                    parts: p2,\n                })\n            }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<(indexes::Indices<D>, P), D>::indexed":["/// Create a new `Zip` with an index producer and the producer `p`.\n///\n/// The Zip will take the exact dimension of `p` and all inputs\n/// must have the same dimensions (or be broadcast to them).\n///\n/// *Note:* Indexed zip has overhead.\npub fn indexed<IP>(p: IP) -> Self\n    where\n        IP: IntoNdProducer<Dim = D, Output = P, Item = P::Item>,{\n        let array = p.into_producer();\n        let dim = array.raw_dim();\n        Zip::from(indices(dim)).and(array)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<P, D>::apply_core":["fn apply_core<F, Acc>(&mut self, acc: Acc, function: F) -> FoldWhile<Acc>\n    where\n        F: FnMut(Acc, P::Item) -> FoldWhile<Acc>,\n        P: ZippableTuple<Dim = D>,{\n        if self.layout.is(CORDER | FORDER) {\n            self.apply_core_contiguous(acc, function)\n        } else {\n            self.apply_core_strided(acc, function)\n        }\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<P, D>::apply_core_contiguous":["fn apply_core_contiguous<F, Acc>(&mut self, mut acc: Acc, mut function: F) -> FoldWhile<Acc>\n    where\n        F: FnMut(Acc, P::Item) -> FoldWhile<Acc>,\n        P: ZippableTuple<Dim = D>,{\n        debug_assert!(self.layout.is(CORDER | FORDER));\n        let size = self.dimension.size();\n        let ptrs = self.parts.as_ptr();\n        let inner_strides = self.parts.contiguous_stride();\n        for i in 0..size {\n            unsafe {\n                let ptr_i = ptrs.stride_offset(inner_strides, i);\n                acc = fold_while![function(acc, self.parts.as_ref(ptr_i))];\n            }\n        }\n        FoldWhile::Continue(acc)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<P, D>::apply_core_strided":["fn apply_core_strided<F, Acc>(&mut self, mut acc: Acc, mut function: F) -> FoldWhile<Acc>\n    where\n        F: FnMut(Acc, P::Item) -> FoldWhile<Acc>,\n        P: ZippableTuple<Dim = D>,{\n        let n = self.dimension.ndim();\n        if n == 0 {\n            panic!(\"Unreachable: ndim == 0 is contiguous\")\n        }\n        let unroll_axis = n - 1;\n        let inner_len = self.dimension[unroll_axis];\n        self.dimension[unroll_axis] = 1;\n        let mut index_ = self.dimension.first_index();\n        let inner_strides = self.parts.stride_of(unroll_axis);\n        while let Some(index) = index_ {\n            // Let's unroll the loop over the innermost axis\n            unsafe {\n                let ptr = self.parts.uget_ptr(&index);\n                for i in 0..inner_len {\n                    let p = ptr.stride_offset(inner_strides, i);\n                    acc = fold_while!(function(acc, self.parts.as_ref(p)));\n                }\n            }\n\n            index_ = self.dimension.next_for(index);\n        }\n        self.dimension[unroll_axis] = inner_len;\n        FoldWhile::Continue(acc)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<P, D>::uninitalized_for_current_layout":["pub(crate) fn uninitalized_for_current_layout<T>(&self) -> Array<MaybeUninit<T>, D>{\n        let is_f = !self.layout.is(CORDER) && self.layout.is(FORDER);\n        Array::maybe_uninit(self.dimension.clone().set_f(is_f))\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<Parts, D>::check":["fn check<P>(&self, part: &P)\n    where\n        P: NdProducer<Dim = D>,{\n        ndassert!(\n            part.equal_dim(&self.dimension),\n            \"Zip: Producer dimension mismatch, expected: {:?}, got: {:?}\",\n            self.dimension,\n            part.raw_dim()\n        );\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<Parts, D>::len_of":["/// Return the length of `axis`\n///\n/// ***Panics*** if `axis` is out of bounds.\nfn len_of(&self, axis: Axis) -> usize{\n        self.dimension[axis.index()]\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<Parts, D>::max_stride_axis":["/// Return an *approximation* to the max stride axis; if\n/// component arrays disagree, there may be no choice better than the\n/// others.\nfn max_stride_axis(&self) -> Axis{\n        let i = match self.layout.flag() {\n            FORDER => self\n                .dimension\n                .slice()\n                .iter()\n                .rposition(|&len| len > 1)\n                .unwrap_or(self.dimension.ndim() - 1),\n            /* corder or default */\n            _ => self\n                .dimension\n                .slice()\n                .iter()\n                .position(|&len| len > 1)\n                .unwrap_or(0),\n        };\n        Axis(i)\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::Zip::<Parts, D>::size":["/// Return a the number of element tuples in the Zip\npub fn size(&self) -> usize{\n        self.dimension.size()\n    }","Real(LocalPath(\"src/zip/mod.rs\"))"],"zip::ZippableTuple":["trait ZippableTuple: Sized {\n    type Item;\n    type Ptr: OffsetTuple<Args = Self::Stride> + Copy;\n    type Dim: Dimension;\n    type Stride: Copy;\n    fn as_ptr(&self) -> Self::Ptr;\n    unsafe fn as_ref(&self, ptr: Self::Ptr) -> Self::Item;\n    unsafe fn uget_ptr(&self, i: &Self::Dim) -> Self::Ptr;\n    fn stride_of(&self, index: usize) -> Self::Stride;\n    fn contiguous_stride(&self) -> Self::Stride;\n    fn split_at(self, axis: Axis, index: usize) -> (Self, Self);\n}","Real(LocalPath(\"src/zip/mod.rs\"))"]},"struct_constructor":{"!":["array_out_of_bounds","broadcast_panic","dot_shape_error","general_dot_shape_error"],"&'a [A]":["into_slice","to_slice"],"&'a mut [A]":["into_slice","into_slice_"],"&<S as data_traits::RawData>::Elem":["index"],"&<dimension::dim::Dim<[usize; 0]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<[usize; 1]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<[usize; 2]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<[usize; 3]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<[usize; 4]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<[usize; 5]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<[usize; 6]> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as std::ops::Index<usize>>::Output":["index"],"&<dimension::dynindeximpl::IxDynImpl as std::ops::Index<J>>::Output":["index"],"&<slice::SliceInfo<T, D> as std::ops::Deref>::Target":["deref"],"&[<Self as data_traits::RawData>::Elem]":["_data_slice"],"&[<Self as free_functions::FixedInitializer>::Elem]":["as_init_slice"],"&[A]":["_data_slice","as_slice","as_slice_memory_order"],"&[T]":["as_init_slice","deref"],"&[isize]":["strides"],"&[slice::SliceOrIndex]":["as_ref"],"&[usize]":["deref","shape","slice"],"&mut <S as data_traits::RawData>::Elem":["index_mut"],"&mut <dimension::dim::Dim<[usize; 0]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<[usize; 1]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<[usize; 2]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<[usize; 3]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<[usize; 4]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<[usize; 5]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<[usize; 6]> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <dimension::dynindeximpl::IxDynImpl as std::ops::Index<J>>::Output":["index_mut"],"&mut [A]":["as_slice_memory_order_mut","as_slice_mut"],"&mut [T]":["deref_mut"],"&mut [usize]":["deref_mut","slice_mut"],"((A, B), (A, B))":["split_at"],"((A, B, C), (A, B, C))":["split_at"],"((A, B, C, D), (A, B, C, D))":["split_at"],"((A, B, C, D, E), (A, B, C, D, E))":["split_at"],"((A, B, C, D, E, F), (A, B, C, D, E, F))":["split_at"],"((A,), (A,))":["split_at"],"(ArrayBase<RawViewRepr<*const A>, D>, ArrayBase<RawViewRepr<*const A>, D>)":["split_at"],"(ArrayBase<RawViewRepr<*mut A>, D>, ArrayBase<RawViewRepr<*mut A>, D>)":["split_at"],"(ArrayBase<ViewRepr<&'a A>, D>, ArrayBase<ViewRepr<&'a A>, D>)":["split_at"],"(ArrayBase<ViewRepr<&'a mut A>, D>, ArrayBase<ViewRepr<&'a mut A>, D>)":["split_at"],"(CowRepr<'a, A>, std::ptr::NonNull<<CowRepr<'a, A> as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(D, D)":["split_at"],"(OwnedArcRepr<A>, std::ptr::NonNull<<OwnedArcRepr<A> as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(RawViewRepr<*const A>, std::ptr::NonNull<<RawViewRepr<*const A> as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(RawViewRepr<*mut A>, std::ptr::NonNull<<RawViewRepr<*mut A> as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(Self, Self)":["split_at"],"(Self, std::ptr::NonNull<<Self as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(ViewRepr<&'a A>, std::ptr::NonNull<<ViewRepr<&'a A> as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(data_repr::OwnedRepr<A>, std::ptr::NonNull<<data_repr::OwnedRepr<A> as data_traits::RawData>::Elem>)":["clone_with_ptr"],"(indexes::Indices<D>, indexes::Indices<D>)":["split_at"],"(isize, (isize, isize))":["extended_gcd"],"(isize, isize)":["solve_linear_diophantine_eq"],"(iterators::AxisChunksIter<'a, A, D>, iterators::AxisChunksIter<'a, A, D>)":["split_at"],"(iterators::AxisChunksIterMut<'a, A, D>, iterators::AxisChunksIterMut<'a, A, D>)":["split_at"],"(iterators::AxisIter<'a, A, D>, iterators::AxisIter<'a, A, D>)":["split_at"],"(iterators::AxisIterCore<A, D>, iterators::AxisIterCore<A, D>)":["split_at"],"(iterators::AxisIterCore<A, D>, usize, D)":["chunk_iter_parts"],"(iterators::AxisIterMut<'a, A, D>, iterators::AxisIterMut<'a, A, D>)":["split_at"],"(iterators::chunks::ExactChunks<'a, A, D>, iterators::chunks::ExactChunks<'a, A, D>)":["split_at"],"(iterators::chunks::ExactChunksMut<'a, A, D>, iterators::chunks::ExactChunksMut<'a, A, D>)":["split_at"],"(iterators::lanes::Lanes<'a, A, D>, iterators::lanes::Lanes<'a, A, D>)":["split_at"],"(iterators::lanes::LanesMut<'a, A, D>, iterators::lanes::LanesMut<'a, A, D>)":["split_at"],"(iterators::windows::Windows<'a, A, D>, iterators::windows::Windows<'a, A, D>)":["split_at"],"(usize, *mut A)":["next_back_with_index","next_with_index"],"(usize, isize)":["diag_params"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["slice_min_max"],"(usize, usize, isize)":["to_abs_slice"],"(zip::Zip<(P1, P2), D>, zip::Zip<(P1, P2), D>)":["split"],"(zip::Zip<(P1, P2, P3), D>, zip::Zip<(P1, P2, P3), D>)":["split"],"(zip::Zip<(P1, P2, P3, P4), D>, zip::Zip<(P1, P2, P3, P4), D>)":["split"],"(zip::Zip<(P1, P2, P3, P4, P5), D>, zip::Zip<(P1, P2, P3, P4, P5), D>)":["split"],"(zip::Zip<(P1, P2, P3, P4, P5, P6), D>, zip::Zip<(P1, P2, P3, P4, P5, P6), D>)":["split"],"(zip::Zip<(P1,), D>, zip::Zip<(P1,), D>)":["split"],"<&'a ArrayBase<S, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a ArrayBase<S, D> as zip::IntoNdProducer>::Output":["into_producer"],"<&'a [A] as zip::IntoNdProducer>::Output":["into_producer"],"<&'a [usize] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<&'a dimension::dynindeximpl::IxDynImpl as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut ArrayBase<S, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut ArrayBase<S, D> as zip::IntoNdProducer>::Output":["into_producer"],"<&'a mut [A] as zip::IntoNdProducer>::Output":["into_producer"],"<&'a mut std::vec::Vec<A> as zip::IntoNdProducer>::Output":["into_producer"],"<&'a std::vec::Vec<A> as zip::IntoNdProducer>::Output":["into_producer"],"<&T as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>) as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>) as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>) as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>) as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do5>) as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>,) as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<() as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<() as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<(A, B) as zip::ZippableTuple>::Item":["as_ref"],"<(A, B) as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<(A, B) as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<(A, B, C) as zip::ZippableTuple>::Item":["as_ref"],"<(A, B, C) as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<(A, B, C) as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<(A, B, C, D) as zip::ZippableTuple>::Item":["as_ref"],"<(A, B, C, D) as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<(A, B, C, D) as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<(A, B, C, D, E) as zip::ZippableTuple>::Item":["as_ref"],"<(A, B, C, D, E) as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<(A, B, C, D, E) as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::Item":["as_ref"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<(A,) as zip::ZippableTuple>::Item":["as_ref"],"<(A,) as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<(A,) as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<(usize, usize) as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<(usize, usize, usize) as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<(usize, usize, usize, usize) as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<(usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<(usize, usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<(usize,) as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<<Self as zip::NdProducer>::Ptr as zip::Offset>::Stride":["stride_of"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::Dim":["raw_dim"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::Stride":["contiguous_stride"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::Dim":["raw_dim"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::Stride":["contiguous_stride"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<Rhs>>::Output":["dot"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<Rhs>>::Output":["dot"],"<ArrayBase<ViewRepr<&'a A>, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::Output":["broadcast_unwrap"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::Dim":["raw_dim"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::Item":["as_ref"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::Stride":["contiguous_stride"],"<ArrayBase<ViewRepr<&'a mut A>, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::Dim":["raw_dim"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::Item":["as_ref"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::Stride":["contiguous_stride"],"<D as dimension::dimension_trait::Dimension>::Pattern":["dim"],"<M as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move","multi_slice_mut"],"<P as zip::IntoNdProducer>::Output":["into_producer"],"<Self as dimension::conversion::Convert>::To":["convert"],"<Self as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<Self as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<Self as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<Self as dimension::dimension_trait::Dimension>::Smaller":["remove_axis","try_remove_axis"],"<Self as impl_views::indexing::IndexLonger<I>>::Output":["get","index","uget"],"<Self as linalg::impl_linalg::Dot<Rhs>>::Output":["dot"],"<Self as slice::MultiSlice<'a, A, D>>::Output":["multi_slice_move"],"<Self as zip::Broadcast<E>>::Output":["broadcast_unwrap"],"<Self as zip::IntoNdProducer>::Output":["into_producer"],"<Self as zip::NdProducer>::Dim":["raw_dim"],"<Self as zip::NdProducer>::Item":["as_ref"],"<Self as zip::NdProducer>::Ptr":["as_ptr","uget_ptr"],"<Self as zip::NdProducer>::Stride":["contiguous_stride"],"<Self as zip::ZippableTuple>::Item":["as_ref"],"<Self as zip::ZippableTuple>::Ptr":["as_ptr","uget_ptr"],"<Self as zip::ZippableTuple>::Stride":["contiguous_stride","stride_of"],"<T as dimension::conversion::IntoDimension>::Dim":["Dim"],"<[usize; 0] as dimension::conversion::Convert>::To":["convert"],"<[usize; 0] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<[usize; 1] as dimension::conversion::Convert>::To":["convert"],"<[usize; 1] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<[usize; 2] as dimension::conversion::Convert>::To":["convert"],"<[usize; 2] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<[usize; 3] as dimension::conversion::Convert>::To":["convert"],"<[usize; 3] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<[usize; 4] as dimension::conversion::Convert>::To":["convert"],"<[usize; 4] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<[usize; 5] as dimension::conversion::Convert>::To":["convert"],"<[usize; 5] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<[usize; 6] as dimension::conversion::Convert>::To":["convert"],"<[usize; 6] as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::Item":["next","next_back"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::Smaller":["try_remove_axis"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::Smaller":["try_remove_axis"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::Smaller":["try_remove_axis"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::Smaller":["remove_axis","try_remove_axis"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::Smaller":["remove_axis","try_remove_axis"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::Smaller":["remove_axis","try_remove_axis"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::Smaller":["remove_axis","try_remove_axis"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::Larger":["insert_axis"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::Pattern":["into_pattern"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::Smaller":["try_remove_axis"],"<dimension::dynindeximpl::IxDynImpl as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"<indexes::Indices<D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<indexes::Indices<D> as zip::NdProducer>::Dim":["raw_dim"],"<indexes::Indices<D> as zip::NdProducer>::Item":["as_ref"],"<indexes::Indices<D> as zip::NdProducer>::Ptr":["as_ptr","uget_ptr"],"<indexes::Indices<D> as zip::NdProducer>::Stride":["contiguous_stride","stride_of"],"<indexes::IndicesIter<D> as std::iter::Iterator>::Item":["next"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::Item":["next"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::Item":["next","next_back"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::Item":["next","next_back"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::Item":["next","next_back"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::Dim":["raw_dim"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::Ptr":["as_ptr","uget_ptr"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::Item":["next","next_back"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::Item":["next","next_back"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::Dim":["raw_dim"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::Ptr":["as_ptr","uget_ptr"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::Item":["next"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::Item":["next"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::Item":["find","last","nth"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::Item":["find","last","nth"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::Item":["next"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::Item":["next"],"<iterators::chunks::ExactChunks<'a, A, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::Item":["next"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::Item":["next"],"<iterators::chunks::ExactChunksMut<'a, A, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::lanes::Lanes<'a, A, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::lanes::LanesMut<'a, A, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::windows::Windows<'a, A, D> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::Item":["as_ref"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::Item":["next"],"<std::vec::Vec<usize> as dimension::conversion::IntoDimension>::Dim":["into_dimension"],"ArrayBase":["add","apply_collect","arr0","arr1","arr2","arr3","as_array_view","as_array_view_mut","as_standard_layout","aview0","aview1","aview2","aview_mut1","aview_mut2","bitand","bitor","bitxor","broadcast","broadcast_assume","broadcast_unwrap","clone","column","column_mut","default","diag","diag_mut","div","dot","eye","fold_axis","from","from_diag","from_elem","from_iter","from_shape","from_shape_fn","from_shape_impl","from_shape_ptr","from_shape_simple_fn","from_shape_vec","from_shape_vec_impl","from_shape_vec_unchecked","from_vec","from_vec_dim_stride_unchecked","geomspace","get_subview","index_axis","index_axis_mut","linspace","logspace","map","map_axis","map_axis_mut","map_mut","mapv","maybe_uninit","mean_axis","mul","neg","new","new_","not","ones","range","raw_view","raw_view_mut","rcarr1","rcarr2","rcarr3","rem","reshape","row","row_mut","select","shl","shr","slice","slice_axis","slice_axis_mut","slice_mut","stack","std_axis","sub","subview","subview_mut","sum_axis","t","to_owned","to_shared","uninitalized_for_current_layout","uninitialized","var_axis","view","view_mut","zeros"],"OwnedArcRepr":["clone","into_shared","new"],"RawViewRepr":["clone","new"],"Shape":["clone","f","from","into_shape","set_f"],"StrideShape":["clone","from","strides"],"ViewRepr":["clone","new"],"arrayformat::FormatOptions":["clone","default_for_array"],"bool":["all","all_close","any","arith_seq_intersect","dim_stride_overlap","eq","equal","equal_dim","is","is_aligned","is_contiguous","is_done","is_empty","is_index","is_owned","is_slice","is_square","is_standard_layout","is_unique","is_view","is_zero","merge_axes","next_for_f","pointer_is_inbounds","same_type","slices_intersect","strides_equivalent","try_is_unique","unrolled_eq"],"data_repr::OwnedRepr":["clone","from","new"],"dimension::axes::Axes":["axes","axes_of","clone"],"dimension::axes::AxisDescription":["clone"],"dimension::axis::Axis":["axis","clone","max_stride_axis","min_stride_axis"],"dimension::dim::Dim":["Ix0","Ix1","Ix2","Ix3","Ix4","Ix5","Ix6","IxDyn","_fastest_varying_stride_order","clone","default","default_strides","first_index","fortran_strides","from_dimension","into_dimension","into_dyn","new","remove_axis","zero","zeros"],"dimension::dynindeximpl::IxDynImpl":["clone","default","from","insert","remove"],"dimension::dynindeximpl::IxDynRepr":["clone","copy_from","default","from","from_vec","from_vec_auto"],"error::ErrorKind":["clone","kind"],"error::ShapeError":["clone","from_kind","incompatible_shapes"],"geomspace::Geomspace":["geomspace"],"indexes::IndexPtr":["clone"],"indexes::Indices":["clone","indices","indices_of"],"indexes::IndicesIter":["clone"],"indexes::IndicesIterF":["clone","indices_iter_f"],"isize":["contiguous_stride","do_collapse_axis","do_slice","index_checked","index_unchecked","stride","stride_of","stride_offset","stride_offset_checked"],"iterators::AxisChunksIter":["axis_chunks_iter","clone","new"],"iterators::AxisChunksIterMut":["axis_chunks_iter_mut","new"],"iterators::AxisIter":["axis_iter","clone","into_outer_iter","new","outer_iter"],"iterators::AxisIterCore":["clone","new"],"iterators::AxisIterMut":["axis_iter_mut","into_outer_iter","new","outer_iter_mut"],"iterators::Baseiter":["clone","into_base_iter","new"],"iterators::ElementsBase":["clone","into_elements_base","new"],"iterators::ElementsBaseMut":["into_elements_base","new"],"iterators::ElementsRepr":["clone"],"iterators::IndexedIter":["clone","indexed_iter","new"],"iterators::IndexedIterMut":["indexed_iter_mut","new"],"iterators::Iter":["clone","into_iter_","iter","new"],"iterators::IterMut":["into_iter_","iter_mut","new"],"iterators::LanesIter":["clone"],"iterators::chunks::ExactChunks":["clone","exact_chunks","new"],"iterators::chunks::ExactChunksIter":["clone"],"iterators::chunks::ExactChunksMut":["exact_chunks_mut","new"],"iterators::lanes::Lanes":["clone","gencolumns","genrows","inner_rows","lanes","new"],"iterators::lanes::LanesMut":["gencolumns_mut","genrows_mut","inner_rows_mut","lanes_mut","new"],"iterators::windows::Windows":["clone","new","windows"],"iterators::windows::WindowsIter":["clone"],"layout::Layout":["c","clone","f","layout","layout_impl","new","none","one_dimensional"],"linspace::Linspace":["linspace","range"],"logspace::Logspace":["logspace"],"private::PrivateMarker":["__private__"],"slice::Slice":["clone","from","new"],"slice::SliceInfo":["clone","new","new_unchecked"],"slice::SliceOrIndex":["clone","from"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::iter::Enumerate":["enumerate"],"std::iter::Zip":["zip"],"std::ptr::NonNull":["as_nonnull_mut","nonnull_debug_checked_from_ptr","nonnull_from_vec_data"],"std::vec::Vec":["into_raw_vec","into_vec","take_as_vec","to_vec","to_vec_mapped"],"u32":["flag"],"usize":["axis","cols","count","index","last_elem","len","len_of","max_abs_offset_check_overflow","ncols","ndim","nrows","out_ndim","position","post_dec","post_inc","pre_dec","rows","size","size_checked","size_of_shape_checked"],"zip::FoldWhile":["apply_core","apply_core_contiguous","apply_core_strided","clone","fold_while"],"zip::Zip":["clone","from","indexed"]},"struct_to_trait":{"<D as dimension::DimensionExt>::D":["dimension::DimensionExt"],"<D as dimension::conversion::IntoDimension>::D":["dimension::conversion::IntoDimension"],"<D as dimension::ndindex::NdIndex<D>>::D":["dimension::ndindex::NdIndex"],"<D as zip::Splittable>::D":["zip::Splittable"],"<P as zip::IntoNdProducer>::P":["zip::IntoNdProducer"],"<T as arraytraits::AsArray<'a, A, D>>::T":["arraytraits::AsArray"],"<T as data_traits::DataClone>::T":["data_traits::DataClone"],"<T as linalg_traits::LinalgScalar>::T":["linalg_traits::LinalgScalar"],"<T as shape_builder::ShapeBuilder>::T":["shape_builder::ShapeBuilder"],"ArrayBase":["linalg::impl_linalg::Dot","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Binary","std::fmt::Debug","std::fmt::Display","std::fmt::LowerExp","std::fmt::LowerHex","std::fmt::UpperExp","std::hash::Hash","std::iter::FromIterator","std::marker::Copy","std::marker::Send","std::marker::Sync","std::ops::Add","std::ops::AddAssign","std::ops::BitAnd","std::ops::BitAndAssign","std::ops::BitOr","std::ops::BitOrAssign","std::ops::BitXor","std::ops::BitXorAssign","std::ops::Div","std::ops::DivAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Neg","std::ops::Not","std::ops::Rem","std::ops::RemAssign","std::ops::Shl","std::ops::ShlAssign","std::ops::Shr","std::ops::ShrAssign","std::ops::Sub","std::ops::SubAssign"],"ArrayView":["std::convert::From","std::iter::IntoIterator","zip::Broadcast","zip::NdProducer"],"ArrayViewMut":["impl_views::indexing::IndexLonger","std::convert::From","std::iter::IntoIterator","zip::NdProducer"],"CowArray":["std::convert::From"],"CowRepr":["data_traits::Data","data_traits::DataMut","data_traits::RawData","data_traits::RawDataClone","data_traits::RawDataMut"],"Ix":["dimension::conversion::IntoDimension","dimension::ndindex::NdIndex"],"OwnedArcRepr":["data_traits::Data","data_traits::DataMut","data_traits::DataOwned","data_traits::DataShared","data_traits::RawData","data_traits::RawDataClone","data_traits::RawDataMut","data_traits::RawDataSubst","std::clone::Clone","std::fmt::Debug"],"RawArrayView":["zip::NdProducer"],"RawArrayViewMut":["zip::NdProducer"],"RawViewRepr":["data_traits::RawData","data_traits::RawDataClone","data_traits::RawDataMut","data_traits::RawDataSubst","std::clone::Clone","std::marker::Copy"],"Shape":["shape_builder::ShapeBuilder","std::clone::Clone","std::convert::From","std::fmt::Debug","std::marker::Copy"],"StrideShape":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::marker::Copy"],"ViewRepr":["data_traits::Data","data_traits::DataMut","data_traits::DataShared","data_traits::RawData","data_traits::RawDataClone","data_traits::RawDataMut","data_traits::RawDataSubst","std::clone::Clone","std::marker::Copy"],"aliases::Array2":["std::convert::From"],"aliases::Array3":["std::convert::From"],"aliases::IxDyn":["dimension::dimension_trait::Dimension"],"arrayformat::FormatOptions":["std::clone::Clone","std::fmt::Debug"],"data_repr::OwnedRepr":["data_traits::Data","data_traits::DataMut","data_traits::DataOwned","data_traits::RawData","data_traits::RawDataClone","data_traits::RawDataMut","data_traits::RawDataSubst","std::clone::Clone","std::fmt::Debug","std::marker::Send","std::marker::Sync","std::ops::Drop"],"dimension::axes::Axes":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator","std::marker::Copy"],"dimension::axes::AxisDescription":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"dimension::axis::Axis":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"dimension::dim::Dim":["dimension::dimension_trait::Dimension","dimension::ndindex::NdIndex","dimension::remove_axis::RemoveAxis","num_traits::Zero","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Sub","std::ops::SubAssign"],"dimension::dynindeximpl::IxDynImpl":["dimension::conversion::IntoDimension","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::ops::DerefMut","std::ops::Index","std::ops::IndexMut"],"dimension::dynindeximpl::IxDynRepr":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::ops::Deref","std::ops::DerefMut"],"error::ErrorKind":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy"],"error::ShapeError":["std::clone::Clone","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display"],"geomspace::Geomspace":["iterators::TrustedIterator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"indexes::IndexPtr":["std::clone::Clone","std::fmt::Debug","std::marker::Copy","zip::Offset"],"indexes::Indices":["std::clone::Clone","std::fmt::Debug","std::iter::IntoIterator","std::marker::Copy","zip::NdProducer"],"indexes::IndicesIter":["iterators::TrustedIterator","std::clone::Clone","std::iter::ExactSizeIterator","std::iter::Iterator"],"indexes::IndicesIterF":["iterators::TrustedIterator","std::clone::Clone","std::iter::ExactSizeIterator","std::iter::Iterator"],"iterators::AxisChunksIter":["std::clone::Clone","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::AxisChunksIterMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::AxisIter":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync","zip::NdProducer"],"iterators::AxisIterCore":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"iterators::AxisIterMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync","zip::NdProducer"],"iterators::Baseiter":["std::clone::Clone","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"iterators::ElementsBase":["std::clone::Clone","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::ElementsBaseMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::ElementsRepr":["std::clone::Clone"],"iterators::IndexedIter":["std::clone::Clone","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::IndexedIterMut":["std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::Iter":["iterators::TrustedIterator","std::clone::Clone","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::IterMut":["iterators::TrustedIterator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::LanesIter":["std::clone::Clone","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::LanesIterMut":["std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iterators::chunks::ExactChunks":["std::clone::Clone","std::iter::IntoIterator","zip::NdProducer"],"iterators::chunks::ExactChunksIter":["std::clone::Clone","std::iter::Iterator"],"iterators::chunks::ExactChunksIterMut":["std::iter::Iterator"],"iterators::chunks::ExactChunksMut":["std::iter::IntoIterator","zip::NdProducer"],"iterators::lanes::Lanes":["std::clone::Clone","std::iter::IntoIterator","zip::NdProducer"],"iterators::lanes::LanesMut":["std::iter::IntoIterator","zip::NdProducer"],"iterators::windows::Windows":["std::clone::Clone","std::iter::IntoIterator","zip::NdProducer"],"iterators::windows::WindowsIter":["std::clone::Clone","std::iter::Iterator"],"layout::Layout":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"linspace::Linspace":["iterators::TrustedIterator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"logspace::Logspace":["iterators::TrustedIterator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"num_complex::Complex":["impl_ops::ScalarOperand","std::ops::Add","std::ops::Div","std::ops::Mul","std::ops::Sub"],"slice::Slice":["slice::SliceNextDim","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"slice::SliceInfo":["std::clone::Clone","std::convert::AsRef","std::fmt::Debug","std::marker::Copy","std::ops::Deref"],"slice::SliceOrIndex":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::iter::Cloned":["iterators::TrustedIterator"],"std::iter::Map":["iterators::TrustedIterator"],"std::ops::Range":["iterators::TrustedIterator","slice::SliceNextDim"],"std::ops::RangeFrom":["slice::SliceNextDim"],"std::ops::RangeFull":["slice::SliceNextDim"],"std::ops::RangeInclusive":["slice::SliceNextDim"],"std::ops::RangeTo":["slice::SliceNextDim"],"std::ops::RangeToInclusive":["slice::SliceNextDim"],"std::slice::Iter":["iterators::TrustedIterator"],"std::slice::IterMut":["iterators::TrustedIterator"],"std::vec::Vec":["dimension::conversion::IntoDimension"],"zip::FoldWhile":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"zip::Zip":["std::clone::Clone","std::fmt::Debug"]},"targets":{"<&'a ArrayBase<S, D> as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<&'a [A] as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<&'a [usize] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<&'a [usize] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<&'a dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<&'a dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<&'a dimension::dynindeximpl::IxDynImpl as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::iter::IntoIterator"],"<&'a mut ArrayBase<S, D> as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<&'a mut T as argument_traits::AssignElem<T>>::assign_elem":["assign_elem","Real(LocalPath(\"src/argument_traits.rs\"))","argument_traits::AssignElem"],"<&'a mut [A] as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<&'a mut std::mem::MaybeUninit<T> as argument_traits::AssignElem<T>>::assign_elem":["assign_elem","Real(LocalPath(\"src/argument_traits.rs\"))","argument_traits::AssignElem"],"<&'a mut std::vec::Vec<A> as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<&'a std::cell::Cell<T> as argument_traits::AssignElem<T>>::assign_elem":["assign_elem","Real(LocalPath(\"src/argument_traits.rs\"))","argument_traits::AssignElem"],"<&'a std::vec::Vec<A> as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::get":["get","Real(LocalPath(\"src/impl_views/indexing.rs\"))","impl_views::indexing::IndexLonger"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::index":["index","Real(LocalPath(\"src/impl_views/indexing.rs\"))","impl_views::indexing::IndexLonger"],"<&'b ArrayBase<ViewRepr<&'a A>, D> as impl_views::indexing::IndexLonger<I>>::uget":["uget","Real(LocalPath(\"src/impl_views/indexing.rs\"))","impl_views::indexing::IndexLonger"],"<&T as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do1>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do2>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do3>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do4>, &slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do5>) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(&slice::SliceInfo<<D as dimension::dimension_trait::Dimension>::SliceArg, Do0>,) as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<() as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<() as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<() as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<() as slice::MultiSlice<'a, A, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/slice.rs\"))","slice::MultiSlice"],"<(A, B) as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<(A, B) as zip::ZippableTuple>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B) as zip::ZippableTuple>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B) as zip::ZippableTuple>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B) as zip::ZippableTuple>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B) as zip::ZippableTuple>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B) as zip::ZippableTuple>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C) as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<(A, B, C) as zip::ZippableTuple>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C) as zip::ZippableTuple>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C) as zip::ZippableTuple>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C) as zip::ZippableTuple>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C) as zip::ZippableTuple>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C) as zip::ZippableTuple>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D) as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<(A, B, C, D) as zip::ZippableTuple>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D) as zip::ZippableTuple>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D) as zip::ZippableTuple>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D) as zip::ZippableTuple>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D) as zip::ZippableTuple>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D) as zip::ZippableTuple>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E) as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<(A, B, C, D, E) as zip::ZippableTuple>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E) as zip::ZippableTuple>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E) as zip::ZippableTuple>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E) as zip::ZippableTuple>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E) as zip::ZippableTuple>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E) as zip::ZippableTuple>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E, F) as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A, B, C, D, E, F) as zip::ZippableTuple>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A,) as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<(A,) as zip::ZippableTuple>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A,) as zip::ZippableTuple>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A,) as zip::ZippableTuple>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A,) as zip::ZippableTuple>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A,) as zip::ZippableTuple>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(A,) as zip::ZippableTuple>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::ZippableTuple"],"<(usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<(usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<(usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<(usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<(usize, usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize, usize, usize) as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<(usize, usize, usize, usize, usize, usize) as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<(usize,) as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<*const T as zip::Offset>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::Offset"],"<*const T as zip::Offset>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::Offset"],"<*mut T as zip::Offset>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::Offset"],"<*mut T as zip::Offset>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::Offset"],"<*mut T as zip::OffsetTuple>::stride_offset":["stride_offset","Real(LocalPath(\"src/zip/mod.rs\"))","zip::OffsetTuple"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::equal_dim":["equal_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*const A>, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::equal_dim":["equal_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<RawViewRepr<*mut A>, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 1]>>>>::dot":["dot","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))","linalg::impl_linalg::Dot"],"<ArrayBase<S, dimension::dim::Dim<[usize; 1]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 2]>>>>::dot":["dot","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))","linalg::impl_linalg::Dot"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 1]>>>>::dot":["dot","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))","linalg::impl_linalg::Dot"],"<ArrayBase<S, dimension::dim::Dim<[usize; 2]>> as linalg::impl_linalg::Dot<ArrayBase<S2, dimension::dim::Dim<[usize; 2]>>>>::dot":["dot","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))","linalg::impl_linalg::Dot"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::Broadcast"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::Broadcast<E>>::broadcast_unwrap":["broadcast_unwrap","Real(LocalPath(\"src/zip/mod.rs\"))","zip::Broadcast"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::equal_dim":["equal_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a A>, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::get":["get","Real(LocalPath(\"src/impl_views/indexing.rs\"))","impl_views::indexing::IndexLonger"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::index":["index","Real(LocalPath(\"src/impl_views/indexing.rs\"))","impl_views::indexing::IndexLonger"],"<ArrayBase<ViewRepr<&'a mut A>, D> as impl_views::indexing::IndexLonger<I>>::uget":["uget","Real(LocalPath(\"src/impl_views/indexing.rs\"))","impl_views::indexing::IndexLonger"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::equal_dim":["equal_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<ArrayBase<ViewRepr<&'a mut A>, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/zip/mod.rs\"))","zip::NdProducer"],"<CowRepr<'a, A> as data_traits::Data>::into_owned":["into_owned","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::Data"],"<CowRepr<'a, A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<CowRepr<'a, A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<CowRepr<'a, A> as data_traits::RawDataClone>::clone_from_with_ptr":["clone_from_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<CowRepr<'a, A> as data_traits::RawDataClone>::clone_with_ptr":["clone_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<CowRepr<'a, A> as data_traits::RawDataMut>::try_ensure_unique":["try_ensure_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<CowRepr<'a, A> as data_traits::RawDataMut>::try_is_unique":["try_is_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<D as dimension::DimensionExt>::axis":["axis","Real(LocalPath(\"src/dimension/mod.rs\"))","dimension::DimensionExt"],"<D as dimension::DimensionExt>::set_axis":["set_axis","Real(LocalPath(\"src/dimension/mod.rs\"))","dimension::DimensionExt"],"<D as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<D as dimension::ndindex::NdIndex<D>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<D as dimension::ndindex::NdIndex<D>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<D as zip::Splittable>::split_at":["split_at","Real(LocalPath(\"src/zip/mod.rs\"))","zip::Splittable"],"<OwnedArcRepr<A> as data_traits::Data>::into_owned":["into_owned","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::Data"],"<OwnedArcRepr<A> as data_traits::DataOwned>::into_shared":["into_shared","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::DataOwned"],"<OwnedArcRepr<A> as data_traits::DataOwned>::new":["new","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::DataOwned"],"<OwnedArcRepr<A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<OwnedArcRepr<A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<OwnedArcRepr<A> as data_traits::RawDataClone>::clone_with_ptr":["clone_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<OwnedArcRepr<A> as data_traits::RawDataMut>::try_ensure_unique":["try_ensure_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<OwnedArcRepr<A> as data_traits::RawDataMut>::try_is_unique":["try_is_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<OwnedArcRepr<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<P as zip::IntoNdProducer>::into_producer":["into_producer","Real(LocalPath(\"src/zip/mod.rs\"))","zip::IntoNdProducer"],"<RawViewRepr<*const A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<RawViewRepr<*const A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<RawViewRepr<*const A> as data_traits::RawDataClone>::clone_with_ptr":["clone_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<RawViewRepr<*mut A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<RawViewRepr<*mut A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<RawViewRepr<*mut A> as data_traits::RawDataClone>::clone_with_ptr":["clone_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<RawViewRepr<*mut A> as data_traits::RawDataMut>::try_ensure_unique":["try_ensure_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<RawViewRepr<*mut A> as data_traits::RawDataMut>::try_is_unique":["try_is_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<Shape<D> as shape_builder::ShapeBuilder>::f":["f","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<Shape<D> as shape_builder::ShapeBuilder>::into_shape":["into_shape","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<Shape<D> as shape_builder::ShapeBuilder>::set_f":["set_f","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<Shape<D> as shape_builder::ShapeBuilder>::strides":["strides","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<T as shape_builder::ShapeBuilder>::f":["f","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<T as shape_builder::ShapeBuilder>::into_shape":["into_shape","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<T as shape_builder::ShapeBuilder>::set_f":["set_f","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<T as shape_builder::ShapeBuilder>::strides":["strides","Real(LocalPath(\"src/shape_builder.rs\"))","shape_builder::ShapeBuilder"],"<ViewRepr<&'a A> as data_traits::Data>::into_owned":["into_owned","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::Data"],"<ViewRepr<&'a A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<ViewRepr<&'a A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<ViewRepr<&'a A> as data_traits::RawDataClone>::clone_with_ptr":["clone_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<ViewRepr<&'a mut A> as data_traits::Data>::into_owned":["into_owned","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::Data"],"<ViewRepr<&'a mut A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<ViewRepr<&'a mut A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<ViewRepr<&'a mut A> as data_traits::RawDataMut>::try_ensure_unique":["try_ensure_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<ViewRepr<&'a mut A> as data_traits::RawDataMut>::try_is_unique":["try_is_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<[T; 0] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 0] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 10] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 10] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 11] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 11] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 12] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 12] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 13] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 13] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 14] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 14] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 15] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 15] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 16] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 16] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 1] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 1] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 2] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 2] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 3] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 3] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 4] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 4] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 5] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 5] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 6] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 6] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 7] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 7] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 8] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 8] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 9] as free_functions::FixedInitializer>::as_init_slice":["as_init_slice","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[T; 9] as free_functions::FixedInitializer>::len":["len","Real(LocalPath(\"src/free_functions.rs\"))","free_functions::FixedInitializer"],"<[usize; 0] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 0] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 0]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 0] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 1] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 1] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 1] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 2] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 2] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 2]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 2] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 3] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 3] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 3]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 3] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 4] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 4] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 4]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 4] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 5] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 5] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 5]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 5] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 6] as dimension::conversion::Convert>::convert":["convert","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::Convert"],"<[usize; 6] as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 6]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 6]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize; 6] as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<[usize] as dimension::DimensionExt>::axis":["axis","Real(LocalPath(\"src/dimension/mod.rs\"))","dimension::DimensionExt"],"<[usize] as dimension::DimensionExt>::set_axis":["set_axis","Real(LocalPath(\"src/dimension/mod.rs\"))","dimension::DimensionExt"],"<data_repr::OwnedRepr<A> as data_traits::Data>::into_owned":["into_owned","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::Data"],"<data_repr::OwnedRepr<A> as data_traits::DataOwned>::into_shared":["into_shared","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::DataOwned"],"<data_repr::OwnedRepr<A> as data_traits::DataOwned>::new":["new","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::DataOwned"],"<data_repr::OwnedRepr<A> as data_traits::RawData>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","data_traits::RawData"],"<data_repr::OwnedRepr<A> as data_traits::RawData>::_data_slice":["_data_slice","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawData"],"<data_repr::OwnedRepr<A> as data_traits::RawDataClone>::clone_from_with_ptr":["clone_from_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<data_repr::OwnedRepr<A> as data_traits::RawDataClone>::clone_with_ptr":["clone_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataClone"],"<data_repr::OwnedRepr<A> as data_traits::RawDataMut>::try_ensure_unique":["try_ensure_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<data_repr::OwnedRepr<A> as data_traits::RawDataMut>::try_is_unique":["try_is_unique","Real(LocalPath(\"src/data_traits.rs\"))","data_traits::RawDataMut"],"<data_repr::OwnedRepr<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/data_repr.rs\"))","std::clone::Clone"],"<data_repr::OwnedRepr<A> as std::clone::Clone>::clone_from":["clone_from","Real(LocalPath(\"src/data_repr.rs\"))","std::clone::Clone"],"<data_repr::OwnedRepr<A> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/data_repr.rs\"))","std::ops::Drop"],"<dimension::axes::Axes<'a, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<dimension::axes::Axes<'a, D> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/dimension/axes.rs\"))","std::iter::DoubleEndedIterator"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/dimension/axes.rs\"))","std::iter::Iterator"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/dimension/axes.rs\"))","std::iter::Iterator"],"<dimension::axes::Axes<'a, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/dimension/axes.rs\"))","std::iter::Iterator"],"<dimension::axes::AxisDescription as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<dimension::dim::Dim<I> as std::cmp::PartialEq<I>>::eq":["eq","Real(LocalPath(\"src/dimension/dim.rs\"))","std::cmp::PartialEq"],"<dimension::dim::Dim<I> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/dimension/dim.rs\"))","std::fmt::Debug"],"<dimension::dim::Dim<I> as std::ops::Add>::add":["add","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::Add"],"<dimension::dim::Dim<I> as std::ops::AddAssign<&'a dimension::dim::Dim<I>>>::add_assign":["add_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::AddAssign"],"<dimension::dim::Dim<I> as std::ops::AddAssign>::add_assign":["add_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::AddAssign"],"<dimension::dim::Dim<I> as std::ops::Mul<usize>>::mul":["mul","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::Mul"],"<dimension::dim::Dim<I> as std::ops::Mul>::mul":["mul","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::Mul"],"<dimension::dim::Dim<I> as std::ops::MulAssign<&'a dimension::dim::Dim<I>>>::mul_assign":["mul_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::MulAssign"],"<dimension::dim::Dim<I> as std::ops::MulAssign<usize>>::mul_assign":["mul_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::MulAssign"],"<dimension::dim::Dim<I> as std::ops::MulAssign>::mul_assign":["mul_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::MulAssign"],"<dimension::dim::Dim<I> as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::Sub"],"<dimension::dim::Dim<I> as std::ops::SubAssign<&'a dimension::dim::Dim<I>>>::sub_assign":["sub_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::SubAssign"],"<dimension::dim::Dim<I> as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::SubAssign"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["_fastest_varying_stride_order","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::next_for":["next_for","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 0]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 0]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["_fastest_varying_stride_order","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::default_strides":["default_strides","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::equal":["equal","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::first_index":["first_index","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::max_stride_axis":["max_stride_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::min_stride_axis":["min_stride_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::next_for":["next_for","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::size":["size","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::size_checked":["size_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::stride_offset":["stride_offset","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["stride_offset_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 1]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 1]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 1]> as dimension::remove_axis::RemoveAxis>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/remove_axis.rs\"))","dimension::remove_axis::RemoveAxis"],"<dimension::dim::Dim<[usize; 1]> as std::ops::Add<usize>>::add":["add","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::Add"],"<dimension::dim::Dim<[usize; 1]> as std::ops::AddAssign<usize>>::add_assign":["add_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::AddAssign"],"<dimension::dim::Dim<[usize; 1]> as std::ops::Sub<usize>>::sub":["sub","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::Sub"],"<dimension::dim::Dim<[usize; 1]> as std::ops::SubAssign<usize>>::sub_assign":["sub_assign","Real(LocalPath(\"src/dimension/dim.rs\"))","std::ops::SubAssign"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["_fastest_varying_stride_order","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::default_strides":["default_strides","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::equal":["equal","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::first_index":["first_index","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::fortran_strides":["fortran_strides","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::last_elem":["last_elem","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::min_stride_axis":["min_stride_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::next_for":["next_for","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::set_last_elem":["set_last_elem","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::size":["size","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::size_checked":["size_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::stride_offset":["stride_offset","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["stride_offset_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 2]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 2]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 2]> as dimension::remove_axis::RemoveAxis>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/remove_axis.rs\"))","dimension::remove_axis::RemoveAxis"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::_fastest_varying_stride_order":["_fastest_varying_stride_order","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::next_for":["next_for","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::size":["size","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::stride_offset":["stride_offset","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::stride_offset_checked":["stride_offset_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 3]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 3]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 3]> as dimension::remove_axis::RemoveAxis>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/remove_axis.rs\"))","dimension::remove_axis::RemoveAxis"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 4]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 4]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 4]> as dimension::remove_axis::RemoveAxis>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/remove_axis.rs\"))","dimension::remove_axis::RemoveAxis"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 5]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 5]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 5]> as dimension::remove_axis::RemoveAxis>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/remove_axis.rs\"))","dimension::remove_axis::RemoveAxis"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<[usize; 6]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 6]> as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<dimension::dim::Dim<[usize; 6]> as dimension::remove_axis::RemoveAxis>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/remove_axis.rs\"))","dimension::remove_axis::RemoveAxis"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::from_dimension":["from_dimension","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::insert_axis":["insert_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::into_pattern":["into_pattern","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::ndim":["ndim","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::slice":["slice","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::slice_mut":["slice_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl> as dimension::dimension_trait::Dimension>::zeros":["zeros","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","dimension::dimension_trait::Dimension"],"<dimension::dynindeximpl::IxDynImpl as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<dimension::dynindeximpl::IxDynImpl as std::convert::From<&'a [usize]>>::from":["from","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::convert::From"],"<dimension::dynindeximpl::IxDynImpl as std::convert::From<std::vec::Vec<usize>>>::from":["from","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::convert::From"],"<dimension::dynindeximpl::IxDynImpl as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::ops::Deref"],"<dimension::dynindeximpl::IxDynImpl as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::ops::DerefMut"],"<dimension::dynindeximpl::IxDynImpl as std::ops::Index<J>>::index":["index","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::ops::Index"],"<dimension::dynindeximpl::IxDynImpl as std::ops::IndexMut<J>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::ops::IndexMut"],"<dimension::dynindeximpl::IxDynRepr<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::clone::Clone"],"<dimension::dynindeximpl::IxDynRepr<T> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::cmp::PartialEq"],"<dimension::dynindeximpl::IxDynRepr<T> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::hash::Hash"],"<dimension::dynindeximpl::IxDynRepr<T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::ops::Deref"],"<dimension::dynindeximpl::IxDynRepr<T> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::ops::DerefMut"],"<dimension::dynindeximpl::IxDynRepr<usize> as std::default::Default>::default":["default","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","std::default::Default"],"<error::ErrorKind as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/error.rs\"))","std::cmp::PartialEq"],"<error::ShapeError as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/error.rs\"))","std::cmp::PartialEq"],"<error::ShapeError as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"<error::ShapeError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<geomspace::Geomspace<F> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/geomspace.rs\"))","std::iter::DoubleEndedIterator"],"<geomspace::Geomspace<F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/geomspace.rs\"))","std::iter::Iterator"],"<geomspace::Geomspace<F> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/geomspace.rs\"))","std::iter::Iterator"],"<i32 as slice::SliceNextDim<D1, D1>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<indexes::IndexPtr<D> as zip::Offset>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::Offset"],"<indexes::IndexPtr<D> as zip::Offset>::stride_offset":["stride_offset","Real(LocalPath(\"src/indexes.rs\"))","zip::Offset"],"<indexes::Indices<D> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/indexes.rs\"))","std::iter::IntoIterator"],"<indexes::Indices<D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::equal_dim":["equal_dim","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::Indices<D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/indexes.rs\"))","zip::NdProducer"],"<indexes::IndicesIter<D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/indexes.rs\"))","std::iter::Iterator"],"<indexes::IndicesIter<D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/indexes.rs\"))","std::iter::Iterator"],"<indexes::IndicesIter<D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/indexes.rs\"))","std::iter::Iterator"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/indexes.rs\"))","std::iter::Iterator"],"<indexes::IndicesIterF<D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/indexes.rs\"))","std::iter::Iterator"],"<isize as slice::SliceNextDim<D1, D1>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<iterators::AxisChunksIter<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisChunksIter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisChunksIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIter<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::AxisIter<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::AxisIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIter<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterCore<A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::AxisIterCore<A, D> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::AxisIterCore<A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIterCore<A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIterMut<'a, A, D> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::AxisIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::AxisIterMut<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/mod.rs\"))","zip::NdProducer"],"<iterators::Baseiter<A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::Baseiter<A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Baseiter<A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::Baseiter<A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["rfold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::ElementsBase<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::ElementsBase<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::ElementsBase<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::ElementsBase<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::ElementsBase<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["rfold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::ElementsBaseMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::ElementsBaseMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::ElementsBaseMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["rfold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::IndexedIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IndexedIter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IndexedIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::Iter<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::all":["all","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::any":["any","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::collect":["collect","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::find":["find","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::find_map":["find_map","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::position":["position","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::Iter<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["rfold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::IterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::all":["all","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::any":["any","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::collect":["collect","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::find":["find","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::find_map":["find_map","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::position":["position","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::IterMut<'a, A, dimension::dim::Dim<[usize; 1]>> as std::iter::DoubleEndedIterator>::rfold":["rfold","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::DoubleEndedIterator"],"<iterators::LanesIter<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<iterators::LanesIter<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::LanesIter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::LanesIterMut<'a, A, D> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::ExactSizeIterator"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::LanesIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/mod.rs\"))","std::iter::Iterator"],"<iterators::chunks::ExactChunks<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/iterators/macros.rs\"))","std::clone::Clone"],"<iterators::chunks::ExactChunks<'a, A, D> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/iterators/chunks.rs\"))","std::iter::IntoIterator"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunks<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/iterators/macros.rs\"))","std::clone::Clone"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/macros.rs\"))","std::iter::Iterator"],"<iterators::chunks::ExactChunksIter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/macros.rs\"))","std::iter::Iterator"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/macros.rs\"))","std::iter::Iterator"],"<iterators::chunks::ExactChunksIterMut<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/macros.rs\"))","std::iter::Iterator"],"<iterators::chunks::ExactChunksMut<'a, A, D> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/iterators/chunks.rs\"))","std::iter::IntoIterator"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::chunks::ExactChunksMut<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/iterators/macros.rs\"))","std::clone::Clone"],"<iterators::lanes::Lanes<'a, A, D> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/iterators/lanes.rs\"))","std::iter::IntoIterator"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::Lanes<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/iterators/lanes.rs\"))","std::iter::IntoIterator"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::lanes::LanesMut<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/iterators/macros.rs\"))","std::clone::Clone"],"<iterators::windows::Windows<'a, A, D> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/iterators/windows.rs\"))","std::iter::IntoIterator"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::__private__":["__private__","Real(LocalPath(\"src/private.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::as_ptr":["as_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::as_ref":["as_ref","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::contiguous_stride":["contiguous_stride","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::layout":["layout","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::raw_dim":["raw_dim","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::split_at":["split_at","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::stride_of":["stride_of","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::Windows<'a, A, D> as zip::NdProducer>::uget_ptr":["uget_ptr","Real(LocalPath(\"src/iterators/macros.rs\"))","zip::NdProducer"],"<iterators::windows::WindowsIter<'a, A, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/iterators/macros.rs\"))","std::clone::Clone"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iterators/macros.rs\"))","std::iter::Iterator"],"<iterators::windows::WindowsIter<'a, A, D> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iterators/macros.rs\"))","std::iter::Iterator"],"<linspace::Linspace<F> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/linspace.rs\"))","std::iter::DoubleEndedIterator"],"<linspace::Linspace<F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/linspace.rs\"))","std::iter::Iterator"],"<linspace::Linspace<F> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/linspace.rs\"))","std::iter::Iterator"],"<logspace::Logspace<F> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/logspace.rs\"))","std::iter::DoubleEndedIterator"],"<logspace::Logspace<F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/logspace.rs\"))","std::iter::Iterator"],"<logspace::Logspace<F> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/logspace.rs\"))","std::iter::Iterator"],"<slice::Slice as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<slice::Slice as std::convert::From<std::ops::Range<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::Range<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::Range<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeFrom<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeFull>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeTo<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeTo<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeTo<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::Slice as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceInfo<T, D> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/slice.rs\"))","std::clone::Clone"],"<slice::SliceInfo<T, D> as std::convert::AsRef<[slice::SliceOrIndex]>>::as_ref":["as_ref","Real(LocalPath(\"src/slice.rs\"))","std::convert::AsRef"],"<slice::SliceInfo<T, D> as std::convert::AsRef<slice::SliceInfo<[slice::SliceOrIndex], D>>>::as_ref":["as_ref","Real(LocalPath(\"src/slice.rs\"))","std::convert::AsRef"],"<slice::SliceInfo<T, D> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/slice.rs\"))","std::ops::Deref"],"<slice::SliceOrIndex as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macro_utils.rs\"))","std::clone::Clone"],"<slice::SliceOrIndex as std::convert::From<i32>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<isize>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<slice::Slice>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::Range<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFrom<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeFull>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeTo<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<i32>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<isize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::convert::From<usize>>::from":["from","Real(LocalPath(\"src/slice.rs\"))","std::convert::From"],"<slice::SliceOrIndex as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/slice.rs\"))","std::fmt::Display"],"<std::ops::Range<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<std::ops::RangeFrom<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<std::ops::RangeFull as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<std::ops::RangeInclusive<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<std::ops::RangeTo<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<std::ops::RangeToInclusive<T> as slice::SliceNextDim<D1, <D1 as dimension::dimension_trait::Dimension>::Larger>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"<std::vec::Vec<usize> as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<usize as dimension::axes::IncOps>::post_dec":["post_dec","Real(LocalPath(\"src/dimension/axes.rs\"))","dimension::axes::IncOps"],"<usize as dimension::axes::IncOps>::post_inc":["post_inc","Real(LocalPath(\"src/dimension/axes.rs\"))","dimension::axes::IncOps"],"<usize as dimension::axes::IncOps>::pre_dec":["pre_dec","Real(LocalPath(\"src/dimension/axes.rs\"))","dimension::axes::IncOps"],"<usize as dimension::conversion::IntoDimension>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/conversion.rs\"))","dimension::conversion::IntoDimension"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<[usize; 1]>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_checked":["index_checked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<usize as dimension::ndindex::NdIndex<dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_unchecked":["index_unchecked","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::ndindex::NdIndex"],"<usize as slice::SliceNextDim<D1, D1>>::next_dim":["next_dim","Real(LocalPath(\"src/slice.rs\"))","slice::SliceNextDim"],"ArrayBase::<S, D>::broadcast_assume":["broadcast_assume","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::broadcast_unwrap":["broadcast_unwrap","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::broadcast_unwrap::broadcast_panic":["broadcast_panic","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::inner_rows":["inner_rows","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::inner_rows_mut":["inner_rows_mut","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::raw_strides":["raw_strides","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::try_remove_axis":["try_remove_axis","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBase::<S, D>::unordered_foreach_mut":["unordered_foreach_mut","Real(LocalPath(\"src/lib.rs\"))",""],"CowRepr::<'a, A>::is_owned":["is_owned","Real(LocalPath(\"src/lib.rs\"))",""],"CowRepr::<'a, A>::is_view":["is_view","Real(LocalPath(\"src/lib.rs\"))",""],"RawViewRepr::<A>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"ViewRepr::<A>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"aliases::Ix0":["Ix0","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::Ix1":["Ix1","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::Ix2":["Ix2","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::Ix3":["Ix3","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::Ix4":["Ix4","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::Ix5":["Ix5","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::Ix6":["Ix6","Real(LocalPath(\"src/aliases.rs\"))",""],"aliases::IxDyn":["IxDyn","Real(LocalPath(\"src/aliases.rs\"))",""],"arrayformat::<impl std::fmt::Binary for ArrayBase<S, D>>::fmt":["fmt","Real(LocalPath(\"src/arrayformat.rs\"))","std::fmt::Binary"],"arrayformat::<impl std::fmt::Debug for ArrayBase<S, D>>::fmt":["fmt","Real(LocalPath(\"src/arrayformat.rs\"))","std::fmt::Debug"],"arrayformat::<impl std::fmt::Display for ArrayBase<S, D>>::fmt":["fmt","Real(LocalPath(\"src/arrayformat.rs\"))","std::fmt::Display"],"arrayformat::<impl std::fmt::LowerExp for ArrayBase<S, D>>::fmt":["fmt","Real(LocalPath(\"src/arrayformat.rs\"))","std::fmt::LowerExp"],"arrayformat::<impl std::fmt::LowerHex for ArrayBase<S, D>>::fmt":["fmt","Real(LocalPath(\"src/arrayformat.rs\"))","std::fmt::LowerHex"],"arrayformat::<impl std::fmt::UpperExp for ArrayBase<S, D>>::fmt":["fmt","Real(LocalPath(\"src/arrayformat.rs\"))","std::fmt::UpperExp"],"arrayformat::FormatOptions::collapse_limit":["collapse_limit","Real(LocalPath(\"src/arrayformat.rs\"))",""],"arrayformat::FormatOptions::default_for_array":["default_for_array","Real(LocalPath(\"src/arrayformat.rs\"))",""],"arrayformat::FormatOptions::set_no_limit":["set_no_limit","Real(LocalPath(\"src/arrayformat.rs\"))",""],"arrayformat::format_array":["format_array","Real(LocalPath(\"src/arrayformat.rs\"))",""],"arrayformat::format_array_inner":["format_array_inner","Real(LocalPath(\"src/arrayformat.rs\"))",""],"arrayformat::format_with_overflow":["format_with_overflow","Real(LocalPath(\"src/arrayformat.rs\"))",""],"arraytraits::<impl std::cmp::PartialEq<ArrayBase<S2, D>> for ArrayBase<S, D>>::eq":["eq","Real(LocalPath(\"src/arraytraits.rs\"))","std::cmp::PartialEq"],"arraytraits::<impl std::convert::From<&'a ArrayBase<S, D>> for ArrayBase<ViewRepr<&'a A>, D>>::from":["from","Real(LocalPath(\"src/arraytraits.rs\"))","std::convert::From"],"arraytraits::<impl std::convert::From<&'a Slice> for ArrayBase<ViewRepr<&'a A>, dimension::dim::Dim<[usize; 1]>>>::from":["from","Real(LocalPath(\"src/arraytraits.rs\"))","std::convert::From"],"arraytraits::<impl std::convert::From<&'a mut ArrayBase<S, D>> for ArrayBase<ViewRepr<&'a mut A>, D>>::from":["from","Real(LocalPath(\"src/arraytraits.rs\"))","std::convert::From"],"arraytraits::<impl std::convert::From<&'a mut Slice> for ArrayBase<ViewRepr<&'a mut A>, dimension::dim::Dim<[usize; 1]>>>::from":["from","Real(LocalPath(\"src/arraytraits.rs\"))","std::convert::From"],"arraytraits::<impl std::convert::From<std::vec::Vec<A>> for ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from":["from","Real(LocalPath(\"src/arraytraits.rs\"))","std::convert::From"],"arraytraits::<impl std::default::Default for ArrayBase<S, D>>::default":["default","Real(LocalPath(\"src/arraytraits.rs\"))","std::default::Default"],"arraytraits::<impl std::hash::Hash for ArrayBase<S, D>>::hash":["hash","Real(LocalPath(\"src/arraytraits.rs\"))","std::hash::Hash"],"arraytraits::<impl std::iter::FromIterator<A> for ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from_iter":["from_iter","Real(LocalPath(\"src/arraytraits.rs\"))","std::iter::FromIterator"],"arraytraits::<impl std::iter::IntoIterator for &'a ArrayBase<S, D>>::into_iter":["into_iter","Real(LocalPath(\"src/arraytraits.rs\"))","std::iter::IntoIterator"],"arraytraits::<impl std::iter::IntoIterator for &'a mut ArrayBase<S, D>>::into_iter":["into_iter","Real(LocalPath(\"src/arraytraits.rs\"))","std::iter::IntoIterator"],"arraytraits::<impl std::iter::IntoIterator for ArrayBase<ViewRepr<&'a A>, D>>::into_iter":["into_iter","Real(LocalPath(\"src/arraytraits.rs\"))","std::iter::IntoIterator"],"arraytraits::<impl std::iter::IntoIterator for ArrayBase<ViewRepr<&'a mut A>, D>>::into_iter":["into_iter","Real(LocalPath(\"src/arraytraits.rs\"))","std::iter::IntoIterator"],"arraytraits::<impl std::ops::Index<I> for ArrayBase<S, D>>::index":["index","Real(LocalPath(\"src/arraytraits.rs\"))","std::ops::Index"],"arraytraits::<impl std::ops::IndexMut<I> for ArrayBase<S, D>>::index_mut":["index_mut","Real(LocalPath(\"src/arraytraits.rs\"))","std::ops::IndexMut"],"arraytraits::array_out_of_bounds":["array_out_of_bounds","Real(LocalPath(\"src/arraytraits.rs\"))",""],"arraytraits::debug_bounds_check":["debug_bounds_check","Real(LocalPath(\"src/arraytraits.rs\"))",""],"data_repr::OwnedRepr::<A>::as_nonnull_mut":["as_nonnull_mut","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_repr::OwnedRepr::<A>::as_ptr":["as_ptr","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_repr::OwnedRepr::<A>::as_slice":["as_slice","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_repr::OwnedRepr::<A>::from":["from","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_repr::OwnedRepr::<A>::into_vec":["into_vec","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_repr::OwnedRepr::<A>::len":["len","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_repr::OwnedRepr::<A>::take_as_vec":["take_as_vec","Real(LocalPath(\"src/data_repr.rs\"))",""],"data_traits::DataMut::ensure_unique":["ensure_unique","Real(LocalPath(\"src/data_traits.rs\"))",""],"data_traits::DataMut::is_unique":["is_unique","Real(LocalPath(\"src/data_traits.rs\"))",""],"data_traits::RawDataClone::clone_from_with_ptr":["clone_from_with_ptr","Real(LocalPath(\"src/data_traits.rs\"))",""],"dimension::abs_index":["abs_index","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::arith_seq_intersect":["arith_seq_intersect","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::axes::AxisDescription::axis":["axis","Real(LocalPath(\"src/dimension/axes.rs\"))",""],"dimension::axes::AxisDescription::len":["len","Real(LocalPath(\"src/dimension/axes.rs\"))",""],"dimension::axes::AxisDescription::stride":["stride","Real(LocalPath(\"src/dimension/axes.rs\"))",""],"dimension::axes::axes_of":["axes_of","Real(LocalPath(\"src/dimension/axes.rs\"))",""],"dimension::axis::Axis::index":["index","Real(LocalPath(\"src/dimension/axis.rs\"))",""],"dimension::can_index_slice":["can_index_slice","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::can_index_slice_not_custom":["can_index_slice_not_custom","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 0]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 0]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 1]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 1]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 2]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 2]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 3]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 3]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 4]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 4]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 5]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 5]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 6]>>::is_zero":["is_zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl num_traits::Zero for dimension::dim::Dim<[usize; 6]>>::zero":["zero","Real(LocalPath(\"src/dimension/conversion.rs\"))","num_traits::Zero"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 0]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 1]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 2]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 3]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 4]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 5]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::Index<usize> for dimension::dim::Dim<[usize; 6]>>::index":["index","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::Index"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 0]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 1]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 2]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 3]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 4]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 5]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::conversion::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<[usize; 6]>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/conversion.rs\"))","std::ops::IndexMut"],"dimension::dim::Dim":["Dim","Real(LocalPath(\"src/dimension/dim.rs\"))",""],"dimension::dim::Dim::<I>::ix":["ix","Real(LocalPath(\"src/dimension/dim.rs\"))",""],"dimension::dim::Dim::<I>::ixm":["ixm","Real(LocalPath(\"src/dimension/dim.rs\"))",""],"dimension::dim::Dim::<I>::new":["new","Real(LocalPath(\"src/dimension/dim.rs\"))",""],"dimension::dim_stride_overlap":["dim_stride_overlap","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::dimension_trait::<impl std::ops::Index<usize> for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::index":["index","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","std::ops::Index"],"dimension::dimension_trait::<impl std::ops::IndexMut<usize> for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::index_mut":["index_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))","std::ops::IndexMut"],"dimension::dimension_trait::Dimension::_fastest_varying_stride_order":["_fastest_varying_stride_order","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::as_array_view":["as_array_view","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::as_array_view_mut":["as_array_view_mut","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::default_strides":["default_strides","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::equal":["equal","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::first_index":["first_index","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::fortran_strides":["fortran_strides","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::from_dimension":["from_dimension","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::into_dyn":["into_dyn","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::is_contiguous":["is_contiguous","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::last_elem":["last_elem","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::max_stride_axis":["max_stride_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::min_stride_axis":["min_stride_axis","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::next_for":["next_for","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::next_for_f":["next_for_f","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::set_last_elem":["set_last_elem","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::size":["size","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::size_checked":["size_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::stride_offset":["stride_offset","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::stride_offset_checked":["stride_offset_checked","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::dimension_trait::Dimension::strides_equivalent":["strides_equivalent","Real(LocalPath(\"src/dimension/dimension_trait.rs\"))",""],"dimension::do_collapse_axis":["do_collapse_axis","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::do_slice":["do_slice","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::dynindeximpl::<impl dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::zeros":["zeros","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::dynindeximpl::<impl dimension::remove_axis::RemoveAxis for dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>::remove_axis":["remove_axis","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))","dimension::remove_axis::RemoveAxis"],"dimension::dynindeximpl::IxDynImpl::insert":["insert","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::dynindeximpl::IxDynImpl::remove":["remove","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::dynindeximpl::IxDynRepr::<T>::copy_from":["copy_from","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::dynindeximpl::IxDynRepr::<T>::from":["from","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::dynindeximpl::IxDynRepr::<T>::from_vec":["from_vec","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::dynindeximpl::IxDynRepr::<T>::from_vec_auto":["from_vec_auto","Real(LocalPath(\"src/dimension/dynindeximpl.rs\"))",""],"dimension::extended_gcd":["extended_gcd","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::max_abs_offset_check_overflow":["max_abs_offset_check_overflow","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::merge_axes":["merge_axes","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::ndindex::<impl dimension::conversion::IntoDimension for &'a [usize]>::into_dimension":["into_dimension","Real(LocalPath(\"src/dimension/ndindex.rs\"))","dimension::conversion::IntoDimension"],"dimension::size_of_shape_checked":["size_of_shape_checked","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::slice_min_max":["slice_min_max","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::slices_intersect":["slices_intersect","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::solve_linear_diophantine_eq":["solve_linear_diophantine_eq","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::stride_offset":["stride_offset","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::stride_offset_checked":["stride_offset_checked","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"dimension::to_abs_slice":["to_abs_slice","Real(LocalPath(\"src/dimension/mod.rs\"))",""],"error::ShapeError::from_kind":["from_kind","Real(LocalPath(\"src/error.rs\"))",""],"error::ShapeError::kind":["kind","Real(LocalPath(\"src/error.rs\"))",""],"error::from_kind":["from_kind","Real(LocalPath(\"src/error.rs\"))",""],"error::incompatible_shapes":["incompatible_shapes","Real(LocalPath(\"src/error.rs\"))",""],"extension::nonnull::nonnull_debug_checked_from_ptr":["nonnull_debug_checked_from_ptr","Real(LocalPath(\"src/extension/nonnull.rs\"))",""],"extension::nonnull::nonnull_from_vec_data":["nonnull_from_vec_data","Real(LocalPath(\"src/extension/nonnull.rs\"))",""],"free_functions::<impl std::convert::From<std::vec::Vec<V>> for ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 2]>>>::from":["from","Real(LocalPath(\"src/free_functions.rs\"))","std::convert::From"],"free_functions::<impl std::convert::From<std::vec::Vec<V>> for ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 3]>>>::from":["from","Real(LocalPath(\"src/free_functions.rs\"))","std::convert::From"],"free_functions::arr0":["arr0","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::arr1":["arr1","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::arr2":["arr2","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::arr3":["arr3","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::aview0":["aview0","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::aview1":["aview1","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::aview2":["aview2","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::aview_mut1":["aview_mut1","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::aview_mut2":["aview_mut2","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::rcarr1":["rcarr1","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::rcarr2":["rcarr2","Real(LocalPath(\"src/free_functions.rs\"))",""],"free_functions::rcarr3":["rcarr3","Real(LocalPath(\"src/free_functions.rs\"))",""],"geomspace::geomspace":["geomspace","Real(LocalPath(\"src/geomspace.rs\"))",""],"impl_1d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::to_vec":["to_vec","Real(LocalPath(\"src/impl_1d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::cols":["cols","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::column":["column","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::column_mut":["column_mut","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::is_square":["is_square","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::ncols":["ncols","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::nrows":["nrows","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::row":["row","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::row_mut":["row_mut","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_2d::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::rows":["rows","Real(LocalPath(\"src/impl_2d.rs\"))",""],"impl_clone::<impl std::clone::Clone for ArrayBase<S, D>>::clone":["clone","Real(LocalPath(\"src/impl_clone.rs\"))","std::clone::Clone"],"impl_clone::<impl std::clone::Clone for ArrayBase<S, D>>::clone_from":["clone_from","Real(LocalPath(\"src/impl_clone.rs\"))","std::clone::Clone"],"impl_constructors::<impl ArrayBase<S, D>>::default":["default","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_elem":["from_elem","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_fn":["from_shape_fn","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_simple_fn":["from_shape_simple_fn","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec":["from_shape_vec","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec_impl":["from_shape_vec_impl","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_shape_vec_unchecked":["from_shape_vec_unchecked","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::from_vec_dim_stride_unchecked":["from_vec_dim_stride_unchecked","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::maybe_uninit":["maybe_uninit","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::ones":["ones","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::uninitialized":["uninitialized","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, D>>::zeros":["zeros","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::from_vec":["from_vec","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::geomspace":["geomspace","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::linspace":["linspace","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::logspace":["logspace","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::range":["range","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::eye":["eye","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_constructors::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::from_diag":["from_diag","Real(LocalPath(\"src/impl_constructors.rs\"))",""],"impl_cow::<impl ArrayBase<CowRepr<'a, A>, D>>::is_owned":["is_owned","Real(LocalPath(\"src/impl_cow.rs\"))",""],"impl_cow::<impl ArrayBase<CowRepr<'a, A>, D>>::is_view":["is_view","Real(LocalPath(\"src/impl_cow.rs\"))",""],"impl_cow::<impl std::convert::From<ArrayBase<ViewRepr<&'a A>, D>> for ArrayBase<CowRepr<'a, A>, D>>::from":["from","Real(LocalPath(\"src/impl_cow.rs\"))","std::convert::From"],"impl_cow::<impl std::convert::From<ArrayBase<data_repr::OwnedRepr<A>, D>> for ArrayBase<CowRepr<'a, A>, D>>::from":["from","Real(LocalPath(\"src/impl_cow.rs\"))","std::convert::From"],"impl_dyn::<impl ArrayBase<S, dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::index_axis_inplace":["index_axis_inplace","Real(LocalPath(\"src/impl_dyn.rs\"))",""],"impl_dyn::<impl ArrayBase<S, dimension::dim::Dim<dimension::dynindeximpl::IxDynImpl>>>::insert_axis_inplace":["insert_axis_inplace","Real(LocalPath(\"src/impl_dyn.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::accumulate_axis_inplace":["accumulate_axis_inplace","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_mut_ptr":["as_mut_ptr","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_ptr":["as_ptr","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_slice":["as_slice","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_slice_memory_order":["as_slice_memory_order","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_slice_memory_order_mut":["as_slice_memory_order_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_slice_mut":["as_slice_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::as_standard_layout":["as_standard_layout","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::assign":["assign","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::axes":["axes","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::axis_chunks_iter":["axis_chunks_iter","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::axis_chunks_iter_mut":["axis_chunks_iter_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::axis_iter":["axis_iter","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::axis_iter_mut":["axis_iter_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::broadcast":["broadcast","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::broadcast::upcast":["upcast","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::collapse_axis":["collapse_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::diag":["diag","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::diag_mut":["diag_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::diag_params":["diag_params","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::dim":["dim","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::ensure_unique":["ensure_unique","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::exact_chunks":["exact_chunks","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::exact_chunks_mut":["exact_chunks_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::fill":["fill","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::first":["first","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::first_mut":["first_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::fold":["fold","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::fold_axis":["fold_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::gencolumns":["gencolumns","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::gencolumns_mut":["gencolumns_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::genrows":["genrows","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::genrows_mut":["genrows_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::get":["get","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::get_0d":["get_0d","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::get_mut":["get_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::get_ptr":["get_ptr","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::get_ptr_mut":["get_ptr_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::index_axis":["index_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::index_axis_move":["index_axis_move","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::index_axis_mut":["index_axis_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::indexed_iter":["indexed_iter","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::indexed_iter_mut":["indexed_iter_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::insert_axis":["insert_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_diag":["into_diag","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_dimensionality":["into_dimensionality","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_dyn":["into_dyn","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_owned":["into_owned","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_shape":["into_shape","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_shared":["into_shared","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::into_subview":["into_subview","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::invert_axis":["invert_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::is_contiguous":["is_contiguous","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::is_empty":["is_empty","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::is_standard_layout":["is_standard_layout","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::is_standard_layout::is_standard_layout":["is_standard_layout","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::iter":["iter","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::iter_mut":["iter_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::lanes":["lanes","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::lanes_mut":["lanes_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::len":["len","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::len_of":["len_of","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::map":["map","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::map_axis":["map_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::map_axis_mut":["map_axis_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::map_inplace":["map_inplace","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::map_mut":["map_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::mapv":["mapv","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::mapv_inplace":["mapv_inplace","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::mapv_into":["mapv_into","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::max_stride_axis":["max_stride_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::merge_axes":["merge_axes","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::multi_slice_mut":["multi_slice_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::ndim":["ndim","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::outer_iter":["outer_iter","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::outer_iter_mut":["outer_iter_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::permuted_axes":["permuted_axes","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::pointer_is_inbounds":["pointer_is_inbounds","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::raw_dim":["raw_dim","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::raw_view":["raw_view","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::raw_view_mut":["raw_view_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::remove_axis":["remove_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::reshape":["reshape","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::reversed_axes":["reversed_axes","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::select":["select","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::shape":["shape","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice":["slice","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_axis":["slice_axis","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_axis_inplace":["slice_axis_inplace","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_axis_mut":["slice_axis_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_collapse":["slice_collapse","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_inplace":["slice_inplace","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_move":["slice_move","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::slice_mut":["slice_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::stride_of":["stride_of","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::strides":["strides","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::subview":["subview","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::subview_inplace":["subview_inplace","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::subview_mut":["subview_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::swap":["swap","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::swap_axes":["swap_axes","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::t":["t","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::to_owned":["to_owned","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::to_shared":["to_shared","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::try_ensure_unique":["try_ensure_unique","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::uget":["uget","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::uget_mut":["uget_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::uswap":["uswap","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::view":["view","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::view_mut":["view_mut","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::visit":["visit","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::windows":["windows","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with":["zip_mut_with","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_by_rows":["zip_mut_with_by_rows","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_elem":["zip_mut_with_elem","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_methods::<impl ArrayBase<S, D>>::zip_mut_with_same_shape":["zip_mut_with_same_shape","Real(LocalPath(\"src/impl_methods.rs\"))",""],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for f32>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for f64>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i128>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i16>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i32>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i64>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for i8>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u128>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u16>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u32>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u64>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S, D>> for u8>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for f32>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for f64>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i128>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i16>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i32>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i64>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for i8>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for num_complex::Complex<f32>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for num_complex::Complex<f64>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u128>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u16>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u32>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u64>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S, D>> for u8>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<ArrayBase<S2, E>> for ArrayBase<S, D>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<B> for &'a ArrayBase<S, D>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::Add<B> for ArrayBase<S, D>>::add":["add","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Add"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for bool>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i128>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i16>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i32>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i64>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for i8>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u128>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u16>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u32>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u64>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S, D>> for u8>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for bool>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i128>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i16>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i32>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i64>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for i8>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u128>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u16>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u32>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u64>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S, D>> for u8>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<B> for &'a ArrayBase<S, D>>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitAnd<B> for ArrayBase<S, D>>::bitand":["bitand","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAnd"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for bool>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i128>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i16>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i32>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i64>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for i8>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u128>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u16>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u32>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u64>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S, D>> for u8>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for bool>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i128>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i16>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i32>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i64>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for i8>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u128>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u16>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u32>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u64>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S, D>> for u8>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<B> for &'a ArrayBase<S, D>>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitOr<B> for ArrayBase<S, D>>::bitor":["bitor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOr"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for bool>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i128>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i16>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i32>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i64>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for i8>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u128>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u16>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u32>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u64>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S, D>> for u8>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for bool>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i128>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i16>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i32>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i64>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for i8>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u128>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u16>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u32>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u64>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S, D>> for u8>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<B> for &'a ArrayBase<S, D>>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::BitXor<B> for ArrayBase<S, D>>::bitxor":["bitxor","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXor"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for f32>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for f64>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i128>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i16>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i32>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i64>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for i8>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u128>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u16>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u32>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u64>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S, D>> for u8>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for f32>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for f64>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i128>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i16>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i32>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i64>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for i8>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for num_complex::Complex<f32>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for num_complex::Complex<f64>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u128>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u16>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u32>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u64>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S, D>> for u8>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<ArrayBase<S2, E>> for ArrayBase<S, D>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<B> for &'a ArrayBase<S, D>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Div<B> for ArrayBase<S, D>>::div":["div","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Div"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for f32>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for f64>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i128>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i16>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i32>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i64>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for i8>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u128>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u16>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u32>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u64>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S, D>> for u8>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for f32>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for f64>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i128>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i16>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i32>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i64>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for i8>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for num_complex::Complex<f32>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for num_complex::Complex<f64>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u128>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u16>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u32>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u64>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S, D>> for u8>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<ArrayBase<S2, E>> for ArrayBase<S, D>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<B> for &'a ArrayBase<S, D>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Mul<B> for ArrayBase<S, D>>::mul":["mul","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Mul"],"impl_ops::arithmetic_ops::<impl std::ops::Neg for &'a ArrayBase<S, D>>::neg":["neg","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Neg"],"impl_ops::arithmetic_ops::<impl std::ops::Neg for ArrayBase<S, D>>::neg":["neg","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Neg"],"impl_ops::arithmetic_ops::<impl std::ops::Not for &'a ArrayBase<S, D>>::not":["not","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Not"],"impl_ops::arithmetic_ops::<impl std::ops::Not for ArrayBase<S, D>>::not":["not","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Not"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for f32>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for f64>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i128>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i16>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i32>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i64>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for i8>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u128>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u16>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u32>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u64>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S, D>> for u8>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for f32>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for f64>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i128>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i16>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i32>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i64>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for i8>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u128>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u16>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u32>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u64>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S, D>> for u8>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<ArrayBase<S2, E>> for ArrayBase<S, D>>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<B> for &'a ArrayBase<S, D>>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Rem<B> for ArrayBase<S, D>>::rem":["rem","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Rem"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i128>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i16>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i32>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i64>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for i8>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u128>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u16>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u32>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u64>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S, D>> for u8>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i128>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i16>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i32>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i64>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for i8>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u128>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u16>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u32>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u64>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S, D>> for u8>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<ArrayBase<S2, E>> for ArrayBase<S, D>>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<B> for &'a ArrayBase<S, D>>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shl<B> for ArrayBase<S, D>>::shl":["shl","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shl"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i128>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i16>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i32>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i64>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for i8>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u128>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u16>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u32>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u64>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S, D>> for u8>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i128>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i16>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i32>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i64>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for i8>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u128>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u16>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u32>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u64>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S, D>> for u8>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<ArrayBase<S2, E>> for ArrayBase<S, D>>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<B> for &'a ArrayBase<S, D>>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Shr<B> for ArrayBase<S, D>>::shr":["shr","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Shr"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for f32>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for f64>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i128>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i16>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i32>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i64>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for i8>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for num_complex::Complex<f32>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for num_complex::Complex<f64>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u128>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u16>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u32>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u64>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S, D>> for u8>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S2, E>> for &'a ArrayBase<S, D>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for f32>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for f64>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i128>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i16>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i32>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i64>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for i8>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for num_complex::Complex<f32>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for num_complex::Complex<f64>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u128>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u16>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u32>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u64>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S, D>> for u8>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<ArrayBase<S2, E>> for ArrayBase<S, D>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<B> for &'a ArrayBase<S, D>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::arithmetic_ops::<impl std::ops::Sub<B> for ArrayBase<S, D>>::sub":["sub","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::Sub"],"impl_ops::assign_ops::<impl std::ops::AddAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::add_assign":["add_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::AddAssign"],"impl_ops::assign_ops::<impl std::ops::AddAssign<A> for ArrayBase<S, D>>::add_assign":["add_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::AddAssign"],"impl_ops::assign_ops::<impl std::ops::BitAndAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitand_assign":["bitand_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAndAssign"],"impl_ops::assign_ops::<impl std::ops::BitAndAssign<A> for ArrayBase<S, D>>::bitand_assign":["bitand_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitAndAssign"],"impl_ops::assign_ops::<impl std::ops::BitOrAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitor_assign":["bitor_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOrAssign"],"impl_ops::assign_ops::<impl std::ops::BitOrAssign<A> for ArrayBase<S, D>>::bitor_assign":["bitor_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitOrAssign"],"impl_ops::assign_ops::<impl std::ops::BitXorAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::bitxor_assign":["bitxor_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXorAssign"],"impl_ops::assign_ops::<impl std::ops::BitXorAssign<A> for ArrayBase<S, D>>::bitxor_assign":["bitxor_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::BitXorAssign"],"impl_ops::assign_ops::<impl std::ops::DivAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::div_assign":["div_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::DivAssign"],"impl_ops::assign_ops::<impl std::ops::DivAssign<A> for ArrayBase<S, D>>::div_assign":["div_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::DivAssign"],"impl_ops::assign_ops::<impl std::ops::MulAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::mul_assign":["mul_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::MulAssign"],"impl_ops::assign_ops::<impl std::ops::MulAssign<A> for ArrayBase<S, D>>::mul_assign":["mul_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::MulAssign"],"impl_ops::assign_ops::<impl std::ops::RemAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::rem_assign":["rem_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::RemAssign"],"impl_ops::assign_ops::<impl std::ops::RemAssign<A> for ArrayBase<S, D>>::rem_assign":["rem_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::RemAssign"],"impl_ops::assign_ops::<impl std::ops::ShlAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shl_assign":["shl_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::ShlAssign"],"impl_ops::assign_ops::<impl std::ops::ShlAssign<A> for ArrayBase<S, D>>::shl_assign":["shl_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::ShlAssign"],"impl_ops::assign_ops::<impl std::ops::ShrAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::shr_assign":["shr_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::ShrAssign"],"impl_ops::assign_ops::<impl std::ops::ShrAssign<A> for ArrayBase<S, D>>::shr_assign":["shr_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::ShrAssign"],"impl_ops::assign_ops::<impl std::ops::SubAssign<&'a ArrayBase<S2, E>> for ArrayBase<S, D>>::sub_assign":["sub_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::SubAssign"],"impl_ops::assign_ops::<impl std::ops::SubAssign<A> for ArrayBase<S, D>>::sub_assign":["sub_assign","Real(LocalPath(\"src/impl_ops.rs\"))","std::ops::SubAssign"],"impl_owned_array::<impl ArrayBase<data_repr::OwnedRepr<A>, D>>::into_raw_vec":["into_raw_vec","Real(LocalPath(\"src/impl_owned_array.rs\"))",""],"impl_owned_array::<impl ArrayBase<data_repr::OwnedRepr<A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["into_scalar","Real(LocalPath(\"src/impl_owned_array.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::cast":["cast","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::deref_into_view":["deref_into_view","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::from_shape_ptr":["from_shape_ptr","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::new":["new","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::new_":["new_","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*const A>, D>>::split_at":["split_at","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::cast":["cast","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::deref_into_view":["deref_into_view","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::deref_into_view_mut":["deref_into_view_mut","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::from_shape_ptr":["from_shape_ptr","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::into_raw_view":["into_raw_view","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::new":["new","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::new_":["new_","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_raw_views::<impl ArrayBase<RawViewRepr<*mut A>, D>>::split_at":["split_at","Real(LocalPath(\"src/impl_raw_views.rs\"))",""],"impl_special_element_types::<impl ArrayBase<S, D>>::assume_init":["assume_init","Real(LocalPath(\"src/impl_special_element_types.rs\"))",""],"impl_special_element_types::unlimited_transmute":["unlimited_transmute","Real(LocalPath(\"src/impl_special_element_types.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape":["from_shape","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape_impl":["from_shape_impl","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::from_shape_ptr":["from_shape_ptr","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::new":["new","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a A>, D>>::new_":["new_","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape":["from_shape","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape_impl":["from_shape_impl","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::from_shape_ptr":["from_shape_ptr","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::new":["new","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::new_":["new_","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::constructors::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::reborrow":["reborrow","Real(LocalPath(\"src/impl_views/constructors.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_base_iter":["into_base_iter","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_elements_base":["into_elements_base","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_iter_":["into_iter_","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_outer_iter":["into_outer_iter","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_raw_view":["into_raw_view","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::into_slice":["into_slice","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::reborrow":["reborrow","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, D>>::to_slice":["to_slice","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["into_scalar","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_base_iter":["into_base_iter","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_elements_base":["into_elements_base","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_iter_":["into_iter_","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_outer_iter":["into_outer_iter","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_raw_view_mut":["into_raw_view_mut","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_slice":["into_slice","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_slice_":["into_slice_","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::into_view":["into_view","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::conversions::<impl ArrayBase<ViewRepr<&'a mut A>, dimension::dim::Dim<[usize; 0]>>>::into_scalar":["into_scalar","Real(LocalPath(\"src/impl_views/conversions.rs\"))",""],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a A>, D>>::split_at":["split_at","Real(LocalPath(\"src/impl_views/splitting.rs\"))",""],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::multi_slice_move":["multi_slice_move","Real(LocalPath(\"src/impl_views/splitting.rs\"))",""],"impl_views::splitting::<impl ArrayBase<ViewRepr<&'a mut A>, D>>::split_at":["split_at","Real(LocalPath(\"src/impl_views/splitting.rs\"))",""],"indexes::indices":["indices","Real(LocalPath(\"src/indexes.rs\"))",""],"indexes::indices_iter_f":["indices_iter_f","Real(LocalPath(\"src/indexes.rs\"))",""],"indexes::indices_of":["indices_of","Real(LocalPath(\"src/indexes.rs\"))",""],"is_aligned":["is_aligned","Real(LocalPath(\"src/lib.rs\"))",""],"iterators::AxisChunksIter::<'a, A, D>::get_subview":["get_subview","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisChunksIter::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisChunksIter::<'a, A, D>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisChunksIterMut::<'a, A, D>::get_subview":["get_subview","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisChunksIterMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisChunksIterMut::<'a, A, D>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIter::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIter::<'a, A, D>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterCore::<A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterCore::<A, D>::next_back_with_index":["next_back_with_index","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterCore::<A, D>::next_with_index":["next_with_index","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterCore::<A, D>::offset":["offset","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterCore::<A, D>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::AxisIterMut::<'a, A, D>::split_at":["split_at","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::Baseiter::<A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::ElementsBase::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::ElementsBaseMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::IndexedIter::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::IndexedIterMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::Iter::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::IterMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::chunk_iter_parts":["chunk_iter_parts","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::chunks::ExactChunks::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/chunks.rs\"))",""],"iterators::chunks::ExactChunksMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/chunks.rs\"))",""],"iterators::lanes::Lanes::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/lanes.rs\"))",""],"iterators::lanes::LanesMut::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/lanes.rs\"))",""],"iterators::to_vec":["to_vec","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::to_vec_mapped":["to_vec_mapped","Real(LocalPath(\"src/iterators/mod.rs\"))",""],"iterators::windows::Windows::<'a, A, D>::new":["new","Real(LocalPath(\"src/iterators/windows.rs\"))",""],"itertools::enumerate":["enumerate","Real(LocalPath(\"src/itertools.rs\"))",""],"itertools::zip":["zip","Real(LocalPath(\"src/itertools.rs\"))",""],"layout::Layout::and":["and","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::c":["c","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::f":["f","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::flag":["flag","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::is":["is","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::new":["new","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::none":["none","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::Layout::one_dimensional":["one_dimensional","Real(LocalPath(\"src/layout/mod.rs\"))",""],"layout::layoutfmt::<impl std::fmt::Debug for layout::Layout>::fmt":["fmt","Real(LocalPath(\"src/layout/layoutfmt.rs\"))","std::fmt::Debug"],"linalg::impl_linalg::<impl ArrayBase<S, D>>::scaled_add":["scaled_add","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot":["dot","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot_generic":["dot_generic","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 1]>>>::dot_impl":["dot_impl","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::<impl ArrayBase<S, dimension::dim::Dim<[usize; 2]>>>::dot":["dot","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::cast_as":["cast_as","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::dot_shape_error":["dot_shape_error","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::general_dot_shape_error":["general_dot_shape_error","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::general_mat_mul":["general_mat_mul","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::general_mat_vec_mul":["general_mat_vec_mul","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::mat_mul_general":["mat_mul_general","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linalg::impl_linalg::same_type":["same_type","Real(LocalPath(\"src/linalg/impl_linalg.rs\"))",""],"linspace::linspace":["linspace","Real(LocalPath(\"src/linspace.rs\"))",""],"linspace::range":["range","Real(LocalPath(\"src/linspace.rs\"))",""],"logspace::logspace":["logspace","Real(LocalPath(\"src/logspace.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::all_close":["all_close","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::mean":["mean","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::mean_axis":["mean_axis","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::product":["product","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::scalar_sum":["scalar_sum","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::std_axis":["std_axis","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::sum":["sum","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::sum_axis":["sum_axis","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric::impl_numeric::<impl ArrayBase<S, D>>::var_axis":["var_axis","Real(LocalPath(\"src/numeric/impl_numeric.rs\"))",""],"numeric_util::unrolled_dot":["unrolled_dot","Real(LocalPath(\"src/numeric_util.rs\"))",""],"numeric_util::unrolled_eq":["unrolled_eq","Real(LocalPath(\"src/numeric_util.rs\"))",""],"numeric_util::unrolled_fold":["unrolled_fold","Real(LocalPath(\"src/numeric_util.rs\"))",""],"shape_builder::<impl Shape<D>>::size":["size","Real(LocalPath(\"src/shape_builder.rs\"))",""],"shape_builder::<impl std::convert::From<D> for Shape<D>>::from":["from","Real(LocalPath(\"src/shape_builder.rs\"))","std::convert::From"],"shape_builder::<impl std::convert::From<T> for StrideShape<D>>::from":["from","Real(LocalPath(\"src/shape_builder.rs\"))","std::convert::From"],"slice::Slice::new":["new","Real(LocalPath(\"src/slice.rs\"))",""],"slice::Slice::step_by":["step_by","Real(LocalPath(\"src/slice.rs\"))",""],"slice::SliceInfo::<T, D>::new":["new","Real(LocalPath(\"src/slice.rs\"))",""],"slice::SliceInfo::<T, D>::new_unchecked":["new_unchecked","Real(LocalPath(\"src/slice.rs\"))",""],"slice::SliceInfo::<T, D>::out_ndim":["out_ndim","Real(LocalPath(\"src/slice.rs\"))",""],"slice::SliceOrIndex::is_index":["is_index","Real(LocalPath(\"src/slice.rs\"))",""],"slice::SliceOrIndex::is_slice":["is_slice","Real(LocalPath(\"src/slice.rs\"))",""],"slice::SliceOrIndex::step_by":["step_by","Real(LocalPath(\"src/slice.rs\"))",""],"stacking::stack":["stack","Real(LocalPath(\"src/stacking.rs\"))",""],"zip::<impl ArrayBase<S, D>>::layout_impl":["layout_impl","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::FoldWhile::<T>::into_inner":["into_inner","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::FoldWhile::<T>::is_done":["is_done","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::NdProducer::equal_dim":["equal_dim","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P,), D>::from":["from","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::all":["all","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::and":["and","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::and_broadcast":["and_broadcast","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::apply":["apply","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::apply_assign_into":["apply_assign_into","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::apply_collect":["apply_collect","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::fold":["fold","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::fold_while":["fold_while","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2), D>::split":["split","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::all":["all","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::and":["and","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::and_broadcast":["and_broadcast","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::apply":["apply","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::apply_assign_into":["apply_assign_into","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::apply_collect":["apply_collect","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::fold":["fold","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::fold_while":["fold_while","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3), D>::split":["split","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::all":["all","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::and":["and","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::and_broadcast":["and_broadcast","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::apply":["apply","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::apply_assign_into":["apply_assign_into","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::apply_collect":["apply_collect","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::fold":["fold","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::fold_while":["fold_while","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4), D>::split":["split","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::all":["all","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::and":["and","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::and_broadcast":["and_broadcast","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply":["apply","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply_assign_into":["apply_assign_into","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::apply_collect":["apply_collect","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::fold":["fold","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::fold_while":["fold_while","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5), D>::split":["split","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::all":["all","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::apply":["apply","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::fold":["fold","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::fold_while":["fold_while","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1, P2, P3, P4, P5, P6), D>::split":["split","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::all":["all","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::and":["and","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::and_broadcast":["and_broadcast","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::apply":["apply","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::apply_assign_into":["apply_assign_into","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::apply_collect":["apply_collect","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::fold":["fold","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::fold_while":["fold_while","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(P1,), D>::split":["split","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<(indexes::Indices<D>, P), D>::indexed":["indexed","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<P, D>::apply_core":["apply_core","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<P, D>::apply_core_contiguous":["apply_core_contiguous","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<P, D>::apply_core_strided":["apply_core_strided","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<P, D>::uninitalized_for_current_layout":["uninitalized_for_current_layout","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<Parts, D>::check":["check","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<Parts, D>::len_of":["len_of","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<Parts, D>::max_stride_axis":["max_stride_axis","Real(LocalPath(\"src/zip/mod.rs\"))",""],"zip::Zip::<Parts, D>::size":["size","Real(LocalPath(\"src/zip/mod.rs\"))",""]},"trait_to_struct":{"arraytraits::AsArray":["<T as arraytraits::AsArray<'a, A, D>>::T"],"data_traits::Data":["CowRepr","OwnedArcRepr","ViewRepr","data_repr::OwnedRepr"],"data_traits::DataClone":["<T as data_traits::DataClone>::T"],"data_traits::DataMut":["CowRepr","OwnedArcRepr","ViewRepr","data_repr::OwnedRepr"],"data_traits::DataOwned":["OwnedArcRepr","data_repr::OwnedRepr"],"data_traits::DataShared":["OwnedArcRepr","ViewRepr"],"data_traits::RawData":["CowRepr","OwnedArcRepr","RawViewRepr","ViewRepr","data_repr::OwnedRepr"],"data_traits::RawDataClone":["CowRepr","OwnedArcRepr","RawViewRepr","ViewRepr","data_repr::OwnedRepr"],"data_traits::RawDataMut":["CowRepr","OwnedArcRepr","RawViewRepr","ViewRepr","data_repr::OwnedRepr"],"data_traits::RawDataSubst":["OwnedArcRepr","RawViewRepr","ViewRepr","data_repr::OwnedRepr"],"dimension::DimensionExt":["<D as dimension::DimensionExt>::D"],"dimension::conversion::IntoDimension":["<D as dimension::conversion::IntoDimension>::D","Ix","dimension::dynindeximpl::IxDynImpl","std::vec::Vec"],"dimension::dimension_trait::Dimension":["aliases::IxDyn","dimension::dim::Dim"],"dimension::ndindex::NdIndex":["<D as dimension::ndindex::NdIndex<D>>::D","Ix","dimension::dim::Dim"],"dimension::remove_axis::RemoveAxis":["dimension::dim::Dim"],"impl_ops::ScalarOperand":["num_complex::Complex"],"impl_views::indexing::IndexLonger":["ArrayViewMut"],"iterators::TrustedIterator":["geomspace::Geomspace","indexes::IndicesIter","indexes::IndicesIterF","iterators::Iter","iterators::IterMut","linspace::Linspace","logspace::Logspace","std::iter::Cloned","std::iter::Map","std::ops::Range","std::slice::Iter","std::slice::IterMut"],"linalg::impl_linalg::Dot":["ArrayBase"],"linalg_traits::LinalgScalar":["<T as linalg_traits::LinalgScalar>::T"],"num_traits::Zero":["dimension::dim::Dim"],"shape_builder::ShapeBuilder":["<T as shape_builder::ShapeBuilder>::T","Shape"],"slice::SliceNextDim":["slice::Slice","std::ops::Range","std::ops::RangeFrom","std::ops::RangeFull","std::ops::RangeInclusive","std::ops::RangeTo","std::ops::RangeToInclusive"],"std::clone::Clone":["ArrayBase","OwnedArcRepr","RawViewRepr","Shape","StrideShape","ViewRepr","arrayformat::FormatOptions","data_repr::OwnedRepr","dimension::axes::Axes","dimension::axes::AxisDescription","dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","error::ErrorKind","error::ShapeError","indexes::IndexPtr","indexes::Indices","indexes::IndicesIter","indexes::IndicesIterF","iterators::AxisChunksIter","iterators::AxisIter","iterators::AxisIterCore","iterators::Baseiter","iterators::ElementsBase","iterators::ElementsRepr","iterators::IndexedIter","iterators::Iter","iterators::LanesIter","iterators::chunks::ExactChunks","iterators::chunks::ExactChunksIter","iterators::lanes::Lanes","iterators::windows::Windows","iterators::windows::WindowsIter","layout::Layout","slice::Slice","slice::SliceInfo","slice::SliceOrIndex","zip::FoldWhile","zip::Zip"],"std::cmp::Eq":["ArrayBase","dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","slice::Slice","slice::SliceOrIndex"],"std::cmp::Ord":["dimension::axis::Axis"],"std::cmp::PartialEq":["ArrayBase","dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","error::ErrorKind","error::ShapeError","slice::Slice","slice::SliceOrIndex"],"std::cmp::PartialOrd":["dimension::axis::Axis"],"std::convert::AsRef":["slice::SliceInfo"],"std::convert::From":["ArrayBase","ArrayView","ArrayViewMut","CowArray","Shape","StrideShape","aliases::Array2","aliases::Array3","dimension::dynindeximpl::IxDynImpl","slice::Slice","slice::SliceOrIndex"],"std::default::Default":["ArrayBase","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr"],"std::error::Error":["error::ShapeError"],"std::fmt::Binary":["ArrayBase"],"std::fmt::Debug":["ArrayBase","OwnedArcRepr","Shape","StrideShape","arrayformat::FormatOptions","data_repr::OwnedRepr","dimension::axes::Axes","dimension::axes::AxisDescription","dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","error::ErrorKind","error::ShapeError","indexes::IndexPtr","indexes::Indices","iterators::AxisIter","iterators::AxisIterCore","layout::Layout","slice::Slice","slice::SliceInfo","slice::SliceOrIndex","zip::FoldWhile","zip::Zip"],"std::fmt::Display":["ArrayBase","error::ShapeError","slice::SliceOrIndex"],"std::fmt::LowerExp":["ArrayBase"],"std::fmt::LowerHex":["ArrayBase"],"std::fmt::UpperExp":["ArrayBase"],"std::hash::Hash":["ArrayBase","dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","slice::Slice","slice::SliceOrIndex"],"std::iter::DoubleEndedIterator":["dimension::axes::Axes","geomspace::Geomspace","iterators::AxisChunksIter","iterators::AxisChunksIterMut","iterators::AxisIter","iterators::AxisIterCore","iterators::AxisIterMut","iterators::Baseiter","iterators::ElementsBase","iterators::ElementsBaseMut","iterators::Iter","iterators::IterMut","linspace::Linspace","logspace::Logspace"],"std::iter::ExactSizeIterator":["geomspace::Geomspace","indexes::IndicesIter","indexes::IndicesIterF","iterators::AxisChunksIter","iterators::AxisChunksIterMut","iterators::AxisIter","iterators::AxisIterCore","iterators::AxisIterMut","iterators::Baseiter","iterators::ElementsBase","iterators::ElementsBaseMut","iterators::IndexedIter","iterators::IndexedIterMut","iterators::Iter","iterators::IterMut","iterators::LanesIter","iterators::LanesIterMut","linspace::Linspace","logspace::Logspace"],"std::iter::FromIterator":["ArrayBase"],"std::iter::IntoIterator":["ArrayView","ArrayViewMut","indexes::Indices","iterators::chunks::ExactChunks","iterators::chunks::ExactChunksMut","iterators::lanes::Lanes","iterators::lanes::LanesMut","iterators::windows::Windows"],"std::iter::Iterator":["dimension::axes::Axes","geomspace::Geomspace","indexes::IndicesIter","indexes::IndicesIterF","iterators::AxisChunksIter","iterators::AxisChunksIterMut","iterators::AxisIter","iterators::AxisIterCore","iterators::AxisIterMut","iterators::Baseiter","iterators::ElementsBase","iterators::ElementsBaseMut","iterators::IndexedIter","iterators::IndexedIterMut","iterators::Iter","iterators::IterMut","iterators::LanesIter","iterators::LanesIterMut","iterators::chunks::ExactChunksIter","iterators::chunks::ExactChunksIterMut","iterators::windows::WindowsIter","linspace::Linspace","logspace::Logspace"],"std::marker::Copy":["ArrayBase","RawViewRepr","Shape","StrideShape","ViewRepr","dimension::axes::Axes","dimension::axes::AxisDescription","dimension::axis::Axis","dimension::dim::Dim","error::ErrorKind","indexes::IndexPtr","indexes::Indices","layout::Layout","slice::Slice","slice::SliceInfo","slice::SliceOrIndex","zip::FoldWhile"],"std::marker::Send":["ArrayBase","data_repr::OwnedRepr","iterators::AxisChunksIter","iterators::AxisChunksIterMut","iterators::AxisIter","iterators::AxisIterMut","iterators::ElementsBase","iterators::ElementsBaseMut","iterators::IndexedIter","iterators::IndexedIterMut","iterators::Iter","iterators::IterMut","iterators::LanesIter","iterators::LanesIterMut"],"std::marker::StructuralEq":["dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","slice::Slice","slice::SliceOrIndex"],"std::marker::StructuralPartialEq":["dimension::axis::Axis","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl","slice::Slice","slice::SliceOrIndex"],"std::marker::Sync":["ArrayBase","data_repr::OwnedRepr","iterators::AxisChunksIter","iterators::AxisChunksIterMut","iterators::AxisIter","iterators::AxisIterMut","iterators::ElementsBase","iterators::ElementsBaseMut","iterators::IndexedIter","iterators::IndexedIterMut","iterators::Iter","iterators::IterMut","iterators::LanesIter","iterators::LanesIterMut"],"std::ops::Add":["ArrayBase","dimension::dim::Dim","num_complex::Complex"],"std::ops::AddAssign":["ArrayBase","dimension::dim::Dim"],"std::ops::BitAnd":["ArrayBase"],"std::ops::BitAndAssign":["ArrayBase"],"std::ops::BitOr":["ArrayBase"],"std::ops::BitOrAssign":["ArrayBase"],"std::ops::BitXor":["ArrayBase"],"std::ops::BitXorAssign":["ArrayBase"],"std::ops::Deref":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr","slice::SliceInfo"],"std::ops::DerefMut":["dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr"],"std::ops::Div":["ArrayBase","num_complex::Complex"],"std::ops::DivAssign":["ArrayBase"],"std::ops::Drop":["data_repr::OwnedRepr"],"std::ops::Index":["ArrayBase","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl"],"std::ops::IndexMut":["ArrayBase","dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl"],"std::ops::Mul":["ArrayBase","dimension::dim::Dim","num_complex::Complex"],"std::ops::MulAssign":["ArrayBase","dimension::dim::Dim"],"std::ops::Neg":["ArrayBase"],"std::ops::Not":["ArrayBase"],"std::ops::Rem":["ArrayBase"],"std::ops::RemAssign":["ArrayBase"],"std::ops::Shl":["ArrayBase"],"std::ops::ShlAssign":["ArrayBase"],"std::ops::Shr":["ArrayBase"],"std::ops::ShrAssign":["ArrayBase"],"std::ops::Sub":["ArrayBase","dimension::dim::Dim","num_complex::Complex"],"std::ops::SubAssign":["ArrayBase","dimension::dim::Dim"],"zip::Broadcast":["ArrayView"],"zip::IntoNdProducer":["<P as zip::IntoNdProducer>::P"],"zip::NdProducer":["ArrayView","ArrayViewMut","RawArrayView","RawArrayViewMut","indexes::Indices","iterators::AxisIter","iterators::AxisIterMut","iterators::chunks::ExactChunks","iterators::chunks::ExactChunksMut","iterators::lanes::Lanes","iterators::lanes::LanesMut","iterators::windows::Windows"],"zip::Offset":["indexes::IndexPtr"],"zip::Splittable":["<D as zip::Splittable>::D"]},"type_to_def_path":{"ArrayBase<S, D>":"ArrayBase","CowRepr<'a, A>":"CowRepr","OwnedArcRepr<A>":"OwnedArcRepr","RawViewRepr<A>":"RawViewRepr","Shape<D>":"Shape","StrideShape<D>":"StrideShape","ViewRepr<A>":"ViewRepr","arrayformat::FormatOptions":"arrayformat::FormatOptions","data_repr::OwnedRepr<A>":"data_repr::OwnedRepr","dimension::axes::Axes<'a, D>":"dimension::axes::Axes","dimension::axes::AxisDescription":"dimension::axes::AxisDescription","dimension::axis::Axis":"dimension::axis::Axis","dimension::dim::Dim<I>":"dimension::dim::Dim","dimension::dynindeximpl::IxDynImpl":"dimension::dynindeximpl::IxDynImpl","dimension::dynindeximpl::IxDynRepr<T>":"dimension::dynindeximpl::IxDynRepr","error::ErrorKind":"error::ErrorKind","error::ShapeError":"error::ShapeError","geomspace::Geomspace<F>":"geomspace::Geomspace","indexes::IndexPtr<D>":"indexes::IndexPtr","indexes::Indices<D>":"indexes::Indices","indexes::IndicesIter<D>":"indexes::IndicesIter","indexes::IndicesIterF<D>":"indexes::IndicesIterF","iterators::AxisChunksIter<'a, A, D>":"iterators::AxisChunksIter","iterators::AxisChunksIterMut<'a, A, D>":"iterators::AxisChunksIterMut","iterators::AxisIter<'a, A, D>":"iterators::AxisIter","iterators::AxisIterCore<A, D>":"iterators::AxisIterCore","iterators::AxisIterMut<'a, A, D>":"iterators::AxisIterMut","iterators::Baseiter<A, D>":"iterators::Baseiter","iterators::ElementsBase<'a, A, D>":"iterators::ElementsBase","iterators::ElementsBaseMut<'a, A, D>":"iterators::ElementsBaseMut","iterators::ElementsRepr<S, C>":"iterators::ElementsRepr","iterators::IndexedIter<'a, A, D>":"iterators::IndexedIter","iterators::IndexedIterMut<'a, A, D>":"iterators::IndexedIterMut","iterators::Iter<'a, A, D>":"iterators::Iter","iterators::IterMut<'a, A, D>":"iterators::IterMut","iterators::LanesIter<'a, A, D>":"iterators::LanesIter","iterators::LanesIterMut<'a, A, D>":"iterators::LanesIterMut","iterators::chunks::ExactChunks<'a, A, D>":"iterators::chunks::ExactChunks","iterators::chunks::ExactChunksIter<'a, A, D>":"iterators::chunks::ExactChunksIter","iterators::chunks::ExactChunksIterMut<'a, A, D>":"iterators::chunks::ExactChunksIterMut","iterators::chunks::ExactChunksMut<'a, A, D>":"iterators::chunks::ExactChunksMut","iterators::lanes::Lanes<'a, A, D>":"iterators::lanes::Lanes","iterators::lanes::LanesMut<'a, A, D>":"iterators::lanes::LanesMut","iterators::windows::Windows<'a, A, D>":"iterators::windows::Windows","iterators::windows::WindowsIter<'a, A, D>":"iterators::windows::WindowsIter","layout::Layout":"layout::Layout","linspace::Linspace<F>":"linspace::Linspace","logspace::Logspace<F>":"logspace::Logspace","private::PrivateMarker":"private::PrivateMarker","slice::Slice":"slice::Slice","slice::SliceInfo<T, D>":"slice::SliceInfo","slice::SliceOrIndex":"slice::SliceOrIndex","zip::FoldWhile<T>":"zip::FoldWhile","zip::Zip<Parts, D>":"zip::Zip"}}