{"dependencies":{"<PodCastError as core::clone::Clone>::clone":["PodCastError"],"<PodCastError as core::cmp::Eq>::assert_receiver_is_total_eq":["PodCastError"],"<PodCastError as core::cmp::PartialEq>::eq":["PodCastError"],"<PodCastError as core::fmt::Debug>::fmt":["PodCastError","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<PodCastError as core::fmt::Display>::fmt":["PodCastError","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<PodCastError as core::hash::Hash>::hash":["PodCastError","core::hash::Hasher","core::marker::Sized"],"PodCastError":["PodCastError"],"bytes_of":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"bytes_of_mut":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"cast":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"cast_mut":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"cast_ref":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"cast_slice":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"cast_slice_mut":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"contiguous::Contiguous::from_integer":["core::marker::Sized","core::option::Option"],"contiguous::Contiguous::into_integer":[],"from_bytes":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"from_bytes_mut":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"pod_align_to":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"pod_align_to_mut":["core::arch::x86_64::__m128","core::marker::Sized","pod::Pod"],"something_went_wrong":["PodCastError"],"transparent::TransparentWrapper::wrap_mut":[],"transparent::TransparentWrapper::wrap_ref":[],"try_cast":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"try_cast_mut":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"try_cast_ref":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"try_cast_slice":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"try_cast_slice_mut":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"try_from_bytes":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"try_from_bytes_mut":["core::arch::x86_64::__m128","core::marker::Sized","core::result::Result","pod::Pod"],"zeroable::Zeroable::zeroed":[]},"glob_path_import":{"contiguous":"","offset_of":"","pod":"","transparent":"","zeroable":""},"self_to_fn":{"PodCastError":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl core::fmt::Display for PodCastError {\n  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n    write!(f, \"{:?}\", self)\n  }\n}"],"core::arch::x86_64::__m128":["unsafe impl Pod for x86_64::__m128 {}","unsafe impl Zeroable for x86_64::__m128 {}"],"core::arch::x86_64::__m128d":["unsafe impl Pod for x86_64::__m128d {}","unsafe impl Zeroable for x86_64::__m128d {}"],"core::arch::x86_64::__m128i":["unsafe impl Pod for x86_64::__m128i {}","unsafe impl Zeroable for x86_64::__m128i {}"],"core::arch::x86_64::__m256":["unsafe impl Pod for x86_64::__m256 {}","unsafe impl Zeroable for x86_64::__m256 {}"],"core::arch::x86_64::__m256d":["unsafe impl Pod for x86_64::__m256d {}","unsafe impl Zeroable for x86_64::__m256d {}"],"core::arch::x86_64::__m256i":["unsafe impl Pod for x86_64::__m256i {}","unsafe impl Zeroable for x86_64::__m256i {}"],"core::marker::PhantomData":["unsafe impl<T: Pod> Pod for PhantomData<T> {}","unsafe impl<T: Zeroable> Zeroable for PhantomData<T> {}"],"core::mem::ManuallyDrop":["unsafe impl<T: Pod> Pod for ManuallyDrop<T> {}","unsafe impl<T: Zeroable> Zeroable for ManuallyDrop<T> {}"],"core::num::NonZeroU128":["unsafe impl Contiguous for $src {\n      type Int = $repr;\n      const MAX_VALUE: $repr = $max;\n      const MIN_VALUE: $repr = $min;\n    }"],"core::num::NonZeroU16":["unsafe impl Contiguous for $src {\n      type Int = $repr;\n      const MAX_VALUE: $repr = $max;\n      const MIN_VALUE: $repr = $min;\n    }"],"core::num::NonZeroU32":["unsafe impl Contiguous for $src {\n      type Int = $repr;\n      const MAX_VALUE: $repr = $max;\n      const MIN_VALUE: $repr = $min;\n    }"],"core::num::NonZeroU64":["unsafe impl Contiguous for $src {\n      type Int = $repr;\n      const MAX_VALUE: $repr = $max;\n      const MIN_VALUE: $repr = $min;\n    }"],"core::num::NonZeroU8":["unsafe impl Contiguous for $src {\n      type Int = $repr;\n      const MAX_VALUE: $repr = $max;\n      const MIN_VALUE: $repr = $min;\n    }"],"core::num::NonZeroUsize":["unsafe impl Contiguous for $src {\n      type Int = $repr;\n      const MAX_VALUE: $repr = $max;\n      const MIN_VALUE: $repr = $min;\n    }"],"core::num::Wrapping":["unsafe impl<T: Pod> Pod for Wrapping<T> {}","unsafe impl<T: Zeroable> Zeroable for Wrapping<T> {}","unsafe impl<T> TransparentWrapper<T> for core::num::Wrapping<T> {}"],"core::option::Option":["unsafe impl Pod for Option<NonZeroI128> {}","unsafe impl Pod for Option<NonZeroI16> {}","unsafe impl Pod for Option<NonZeroI32> {}","unsafe impl Pod for Option<NonZeroI64> {}","unsafe impl Pod for Option<NonZeroI8> {}","unsafe impl Pod for Option<NonZeroIsize> {}","unsafe impl Pod for Option<NonZeroU128> {}","unsafe impl Pod for Option<NonZeroU16> {}","unsafe impl Pod for Option<NonZeroU32> {}","unsafe impl Pod for Option<NonZeroU64> {}","unsafe impl Pod for Option<NonZeroU8> {}","unsafe impl Pod for Option<NonZeroUsize> {}","unsafe impl Zeroable for Option<NonZeroI128> {}","unsafe impl Zeroable for Option<NonZeroI16> {}","unsafe impl Zeroable for Option<NonZeroI32> {}","unsafe impl Zeroable for Option<NonZeroI64> {}","unsafe impl Zeroable for Option<NonZeroI8> {}","unsafe impl Zeroable for Option<NonZeroIsize> {}","unsafe impl Zeroable for Option<NonZeroU128> {}","unsafe impl Zeroable for Option<NonZeroU16> {}","unsafe impl Zeroable for Option<NonZeroU32> {}","unsafe impl Zeroable for Option<NonZeroU64> {}","unsafe impl Zeroable for Option<NonZeroU8> {}","unsafe impl Zeroable for Option<NonZeroUsize> {}","unsafe impl<T: 'static> Pod for Option<NonNull<T>> {}","unsafe impl<T> Zeroable for Option<NonNull<T>> {}"]},"single_path_import":{"core":"core"},"srcs":{"<PodCastError as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n    write!(f, \"{:?}\", self)\n  }","Real(LocalPath(\"src/lib.rs\"))"],"PodCastError":["/// The things that can go wrong when casting between [`Pod`] data forms.\npub enum PodCastError {\n  /// You tried to cast a slice to an element type with a higher alignment\n  /// requirement but the slice wasn't aligned.\n  TargetAlignmentGreaterAndInputNotAligned,\n  /// If the element size changes then the output slice changes length\n  /// accordingly. If the output slice wouldn't be a whole number of elements\n  /// then the conversion fails.\n  OutputSliceWouldHaveSlop,\n  /// When casting a slice you can't convert between ZST elements and non-ZST\n  /// elements. When casting an individual `T`, `&T`, or `&mut T` value the\n  /// source size and destination size must be an exact match.\n  SizeMismatch,\n  /// For this type of cast the alignments must be exactly the same and they\n  /// were not so now you're sad.\n  ///\n  /// This error is generated **only** by operations that cast allocated types\n  /// (such as `Box` and `Vec`), because in that case the alignment must stay\n  /// exact.\n  AlignmentMismatch,\n}","Real(LocalPath(\"src/lib.rs\"))"],"bytes_of":["/// Re-interprets `&T` as `&[u8]`.\n///\n/// Any ZST becomes an empty slice, and in that case the pointer value of that\n/// empty slice might not match the pointer value of the input reference.\n#[inline]\npub fn bytes_of<T: Pod>(t: &T) -> &[u8]{\n  match try_cast_slice::<T, u8>(core::slice::from_ref(t)) {\n    Ok(s) => s,\n    Err(_) => unreachable!(),\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"bytes_of_mut":["/// Re-interprets `&mut T` as `&mut [u8]`.\n///\n/// Any ZST becomes an empty slice, and in that case the pointer value of that\n/// empty slice might not match the pointer value of the input reference.\n#[inline]\npub fn bytes_of_mut<T: Pod>(t: &mut T) -> &mut [u8]{\n  match try_cast_slice_mut::<T, u8>(core::slice::from_mut(t)) {\n    Ok(s) => s,\n    Err(_) => unreachable!(),\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"cast":["/// Cast `T` into `U`\n///\n/// ## Panics\n///\n/// * This is like [`try_cast`](try_cast), but will panic on a size mismatch.\n#[inline]\npub fn cast<A: Pod, B: Pod>(a: A) -> B{\n  if size_of::<A>() == size_of::<B>() {\n    unsafe { core::mem::transmute_copy(&a) }\n  } else {\n    something_went_wrong(\"cast\", PodCastError::SizeMismatch)\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"cast_mut":["/// Cast `&mut T` into `&mut U`.\n///\n/// ## Panics\n///\n/// This is [`try_cast_mut`] but will panic on error.\n#[inline]\npub fn cast_mut<A: Pod, B: Pod>(a: &mut A) -> &mut B{\n  if size_of::<A>() == size_of::<B>() && align_of::<A>() >= align_of::<B>() {\n    // Plz mr compiler, just notice that we can't ever hit Err in this case.\n    match try_cast_mut(a) {\n      Ok(b) => b,\n      Err(_) => unreachable!(),\n    }\n  } else {\n    match try_cast_mut(a) {\n      Ok(b) => b,\n      Err(e) => something_went_wrong(\"cast_mut\", e),\n    }\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"cast_ref":["/// Cast `&T` into `&U`.\n///\n/// ## Panics\n///\n/// This is [`try_cast_ref`] but will panic on error.\n#[inline]\npub fn cast_ref<A: Pod, B: Pod>(a: &A) -> &B{\n  if size_of::<A>() == size_of::<B>() && align_of::<A>() >= align_of::<B>() {\n    // Plz mr compiler, just notice that we can't ever hit Err in this case.\n    match try_cast_ref(a) {\n      Ok(b) => b,\n      Err(_) => unreachable!(),\n    }\n  } else {\n    match try_cast_ref(a) {\n      Ok(b) => b,\n      Err(e) => something_went_wrong(\"cast_ref\", e),\n    }\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"cast_slice":["/// Cast `&[A]` into `&[B]`.\n///\n/// ## Panics\n///\n/// This is [`try_cast_slice`] but will panic on error.\n#[inline]\npub fn cast_slice<A: Pod, B: Pod>(a: &[A]) -> &[B]{\n  match try_cast_slice(a) {\n    Ok(b) => b,\n    Err(e) => something_went_wrong(\"cast_slice\", e),\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"cast_slice_mut":["/// Cast `&mut [T]` into `&mut [U]`.\n///\n/// ## Panics\n///\n/// This is [`try_cast_slice_mut`] but will panic on error.\n#[inline]\npub fn cast_slice_mut<A: Pod, B: Pod>(a: &mut [A]) -> &mut [B]{\n  match try_cast_slice_mut(a) {\n    Ok(b) => b,\n    Err(e) => something_went_wrong(\"cast_slice_mut\", e),\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"contiguous::Contiguous":["/// A trait indicating that:\n///\n/// 1. A type has an equivalent representation to some known integral type.\n/// 2. All instances of this type fall in a fixed range of values.\n/// 3. Within that range, there are no gaps.\n///\n/// This is generally useful for fieldless enums (aka \"c-style\" enums), however\n/// it's important that it only be used for those with an explicit `#[repr]`, as\n/// `#[repr(Rust)]` fieldess enums have an unspecified layout.\n///\n/// Additionally, you shouldn't assume that all implementations are enums. Any\n/// type which meets the requirements above while following the rules under\n/// \"Safety\" below is valid.\n///\n/// # Example\n///\n/// ```\n/// # use bytemuck::Contiguous;\n/// #[repr(u8)]\n/// #[derive(Debug, Copy, Clone, PartialEq)]\n/// enum Foo {\n///   A = 0,\n///   B = 1,\n///   C = 2,\n///   D = 3,\n///   E = 4,\n/// }\n/// unsafe impl Contiguous for Foo {\n///   type Int = u8;\n///   const MIN_VALUE: u8 = Foo::A as u8;\n///   const MAX_VALUE: u8 = Foo::E as u8;\n/// }\n/// assert_eq!(Foo::from_integer(3).unwrap(), Foo::D);\n/// assert_eq!(Foo::from_integer(8), None);\n/// assert_eq!(Foo::C.into_integer(), 2);\n/// ```\n/// # Safety\n///\n/// This is an unsafe trait, and incorrectly implementing it is undefined\n/// behavior.\n///\n/// Informally, by implementing it, you're asserting that `C` is identical to\n/// the integral type `C::Int`, and that every `C` falls between `C::MIN_VALUE`\n/// and `C::MAX_VALUE` exactly once, without any gaps.\n///\n/// Precisely, the guarantees you must uphold when implementing `Contiguous` for\n/// some type `C` are:\n///\n/// 1. The size of `C` and `C::Int` must be the same, and neither may be a ZST.\n///    (Note: alignment is explicitly allowed to differ)\n///\n/// 2. `C::Int` must be a primitive integer, and not a wrapper type. In the\n///    future, this may be lifted to include cases where the behavior is\n///    identical for a relevant set of traits (Ord, arithmetic, ...).\n///\n/// 3. All `C::Int`s which are in the *inclusive* range between `C::MIN_VALUE`\n///    and `C::MAX_VALUE` are bitwise identical to unique valid instances of\n///    `C`.\n///\n/// 4. There exist no instances of `C` such that their bitpatterns, when\n///    interpreted as instances of `C::Int`, fall outside of the `MAX_VALUE` /\n///    `MIN_VALUE` range -- It is legal for unsafe code to assume that if it\n///    gets a `C` that implements `Contiguous`, it is in the appropriate range.\n///\n/// 5. Finally, you promise not to provide overridden implementations of\n///    `Contiguous::from_integer` and `Contiguous::into_integer`.\n///\n/// For clarity, the following rules could be derived from the above, but are\n/// listed explicitly:\n///\n/// - `C::MAX_VALUE` must be greater or equal to `C::MIN_VALUE` (therefore, `C`\n///   must be an inhabited type).\n///\n/// - There exist no two values between `MIN_VALUE` and `MAX_VALUE` such that\n///   when interpreted as a `C` they are considered identical (by, say, match).\npub unsafe trait Contiguous: Copy + 'static {\n  /// The primitive integer type with an identical representation to this\n  /// type.\n  ///\n  /// Contiguous is broadly intended for use with fieldless enums, and for\n  /// these the correct integer type is easy: The enum should have a\n  /// `#[repr(Int)]` or `#[repr(C)]` attribute, (if it does not, it is\n  /// *unsound* to implement `Contiguous`!).\n  ///\n  /// - For `#[repr(Int)]`, use the listed `Int`. e.g. `#[repr(u8)]` should\n  ///   use `type Int = u8`.\n  ///\n  /// - For `#[repr(C)]`, use whichever type the C compiler will use to\n  ///   represent the given enum. This is usually `c_int` (from `std::os::raw`\n  ///   or `libc`), but it's up to you to make the determination as the\n  ///   implementer of the unsafe trait.\n  ///\n  /// For precise rules, see the list under \"Safety\" above.\n  type Int: Copy + Ord;\n\n  /// The upper *inclusive* bound for valid instances of this type.\n  const MAX_VALUE: Self::Int;\n\n  /// The lower *inclusive* bound for valid instances of this type.\n  const MIN_VALUE: Self::Int;\n\n  /// If `value` is within the range for valid instances of this type,\n  /// returns `Some(converted_value)`, otherwise, returns `None`.\n  ///\n  /// This is a trait method so that you can write `value.into_integer()` in\n  /// your code. It is a contract of this trait that if you implement\n  /// `Contiguous` on your type you **must not** override this method.\n  ///\n  /// # Panics\n  ///\n  /// We will not panic for any correct implementation of `Contiguous`, but\n  /// *may* panic if we detect an incorrect one.\n  ///\n  /// This is undefined behavior regardless, so it could have been the nasal\n  /// demons at that point anyway ;).\n  #[inline]\n  fn from_integer(value: Self::Int) -> Option<Self> {\n    // Guard against an illegal implementation of Contiguous. Annoyingly we\n    // can't rely on `transmute` to do this for us (see below), but\n    // whatever, this gets compiled into nothing in release.\n    assert!(size_of::<Self>() == size_of::<Self::Int>());\n    if Self::MIN_VALUE <= value && value <= Self::MAX_VALUE {\n      // SAFETY: We've checked their bounds (and their size, even though\n      // they've sworn under the Oath Of Unsafe Rust that that already\n      // matched) so this is allowed by `Contiguous`'s unsafe contract.\n      //\n      // So, the `transmute_copy`. ideally we'd use transmute here, which\n      // is more obviously safe. Sadly, we can't, as these types still\n      // have unspecified sizes.\n      Some(unsafe { transmute_copy::<Self::Int, Self>(&value) })\n    } else {\n      None\n    }\n  }\n\n  /// Perform the conversion from `C` into the underlying integral type. This\n  /// mostly exists otherwise generic code would need unsafe for the `value as\n  /// integer`\n  ///\n  /// This is a trait method so that you can write `value.into_integer()` in\n  /// your code. It is a contract of this trait that if you implement\n  /// `Contiguous` on your type you **must not** override this method.\n  ///\n  /// # Panics\n  ///\n  /// We will not panic for any correct implementation of `Contiguous`, but\n  /// *may* panic if we detect an incorrect one.\n  ///\n  /// This is undefined behavior regardless, so it could have been the nasal\n  /// demons at that point anyway ;).\n  #[inline]\n  fn into_integer(self) -> Self::Int {\n    // Guard against an illegal implementation of Contiguous. Annoyingly we\n    // can't rely on `transmute` to do the size check for us (see\n    // `from_integer's comment`), but whatever, this gets compiled into\n    // nothing in release. Note that we don't check the result of cast\n    assert!(size_of::<Self>() == size_of::<Self::Int>());\n\n    // SAFETY: The unsafe contract requires that these have identical\n    // representations, and that the range be entirely valid. Using\n    // transmute_copy instead of transmute here is annoying, but is required\n    // as `Self` and `Self::Int` have unspecified sizes still.\n    unsafe { transmute_copy::<Self, Self::Int>(&self) }\n  }\n}","Real(LocalPath(\"src/contiguous.rs\"))"],"contiguous::Contiguous::from_integer":["/// If `value` is within the range for valid instances of this type,\n/// returns `Some(converted_value)`, otherwise, returns `None`.\n///\n/// This is a trait method so that you can write `value.into_integer()` in\n/// your code. It is a contract of this trait that if you implement\n/// `Contiguous` on your type you **must not** override this method.\n///\n/// # Panics\n///\n/// We will not panic for any correct implementation of `Contiguous`, but\n/// *may* panic if we detect an incorrect one.\n///\n/// This is undefined behavior regardless, so it could have been the nasal\n/// demons at that point anyway ;).\n#[inline]\nfn from_integer(value: Self::Int) -> Option<Self>{\n    // Guard against an illegal implementation of Contiguous. Annoyingly we\n    // can't rely on `transmute` to do this for us (see below), but\n    // whatever, this gets compiled into nothing in release.\n    assert!(size_of::<Self>() == size_of::<Self::Int>());\n    if Self::MIN_VALUE <= value && value <= Self::MAX_VALUE {\n      // SAFETY: We've checked their bounds (and their size, even though\n      // they've sworn under the Oath Of Unsafe Rust that that already\n      // matched) so this is allowed by `Contiguous`'s unsafe contract.\n      //\n      // So, the `transmute_copy`. ideally we'd use transmute here, which\n      // is more obviously safe. Sadly, we can't, as these types still\n      // have unspecified sizes.\n      Some(unsafe { transmute_copy::<Self::Int, Self>(&value) })\n    } else {\n      None\n    }\n  }","Real(LocalPath(\"src/contiguous.rs\"))"],"contiguous::Contiguous::into_integer":["/// Perform the conversion from `C` into the underlying integral type. This\n/// mostly exists otherwise generic code would need unsafe for the `value as\n/// integer`\n///\n/// This is a trait method so that you can write `value.into_integer()` in\n/// your code. It is a contract of this trait that if you implement\n/// `Contiguous` on your type you **must not** override this method.\n///\n/// # Panics\n///\n/// We will not panic for any correct implementation of `Contiguous`, but\n/// *may* panic if we detect an incorrect one.\n///\n/// This is undefined behavior regardless, so it could have been the nasal\n/// demons at that point anyway ;).\n#[inline]\nfn into_integer(self) -> Self::Int{\n    // Guard against an illegal implementation of Contiguous. Annoyingly we\n    // can't rely on `transmute` to do the size check for us (see\n    // `from_integer's comment`), but whatever, this gets compiled into\n    // nothing in release. Note that we don't check the result of cast\n    assert!(size_of::<Self>() == size_of::<Self::Int>());\n\n    // SAFETY: The unsafe contract requires that these have identical\n    // representations, and that the range be entirely valid. Using\n    // transmute_copy instead of transmute here is annoying, but is required\n    // as `Self` and `Self::Int` have unspecified sizes still.\n    unsafe { transmute_copy::<Self, Self::Int>(&self) }\n  }","Real(LocalPath(\"src/contiguous.rs\"))"],"from_bytes":["/// Re-interprets `&[u8]` as `&T`.\n///\n/// ## Panics\n///\n/// This is [`try_from_bytes`] but will panic on error.\n#[inline]\npub fn from_bytes<T: Pod>(s: &[u8]) -> &T{\n  match try_from_bytes(s) {\n    Ok(t) => t,\n    Err(e) => something_went_wrong(\"from_bytes\", e),\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"from_bytes_mut":["/// Re-interprets `&mut [u8]` as `&mut T`.\n///\n/// ## Panics\n///\n/// This is [`try_from_bytes_mut`] but will panic on error.\n#[inline]\npub fn from_bytes_mut<T: Pod>(s: &mut [u8]) -> &mut T{\n  match try_from_bytes_mut(s) {\n    Ok(t) => t,\n    Err(e) => something_went_wrong(\"from_bytes_mut\", e),\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"pod::Pod":["/// Marker trait for \"plain old data\".\n///\n/// The point of this trait is that once something is marked \"plain old data\"\n/// you can really go to town with the bit fiddling and bit casting. Therefore,\n/// it's a relatively strong claim to make about a type. Do not add this to your\n/// type casually.\n///\n/// **Reminder:** The results of casting around bytes between data types are\n/// _endian dependant_. Little-endian machines are the most common, but\n/// big-endian machines do exist (and big-endian is also used for \"network\n/// order\" bytes).\n///\n/// ## Safety\n///\n/// * The type must be inhabited (eg: no\n///   [Infallible](core::convert::Infallible)).\n/// * The type must allow any bit pattern (eg: no `bool` or `char`, which have\n///   illegal bit patterns).\n/// * The type must not contain any padding bytes, either in the middle or on\n///   the end (eg: no `#[repr(C)] struct Foo(u8, u16)`, which has padding in the\n///   middle, and also no `#[repr(C)] struct Foo(u16, u8)`, which has padding on\n///   the end).\n/// * The type needs to have all fields also be `Pod`.\n/// * The type needs to be `repr(C)` or `repr(transparent)`. In the case of\n///   `repr(C)`, the `packed` and `align` repr modifiers can be used as long as\n///   all other rules end up being followed.\npub unsafe trait Pod: Zeroable + Copy + 'static {}","Real(LocalPath(\"src/pod.rs\"))"],"pod_align_to":["/// As `align_to`, but safe because of the [`Pod`] bound.\n#[inline]\npub fn pod_align_to<T: Pod, U: Pod>(vals: &[T]) -> (&[T], &[U], &[T]){\n  unsafe { vals.align_to::<U>() }\n}","Real(LocalPath(\"src/lib.rs\"))"],"pod_align_to_mut":["/// As `align_to_mut`, but safe because of the [`Pod`] bound.\n#[inline]\npub fn pod_align_to_mut<T: Pod, U: Pod>(\n  vals: &mut [T],\n) -> (&mut [T], &mut [U], &mut [T]){\n  unsafe { vals.align_to_mut::<U>() }\n}","Real(LocalPath(\"src/lib.rs\"))"],"something_went_wrong":["/// Immediately panics.\n#[cold]\n#[inline(never)]\nfn something_went_wrong(src: &str, err: PodCastError) -> !{\n  // Note(Lokathor): Keeping the panic here makes the panic _formatting_ go\n  // here too, which helps assembly readability and also helps keep down\n  // the inline pressure.\n  panic!(\"{src}>{err:?}\", src = src, err = err)\n}","Real(LocalPath(\"src/lib.rs\"))"],"transparent::TransparentWrapper":["/// A trait which indicates that a type is a `repr(transparent)` wrapper around\n/// the `Wrapped` value.\n///\n/// This allows safely creating references to `T` from those to the `Wrapped`\n/// type, using the `wrap_ref` and `wrap_mut` functions.\n///\n/// # Safety\n///\n/// The safety contract of `TransparentWrapper` is relatively simple:\n///\n/// For a given `Wrapper` which implements `TransparentWrapper<Wrapped>`:\n///\n/// 1. Wrapper must be a `#[repr(transparent)]` wrapper around `Wrapped`. This\n///    either means that it must be a `#[repr(transparent)]` struct which\n///    contains a either a field of type `Wrapped` (or a field of some other\n///    transparent wrapper for `Wrapped`) as the only non-ZST field.\n///\n/// 2. Any fields *other* than the `Wrapped` field must be trivially\n///    constructable ZSTs, for example `PhantomData`, `PhantomPinned`, etc.\n///\n/// 3. The `Wrapper` may not impose additional alignment requirements over\n///    `Wrapped`.\n///     - Note: this is currently guaranteed by `repr(transparent)`, but there\n///       have been discussions of lifting it, so it's stated here explicitly.\n///\n/// 4. The `wrap_ref` and `wrap_mut` functions on `TransparentWrapper` may not\n///    be overridden.\n///\n/// ## Caveats\n///\n/// If the wrapper imposes additional constraints upon the wrapped type which\n/// are required for safety, it's responsible for ensuring those still hold --\n/// this generally requires preventing access to instances of the wrapped type,\n/// as implementing `TransparentWrapper<U> for T` means anybody can call\n/// `T::cast_ref(any_instance_of_u)`.\n///\n/// For example, it would be invalid to implement TransparentWrapper for `str`\n/// to implement `TransparentWrapper` around `[u8]` because of this.\n///\n/// # Examples\n///\n/// ## Basic\n///\n/// ```\n/// use bytemuck::TransparentWrapper;\n/// # #[derive(Default)]\n/// # struct SomeStruct(u32);\n///\n/// #[repr(transparent)]\n/// struct MyWrapper(SomeStruct);\n///\n/// unsafe impl TransparentWrapper<SomeStruct> for MyWrapper {}\n///\n/// // interpret a reference to &SomeStruct as a &MyWrapper\n/// let thing = SomeStruct::default();\n/// let wrapped_ref: &MyWrapper = MyWrapper::wrap_ref(&thing);\n///\n/// // Works with &mut too.\n/// let mut mut_thing = SomeStruct::default();\n/// let wrapped_mut: &mut MyWrapper = MyWrapper::wrap_mut(&mut mut_thing);\n///\n/// # let _ = (wrapped_ref, wrapped_mut); // silence warnings\n/// ```\n///\n/// ## Use with dynamically sized types\n///\n/// ```\n/// use bytemuck::TransparentWrapper;\n///\n/// #[repr(transparent)]\n/// struct Slice<T>([T]);\n///\n/// unsafe impl<T> TransparentWrapper<[T]> for Slice<T> {}\n///\n/// let s = Slice::wrap_ref(&[1u32, 2, 3]);\n/// assert_eq!(&s.0, &[1, 2, 3]);\n///\n/// let mut buf = [1, 2, 3u8];\n/// let sm = Slice::wrap_mut(&mut buf);\n/// ```\npub unsafe trait TransparentWrapper<Wrapped: ?Sized> {\n  /// Convert a reference to a wrapped type into a reference to the wrapper.\n  ///\n  /// This is a trait method so that you can write `MyType::wrap_ref(...)` in\n  /// your code. It is part of the safety contract for this trait that if you\n  /// implement `TransparentWrapper<_>` for your type you **must not** override\n  /// this method.\n  #[inline]\n  fn wrap_ref(s: &Wrapped) -> &Self {\n    unsafe {\n      assert!(size_of::<*const Wrapped>() == size_of::<*const Self>());\n      // Using a pointer cast doesn't work here because rustc can't tell that the\n      // vtables match (if we lifted the ?Sized restriction, this would go away),\n      // and transmute doesn't work for the usual reasons it doesn't work inside\n      // generic functions.\n      //\n      // SAFETY: The unsafe contract requires that these have identical\n      // representations. Using this transmute_copy instead of transmute here is\n      // annoying, but is required as `Self` and `Wrapped` have unspecified\n      // sizes still.\n      let wrapped_ptr = s as *const Wrapped;\n      let wrapper_ptr: *const Self = transmute_copy(&wrapped_ptr);\n      &*wrapper_ptr\n    }\n  }\n\n  /// Convert a mut reference to a wrapped type into a mut reference to the\n  /// wrapper.\n  ///\n  /// This is a trait method so that you can write `MyType::wrap_mut(...)` in\n  /// your code. It is part of the safety contract for this trait that if you implement\n  /// `TransparentWrapper<_>` for your type you **must not** override this method.\n  #[inline]\n  fn wrap_mut(s: &mut Wrapped) -> &mut Self {\n    unsafe {\n      assert!(size_of::<*mut Wrapped>() == size_of::<*mut Self>());\n      // Using a pointer cast doesn't work here because rustc can't tell that the\n      // vtables match (if we lifted the ?Sized restriction, this would go away),\n      // and transmute doesn't work for the usual reasons it doesn't work inside\n      // generic functions.\n      //\n      // SAFETY: The unsafe contract requires that these have identical\n      // representations. Using this transmute_copy instead of transmute here is\n      // annoying, but is required as `Self` and `Wrapped` have unspecified\n      // sizes still.\n      let wrapped_ptr = s as *mut Wrapped;\n      let wrapper_ptr: *mut Self = transmute_copy(&wrapped_ptr);\n      &mut *wrapper_ptr\n    }\n  }\n}","Real(LocalPath(\"src/transparent.rs\"))"],"transparent::TransparentWrapper::wrap_mut":["/// Convert a mut reference to a wrapped type into a mut reference to the\n/// wrapper.\n///\n/// This is a trait method so that you can write `MyType::wrap_mut(...)` in\n/// your code. It is part of the safety contract for this trait that if you implement\n/// `TransparentWrapper<_>` for your type you **must not** override this method.\n#[inline]\nfn wrap_mut(s: &mut Wrapped) -> &mut Self{\n    unsafe {\n      assert!(size_of::<*mut Wrapped>() == size_of::<*mut Self>());\n      // Using a pointer cast doesn't work here because rustc can't tell that the\n      // vtables match (if we lifted the ?Sized restriction, this would go away),\n      // and transmute doesn't work for the usual reasons it doesn't work inside\n      // generic functions.\n      //\n      // SAFETY: The unsafe contract requires that these have identical\n      // representations. Using this transmute_copy instead of transmute here is\n      // annoying, but is required as `Self` and `Wrapped` have unspecified\n      // sizes still.\n      let wrapped_ptr = s as *mut Wrapped;\n      let wrapper_ptr: *mut Self = transmute_copy(&wrapped_ptr);\n      &mut *wrapper_ptr\n    }\n  }","Real(LocalPath(\"src/transparent.rs\"))"],"transparent::TransparentWrapper::wrap_ref":["/// Convert a reference to a wrapped type into a reference to the wrapper.\n///\n/// This is a trait method so that you can write `MyType::wrap_ref(...)` in\n/// your code. It is part of the safety contract for this trait that if you\n/// implement `TransparentWrapper<_>` for your type you **must not** override\n/// this method.\n#[inline]\nfn wrap_ref(s: &Wrapped) -> &Self{\n    unsafe {\n      assert!(size_of::<*const Wrapped>() == size_of::<*const Self>());\n      // Using a pointer cast doesn't work here because rustc can't tell that the\n      // vtables match (if we lifted the ?Sized restriction, this would go away),\n      // and transmute doesn't work for the usual reasons it doesn't work inside\n      // generic functions.\n      //\n      // SAFETY: The unsafe contract requires that these have identical\n      // representations. Using this transmute_copy instead of transmute here is\n      // annoying, but is required as `Self` and `Wrapped` have unspecified\n      // sizes still.\n      let wrapped_ptr = s as *const Wrapped;\n      let wrapper_ptr: *const Self = transmute_copy(&wrapped_ptr);\n      &*wrapper_ptr\n    }\n  }","Real(LocalPath(\"src/transparent.rs\"))"],"try_cast":["/// Try to cast `T` into `U`.\n///\n/// Note that for this particular type of cast, alignment isn't a factor. The\n/// input value is semantically copied into the function and then returned to a\n/// new memory location which will have whatever the required alignment of the\n/// output type is.\n///\n/// ## Failure\n///\n/// * If the types don't have the same size this fails.\n#[inline]\npub fn try_cast<A: Pod, B: Pod>(a: A) -> Result<B, PodCastError>{\n  if size_of::<A>() == size_of::<B>() {\n    Ok(unsafe { core::mem::transmute_copy(&a) })\n  } else {\n    Err(PodCastError::SizeMismatch)\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"try_cast_mut":["/// Try to convert a `&mut T` into `&mut U`.\n///\n/// As [`try_cast_ref`], but `mut`.\n#[inline]\npub fn try_cast_mut<A: Pod, B: Pod>(a: &mut A) -> Result<&mut B, PodCastError>{\n  // Note(Lokathor): everything with `align_of` and `size_of` will optimize away\n  // after monomorphization.\n  if align_of::<B>() > align_of::<A>()\n    && (a as *mut A as usize) % align_of::<B>() != 0\n  {\n    Err(PodCastError::TargetAlignmentGreaterAndInputNotAligned)\n  } else if size_of::<B>() == size_of::<A>() {\n    Ok(unsafe { &mut *(a as *mut A as *mut B) })\n  } else {\n    Err(PodCastError::SizeMismatch)\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"try_cast_ref":["/// Try to convert a `&T` into `&U`.\n///\n/// ## Failure\n///\n/// * If the reference isn't aligned in the new type\n/// * If the source type and target type aren't the same size.\n#[inline]\npub fn try_cast_ref<A: Pod, B: Pod>(a: &A) -> Result<&B, PodCastError>{\n  // Note(Lokathor): everything with `align_of` and `size_of` will optimize away\n  // after monomorphization.\n  if align_of::<B>() > align_of::<A>()\n    && (a as *const A as usize) % align_of::<B>() != 0\n  {\n    Err(PodCastError::TargetAlignmentGreaterAndInputNotAligned)\n  } else if size_of::<B>() == size_of::<A>() {\n    Ok(unsafe { &*(a as *const A as *const B) })\n  } else {\n    Err(PodCastError::SizeMismatch)\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"try_cast_slice":["/// Try to convert `&[A]` into `&[B]` (possibly with a change in length).\n///\n/// * `input.as_ptr() as usize == output.as_ptr() as usize`\n/// * `input.len() * size_of::<A>() == output.len() * size_of::<B>()`\n///\n/// ## Failure\n///\n/// * If the target type has a greater alignment requirement and the input slice\n///   isn't aligned.\n/// * If the target element type is a different size from the current element\n///   type, and the output slice wouldn't be a whole number of elements when\n///   accounting for the size change (eg: 3 `u16` values is 1.5 `u32` values, so\n///   that's a failure).\n/// * Similarly, you can't convert between a [ZST](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)\n///   and a non-ZST.\n#[inline]\npub fn try_cast_slice<A: Pod, B: Pod>(a: &[A]) -> Result<&[B], PodCastError>{\n  // Note(Lokathor): everything with `align_of` and `size_of` will optimize away\n  // after monomorphization.\n  if align_of::<B>() > align_of::<A>()\n    && (a.as_ptr() as usize) % align_of::<B>() != 0\n  {\n    Err(PodCastError::TargetAlignmentGreaterAndInputNotAligned)\n  } else if size_of::<B>() == size_of::<A>() {\n    Ok(unsafe { core::slice::from_raw_parts(a.as_ptr() as *const B, a.len()) })\n  } else if size_of::<A>() == 0 || size_of::<B>() == 0 {\n    Err(PodCastError::SizeMismatch)\n  } else if core::mem::size_of_val(a) % size_of::<B>() == 0 {\n    let new_len = core::mem::size_of_val(a) / size_of::<B>();\n    Ok(unsafe { core::slice::from_raw_parts(a.as_ptr() as *const B, new_len) })\n  } else {\n    Err(PodCastError::OutputSliceWouldHaveSlop)\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"try_cast_slice_mut":["/// Try to convert `&mut [A]` into `&mut [B]` (possibly with a change in\n/// length).\n///\n/// As [`try_cast_slice`], but `&mut`.\n#[inline]\npub fn try_cast_slice_mut<A: Pod, B: Pod>(\n  a: &mut [A],\n) -> Result<&mut [B], PodCastError>{\n  // Note(Lokathor): everything with `align_of` and `size_of` will optimize away\n  // after monomorphization.\n  if align_of::<B>() > align_of::<A>()\n    && (a.as_mut_ptr() as usize) % align_of::<B>() != 0\n  {\n    Err(PodCastError::TargetAlignmentGreaterAndInputNotAligned)\n  } else if size_of::<B>() == size_of::<A>() {\n    Ok(unsafe {\n      core::slice::from_raw_parts_mut(a.as_mut_ptr() as *mut B, a.len())\n    })\n  } else if size_of::<A>() == 0 || size_of::<B>() == 0 {\n    Err(PodCastError::SizeMismatch)\n  } else if core::mem::size_of_val(a) % size_of::<B>() == 0 {\n    let new_len = core::mem::size_of_val(a) / size_of::<B>();\n    Ok(unsafe {\n      core::slice::from_raw_parts_mut(a.as_mut_ptr() as *mut B, new_len)\n    })\n  } else {\n    Err(PodCastError::OutputSliceWouldHaveSlop)\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"try_from_bytes":["/// Re-interprets `&[u8]` as `&T`.\n///\n/// ## Failure\n///\n/// * If the slice isn't aligned for the new type\n/// * If the slice's length isn’t exactly the size of the new type\n#[inline]\npub fn try_from_bytes<T: Pod>(s: &[u8]) -> Result<&T, PodCastError>{\n  if s.len() != size_of::<T>() {\n    Err(PodCastError::SizeMismatch)\n  } else if (s.as_ptr() as usize) % align_of::<T>() != 0 {\n    Err(PodCastError::TargetAlignmentGreaterAndInputNotAligned)\n  } else {\n    Ok(unsafe { &*(s.as_ptr() as *const T) })\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"try_from_bytes_mut":["/// Re-interprets `&mut [u8]` as `&mut T`.\n///\n/// ## Failure\n///\n/// * If the slice isn't aligned for the new type\n/// * If the slice's length isn’t exactly the size of the new type\n#[inline]\npub fn try_from_bytes_mut<T: Pod>(\n  s: &mut [u8],\n) -> Result<&mut T, PodCastError>{\n  if s.len() != size_of::<T>() {\n    Err(PodCastError::SizeMismatch)\n  } else if (s.as_ptr() as usize) % align_of::<T>() != 0 {\n    Err(PodCastError::TargetAlignmentGreaterAndInputNotAligned)\n  } else {\n    Ok(unsafe { &mut *(s.as_mut_ptr() as *mut T) })\n  }\n}","Real(LocalPath(\"src/lib.rs\"))"],"zeroable::Zeroable":["/// Trait for types that can be safely created with\n/// [`zeroed`](core::mem::zeroed).\n///\n/// An all-zeroes value may or may not be the same value as the\n/// [Default](core::default::Default) value of the type.\n///\n/// ## Safety\n///\n/// * Your type must be inhabited (eg: no\n///   [Infallible](core::convert::Infallible)).\n/// * Your type must be allowed to be an \"all zeroes\" bit pattern (eg: no\n///   [`NonNull<T>`](core::ptr::NonNull)).\npub unsafe trait Zeroable: Sized {\n  /// Calls [`zeroed`](core::mem::zeroed).\n  ///\n  /// This is a trait method so that you can write `MyType::zeroed()` in your\n  /// code. It is a contract of this trait that if you implement it on your type\n  /// you **must not** override this method.\n  #[inline]\n  fn zeroed() -> Self {\n    unsafe { core::mem::zeroed() }\n  }\n}","Real(LocalPath(\"src/zeroable.rs\"))"],"zeroable::Zeroable::zeroed":["/// Calls [`zeroed`](core::mem::zeroed).\n///\n/// This is a trait method so that you can write `MyType::zeroed()` in your\n/// code. It is a contract of this trait that if you implement it on your type\n/// you **must not** override this method.\n#[inline]\nfn zeroed() -> Self{\n    unsafe { core::mem::zeroed() }\n  }","Real(LocalPath(\"src/zeroable.rs\"))"]},"struct_constructor":{"!":["something_went_wrong"],"&[B]":["cast_slice"],"&[u8]":["bytes_of"],"&mut [B]":["cast_slice_mut"],"&mut [u8]":["bytes_of_mut"],"(&[T], &[U], &[T])":["pod_align_to"],"(&mut [T], &mut [U], &mut [T])":["pod_align_to_mut"],"<Self as contiguous::Contiguous>::Int":["into_integer"],"PodCastError":["clone"],"bool":["eq"],"core::option::Option":["from_integer"],"core::result::Result":["fmt","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from_bytes","try_from_bytes_mut"]},"struct_to_trait":{"PodCastError":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::fmt::Display","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"core::arch::x86_64::__m128":["pod::Pod","zeroable::Zeroable"],"core::arch::x86_64::__m128d":["pod::Pod","zeroable::Zeroable"],"core::arch::x86_64::__m128i":["pod::Pod","zeroable::Zeroable"],"core::arch::x86_64::__m256":["pod::Pod","zeroable::Zeroable"],"core::arch::x86_64::__m256d":["pod::Pod","zeroable::Zeroable"],"core::arch::x86_64::__m256i":["pod::Pod","zeroable::Zeroable"],"core::marker::PhantomData":["pod::Pod","zeroable::Zeroable"],"core::mem::ManuallyDrop":["pod::Pod","zeroable::Zeroable"],"core::num::NonZeroU128":["contiguous::Contiguous"],"core::num::NonZeroU16":["contiguous::Contiguous"],"core::num::NonZeroU32":["contiguous::Contiguous"],"core::num::NonZeroU64":["contiguous::Contiguous"],"core::num::NonZeroU8":["contiguous::Contiguous"],"core::num::NonZeroUsize":["contiguous::Contiguous"],"core::num::Wrapping":["pod::Pod","transparent::TransparentWrapper","zeroable::Zeroable"],"core::option::Option":["pod::Pod","zeroable::Zeroable"]},"targets":{"<PodCastError as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"bytes_of":["bytes_of","Real(LocalPath(\"src/lib.rs\"))",""],"bytes_of_mut":["bytes_of_mut","Real(LocalPath(\"src/lib.rs\"))",""],"cast":["cast","Real(LocalPath(\"src/lib.rs\"))",""],"cast_mut":["cast_mut","Real(LocalPath(\"src/lib.rs\"))",""],"cast_ref":["cast_ref","Real(LocalPath(\"src/lib.rs\"))",""],"cast_slice":["cast_slice","Real(LocalPath(\"src/lib.rs\"))",""],"cast_slice_mut":["cast_slice_mut","Real(LocalPath(\"src/lib.rs\"))",""],"contiguous::Contiguous::from_integer":["from_integer","Real(LocalPath(\"src/contiguous.rs\"))",""],"contiguous::Contiguous::into_integer":["into_integer","Real(LocalPath(\"src/contiguous.rs\"))",""],"from_bytes":["from_bytes","Real(LocalPath(\"src/lib.rs\"))",""],"from_bytes_mut":["from_bytes_mut","Real(LocalPath(\"src/lib.rs\"))",""],"pod_align_to":["pod_align_to","Real(LocalPath(\"src/lib.rs\"))",""],"pod_align_to_mut":["pod_align_to_mut","Real(LocalPath(\"src/lib.rs\"))",""],"something_went_wrong":["something_went_wrong","Real(LocalPath(\"src/lib.rs\"))",""],"transparent::TransparentWrapper::wrap_mut":["wrap_mut","Real(LocalPath(\"src/transparent.rs\"))",""],"transparent::TransparentWrapper::wrap_ref":["wrap_ref","Real(LocalPath(\"src/transparent.rs\"))",""],"try_cast":["try_cast","Real(LocalPath(\"src/lib.rs\"))",""],"try_cast_mut":["try_cast_mut","Real(LocalPath(\"src/lib.rs\"))",""],"try_cast_ref":["try_cast_ref","Real(LocalPath(\"src/lib.rs\"))",""],"try_cast_slice":["try_cast_slice","Real(LocalPath(\"src/lib.rs\"))",""],"try_cast_slice_mut":["try_cast_slice_mut","Real(LocalPath(\"src/lib.rs\"))",""],"try_from_bytes":["try_from_bytes","Real(LocalPath(\"src/lib.rs\"))",""],"try_from_bytes_mut":["try_from_bytes_mut","Real(LocalPath(\"src/lib.rs\"))",""],"zeroable::Zeroable::zeroed":["zeroed","Real(LocalPath(\"src/zeroable.rs\"))",""]},"trait_to_struct":{"contiguous::Contiguous":["core::num::NonZeroU128","core::num::NonZeroU16","core::num::NonZeroU32","core::num::NonZeroU64","core::num::NonZeroU8","core::num::NonZeroUsize"],"core::clone::Clone":["PodCastError"],"core::cmp::Eq":["PodCastError"],"core::cmp::PartialEq":["PodCastError"],"core::fmt::Debug":["PodCastError"],"core::fmt::Display":["PodCastError"],"core::hash::Hash":["PodCastError"],"core::marker::Copy":["PodCastError"],"core::marker::StructuralEq":["PodCastError"],"core::marker::StructuralPartialEq":["PodCastError"],"pod::Pod":["core::arch::x86_64::__m128","core::arch::x86_64::__m128d","core::arch::x86_64::__m128i","core::arch::x86_64::__m256","core::arch::x86_64::__m256d","core::arch::x86_64::__m256i","core::marker::PhantomData","core::mem::ManuallyDrop","core::num::Wrapping","core::option::Option"],"transparent::TransparentWrapper":["core::num::Wrapping"],"zeroable::Zeroable":["core::arch::x86_64::__m128","core::arch::x86_64::__m128d","core::arch::x86_64::__m128i","core::arch::x86_64::__m256","core::arch::x86_64::__m256d","core::arch::x86_64::__m256i","core::marker::PhantomData","core::mem::ManuallyDrop","core::num::Wrapping","core::option::Option"]},"type_to_def_path":{"PodCastError":"PodCastError"}}